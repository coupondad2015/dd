<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dungeons Deep ‚Äî ASCII Roguelike</title>
  <link rel="icon" href="/images/icons/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="96x96" href="/images/icons/favicon-96x96.png">
  <link rel="icon" type="image/svg+xml" href="/images/icons/favicon.svg">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png">
  <link rel="manifest" href="/images/icons/site.webmanifest">
  <meta name="theme-color" content="#000000">
  <style>
  .skip-btn{
    margin-left: 12px;
    width: 40px;
    height: 32px;
    border-radius: 10px;
    border: 1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.04);
    color: rgba(230,240,255,.95);
    cursor: pointer;
    line-height: 1;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }
  .skip-btn:hover{
    background: rgba(255,255,255,.06);
    border-color: rgba(255,255,255,.24);
  }

    #restartBtn.btn-lose{
      border-color: rgba(220,50,50,.9);
      color: #ffd0d0;
      box-shadow: 0 0 0 1px rgba(220,50,50,.25), 0 0 18px rgba(220,50,50,.18);
    }
    #restartBtn.btn-win{
      border-color: rgba(70,220,120,.9);
      color: #d8ffe4;
      box-shadow: 0 0 0 1px rgba(70,220,120,.22), 0 0 18px rgba(70,220,120,.14);
    }
.hud-debug{
    margin-top: 6px;
    padding: 4px 8px;
    font-size: 11px;
    opacity: 0.75;
    border: 1px dashed rgba(255,255,255,.20);
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    border-radius: 10px;
  }
:root { color-scheme: dark; }
    body{
      margin:0;
      min-height:100vh;
      background:#0b0f12;
      color:#cfd8dc;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      display:flex;
      justify-content:center;
      align-items:stretch;
    }
    .wrap{ width:min(1100px, 98vw); padding:12px; height:100vh; box-sizing:border-box; display:flex; flex-direction:column; gap:10px; }

    .panel{
      background:#0f151a;
      border:1px solid #1b2a33;
      border-radius:12px;
      padding:10px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    /* === Compact full-width header band === */
    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
    }
    .header{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:8px 10px; /* tighter */
    }
    .header-left{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      flex: 1 1 auto;
      min-width: 0;
    }
    .header-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex:0 0 auto;
    }

    /* HUD: single-line terminal-style header */
    .hud{
      display:flex;
      flex-wrap:wrap;
      gap: 0;
      align-items:baseline;
      min-width:0;
      font-size:18px;
      line-height:1.1;
      white-space:nowrap;
    }
    .hud .hud-item{
      display:inline-flex;
      align-items:baseline;
      gap:6px;
      padding: 0 18px 0 0;
      border:none;
      background:transparent;
      border-radius:0;
      white-space:nowrap;
    }
    .hud .muted{ opacity:.92; }
/* Logo replaces the title pill */
    .hud-item.title.hud-logo{
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        padding: 0 !important;
    }

    .hud-ico{
      height:18px;
      width:auto;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      margin-right: 6px;
      vertical-align: -3px;
      filter: saturate(0.95) contrast(1.05);
    }

    .hud-logo img{
        height: 38px;      /* tweak to taste */
        width: auto;
        display: block;
    }

    kbd{
      border:1px solid #2a3b45; border-bottom-width:2px;
      padding:0 6px; border-radius:6px; background:#0b1115;
      font-size:12px;
      display:inline-block;
      margin:0 1px;
    }
    
    
    /* Control key color-coding + hover help */
    kbd.pkey{ cursor: help; }
    kbd.p-heal{  border-color:#c96ad6; color:#c96ad6; }
    kbd.p-poison{border-color:#2dd36f; color:#2dd36f; }
    kbd.p-invis{ border-color:#90a4ae; color:#90a4ae; }
    kbd.p-trans{ border-color:#caa66a; color:#caa66a; }
    kbd.p-invinc{border-color:#ff5b5b; color:#ff5b5b; }
    kbd.p-tele{  border-color:#7aa2ff; color:#7aa2ff; }

/* Controls side panel */
    .controls-panel .controls-title{
      margin-bottom:10px;
      font-size:14px;
    }
    .controls-body{
      display:flex;
      gap:12px;
      align-items:flex-start;
    }
    .controls-keypad{
      width: 150px;
      height: auto;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      filter: saturate(.9) contrast(1.05);
    }
    .controls-lines{
      display:flex;
      flex-direction:column;
      gap:8px;
      font-size:12px;
      opacity:.95;
    }
    .controls-muted{
      opacity:.85;
    }
button{
      background:#0b1115; color:#cfd8dc;
      border:1px solid #2a3b45;
      border-radius:10px;
      padding:8px 10px;
      cursor:pointer;
      font-family:inherit;
    }
    button:hover{ border-color:#3c5664; }

    
    .main{
      flex:1;
      min-height:0; /* allow children to scroll instead of pushing layout */
      display:grid;
      grid-template-columns: 1fr 340px;
      grid-template-rows: 1fr auto;
      grid-template-areas:
        "screen sidebar"
        "messages .";
      gap:10px;
      align-items:stretch;
    }
    .screen-panel{ grid-area: screen; min-height:0; }
    .screen-panel .panel{ height:100%; }
    .messages-panel{ grid-area: messages; }
    
    .sidebar{
      grid-area: sidebar;
      display:flex;
      flex-direction:column;
      gap:10px;
      max-height: calc(100vh - 140px); /* keep messages visible */
      overflow-y: auto;
      padding-right: 4px;
    }

    @media (max-width: 980px){
      .main{
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
        grid-template-areas:
          "screen"
          "messages"
          "sidebar";
      }
      .sidebar{ height:auto; max-height:none; overflow:visible; padding-right:0; }
    }

    #screen{
      white-space:pre;
      font-size:14px;
      user-select:none;
      overflow:auto;

      /* responsive viewport height */
      height: clamp(320px, calc(100vh - 220px), 620px);
      min-height: 320px;
      max-height: 620px;

      line-height:0.9;
      letter-spacing:0.2em;

      font-family:
        "JetBrains Mono",
        "Cascadia Mono",
        "Fira Code",
        Consolas,
        monospace;
    }

    .logline{ opacity:.92; }
    .logline.prompt{ color:#e6e6e6; font-style:italic; opacity:.98; }
    
.logline.lore{
  margin-left:1.25em;
  font-style:italic;
  opacity:0.78;
}
.logline.warn{ color:#ffd166; opacity:.98; }
    .logline.hit{ color:#ff6b6b; opacity:.98; }
    .logline.loot{ color:#a7ffeb; opacity:.98; }
    .logline.sys{ color:#9be7ff; opacity:.95; }

    /* --- Message accent spans (subtle, targeted) --- */
    .msg-gold{ color:#ffd166; }
    .msg-cgold{ color:#b71c1c; }
    .msg-weapon{ color:#ffd166; }
    .msg-key{ color:#ffd166; }
    .msg-secret{ color:#9be7ff; }
    .msg-intro{ color:#9be7ff; opacity:.98; }
    .msg-potion-heal{ color:#ff6bd6; }
    .msg-potion-poison{ color:#68ff79; }
    .msg-potion-invis{ color:#b0bec5; }
    .msg-potion-trans{ color:#d4a373; }
    .msg-potion-invinc{ color:#ff4d4d; }
    .msg-scroll{ color:#b7f0ff; }
    .msg-prompt-hl{ color:#e6e6e6; opacity:.98; }

    .panel.log{
      overflow:auto;
      max-height: 220px;
    }
    .panel.log .logline{ padding: 2px 0; }
.logline.prompt{
      font-style: italic;
      opacity: 0.95;
    }
    .dim { opacity:.35; }

    .legend h3, .log h3 { margin:0 0 8px 0; font-size:14px; }
    .legend-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:4px 10px; /* tighter */
      font-size:12px;
    }
    .legend-item{
      display:flex;
      gap:6px;
      align-items:baseline;
      padding:1px 0; /* tighter */
      border:none;           /* remove pill border */
      border-radius:0;
      background:transparent;
    }
    .legend-item:hover{ opacity:1; }
    
    .glyph{
      min-width: 18px;
      text-align:center;
      font-weight:700;
    }
    .legend-note{
      margin-top:8px;
      font-size:11px;
      opacity:.9;
      border-top:1px solid #1b2a33;
      padding-top:8px;
      line-height:1.25;
    }
    .footer-note{
      margin-top:10px;
      font-size:12px;
      opacity:.85;
    }
    .pill{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #2a3b45;
      background:#0b1115;
      font-size:12px;
      margin-left:6px;
    }
    .promptline{
      margin-top:8px;
      padding:8px 10px;
      border:1px solid #2a3b45;
      border-radius:12px;
      background:#0b1115;
      font-size:12px;
    }

    /* Prompt rendered inline at bottom of Messages panel */
    .logprompt{
      margin-top:8px;
      padding:8px 10px;
      border-top:1px solid #1b2a33;
      background:#0b1115;
      font-size:12px;
    }

    /* Effects as inline chips */
    .effects{
      display:inline-flex;
      flex-wrap:wrap;
      gap:6px;
      align-items:center;
      margin:0;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid #2a3b45;
      background:#0b1115;
      font-size:12px;
      white-space:nowrap;
      opacity:.95;
    }

    /* Collapsible legend */
    .legend-toggle{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background:#0b1115;
      color:#cfd8dc;
      border:1px solid #2a3b45;
      border-radius:10px;
      padding:8px 10px;
      cursor:pointer;
      font-family:inherit;
      font-size:13px;
    }
    .legend-toggle:hover{ border-color:#3c5664; }
    .legend-body[data-collapsed="true"]{ display:none; }
    .chev{
      display:inline-block;
      transition: transform 120ms ease;
    }
    .legend-toggle[aria-expanded="true"] .chev{ transform: rotate(180deg); }

    /* Mute button (music) */
    .mute-btn{
      margin-left: 18px; /* not too close to Reset */
      width: 44px;
      height: 36px;
      border-radius: 12px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:16px;
    }
    .mute-btn.is-muted{
      opacity: .75;
    }

/* --- Glyph Canvas Renderer (ASCII-exact) --- */
#screenWrap{ position: relative; }
#screenCanvas{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  pointer-events:none;
}

/* === SPLASH INTRO (<=5s) === */
#splash {
  position: fixed;
  inset: 0;
  z-index: 99999;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
}
#splash.hidden { display:none; }

.splash-frame {
  width: min(980px, 94vw);
  aspect-ratio: 16/9;
  border-radius: 20px;
  background: #06080a;
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: 0 30px 80px rgba(0,0,0,.65);
  overflow: hidden;
  position: relative;
  transform: translateZ(0);
}

.splash-reveal {
  position: absolute;
  inset: 0;
  background-image: url("/images/dd_logo.jpg");
  background-size: cover;
  background-position: center;
  image-rendering: auto;
  filter: contrast(1.12) saturate(0.92);
  transform: scale(1.02);
  /* unfurl from top-to-bottom, then scroll away */
  animation: ddSplashSeq 4.9s cubic-bezier(.2,.7,.15,1) forwards;
  will-change: transform, clip-path, opacity;
}

.splash-reveal::after {
  /* subtle vignette */
  content:"";
  position:absolute;
  inset:0;
  background:
    radial-gradient(ellipse at center, rgba(0,0,0,0) 42%, rgba(0,0,0,.42) 92%),
    linear-gradient(180deg, rgba(0,0,0,.30), rgba(0,0,0,0) 30%, rgba(0,0,0,.22));
  pointer-events:none;
}

.splash-crt {
  position:absolute;
  inset:0;
  pointer-events:none;
}
.splash-crt::before {
  /* scanlines */
  content:"";
  position:absolute;
  inset:-2px;
  background: repeating-linear-gradient(
    to bottom,
    rgba(255,255,255,.05) 0px,
    rgba(255,255,255,.05) 1px,
    rgba(0,0,0,.00) 2px,
    rgba(0,0,0,.00) 4px
  );
  opacity: .22;
  mix-blend-mode: overlay;
}
.splash-crt::after {
  /* phosphor / tube bloom */
  content:"";
  position:absolute;
  inset:0;
  background:
    radial-gradient(circle at 50% 50%, rgba(120,200,255,.10), rgba(0,0,0,0) 55%),
    radial-gradient(circle at 30% 40%, rgba(255,120,120,.06), rgba(0,0,0,0) 55%),
    radial-gradient(circle at 70% 60%, rgba(120,255,170,.06), rgba(0,0,0,0) 55%);
  opacity: .35;
  mix-blend-mode: screen;
  animation: ddCrtFlicker 0.18s steps(2,end) infinite;
}

.splash-hint {
  position:absolute;
  left: 14px;
  bottom: 12px;
  font-size: 12px;
  letter-spacing: .06em;
  color: rgba(230,240,255,.82);
  text-shadow: 0 2px 12px rgba(0,0,0,.75);
  user-select:none;
}

@keyframes ddCrtFlicker {
  0%{ opacity:.30; transform: translateY(0); }
  50%{ opacity:.42; transform: translateY(.3px); }
  100%{ opacity:.33; transform: translateY(0); }
}

@keyframes ddSplashSeq {
  /* start hidden */
  0% {
    opacity: 0;
    transform: translateY(10px) scale(1.01);
    clip-path: inset(0 0 100% 0);
  }
  /* fade in + begin unfurl */
  8% {
    opacity: 1;
    transform: translateY(0) scale(1.02);
    clip-path: inset(0 0 88% 0);
  }
  /* unfurl reveal */
  55% {
    opacity: 1;
    transform: translateY(0) scale(1.02);
    clip-path: inset(0 0 0% 0);
  }
  /* brief hold */
  80% {
    opacity: 1;
    transform: translateY(0) scale(1.02);
    clip-path: inset(0 0 0% 0);
  }
  /* scroll away */
  100% {
    opacity: 0;
    transform: translateY(-140%) scale(1.02);
    clip-path: inset(0 0 0% 0);
  }
}

</style>
</head>
<body>

  <!-- === SPLASH INTRO === -->
  <div id="splash" aria-label="Dungeons Deep splash">
    <div class="splash-frame">
      <div class="splash-reveal" id="splashReveal"></div>
      <div class="splash-crt" aria-hidden="true"></div>
      <div class="splash-hint">press any key to skip</div>
    </div>
  </div>

  <div class="wrap">
    <div class="topbar">
      <div class="panel header">
        <div class="header-left">
          <div class="hud" id="hud"></div>
        </div>
        <div class="header-right">
          <button id="restartBtn">Reset</button>
          <button id="muteBtn" class="mute-btn" title="Mute / unmute music" aria-pressed="false">üîä</button>
          <button id="skipBtn" class="skip-btn" title="Skip current track" aria-label="Skip track">‚è≠</button>
        </div>
      </div>
    </div>

    
    <div class="main">
      <div class="panel screen-panel">
        <div id="screenWrap">
          <div id="screen" aria-label="game screen"></div>
          <canvas id="screenCanvas" aria-label="Glyph canvas"></canvas>
        </div>
      </div>

      <div class="messages-panel">
        <div class="panel log" id="log"></div>
      </div>

      <div class="sidebar">
        <div class="panel controls-panel">
        <button class="legend-toggle" id="controlsToggle" aria-expanded="true">
          <span><b>Controls</b></span>
          <span class="chev">‚ñæ</span>
        </button>
        <div class="legend-body" id="controlsBody" style="margin-top:10px;" data-collapsed="false">
<div class="controls-body">
          <img class="controls-keypad" src="/images/ui/keypad.png" alt="Movement keys" />
          <div class="controls-lines">
            <div><b>Wait</b> <kbd title="Wait (.)">.</kbd></div>
            <div><b>Descend</b> <kbd title="Descend (&gt;)">&gt;</kbd></div>
            <div style="margin-top:6px;"><b>Heal</b> <kbd class="pkey p-heal" title="Heal (P)">P</kbd></div>
            <div class="controls-muted">Potions:
              <kbd class="pkey p-poison" title="Poison (0)">0</kbd>/<kbd class="pkey p-invis" title="Invisibility (1)">1</kbd>/<kbd class="pkey p-trans" title="Transmutation (2)">2</kbd>/<kbd class="pkey p-invinc" title="Invincibility (3)">3</kbd>/<kbd class="pkey p-tele" title="Teleport (4)">4</kbd>
            </div>
          </div>
        </div>
      </div> <!-- /controlsBody -->
        </div>

        <div class="panel legend">
        <button class="legend-toggle" id="legendToggle" aria-expanded="false">
          <span><b>Legend</b></span>
          <span class="chev">‚ñæ</span>
        </button>
        <div class="legend-body" id="legendBody" style="margin-top:10px;">
          <div id="legend" class="legend-grid"></div>
          <div class="legend-note" id="legendNote"></div>
        </div>

        <div class="panel tips-panel">
          <button class="legend-toggle" id="tipsToggle" aria-expanded="true">
            <span><b>Tips</b></span>
            <span class="chev">‚ñæ</span>
          </button>
          <div class="legend-body" id="tipsBody" style="margin-top:10px;" data-collapsed="false">
            <div class="footer-note">
                    doors <span class="pill">#</span>/<span class="pill">/</span> block chokepoints until opened by bumping,
          locked doors <span class="pill">X</span> need keys from chests <span class="pill">$</span> (or can be forced),
          torches <span class="pill">t</span> restore sight (carry 2),
          traders <span class="pill" style="border-color:#ffd166;color:#ffd166;">T</span> sell goods.
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

  <audio id="bgm" src="/music/dungeons deep.mp3" preload="auto"></audio>

<script>
  let __visualLoopStarted = false;
  let __wrapRO = null;

  // DEBUG enable: add ?debug=1 to URL (or press F2 to toggle)
  try{
    const qp = new URLSearchParams(location.search);
    if(qp.get("debug")==="1") window.DEBUG = true;
  }catch(e){}
  window.addEventListener("keydown", (e)=>{
    if(e.key === "F2"){
      e.preventDefault();
      window.DEBUG = !window.DEBUG;
      try{ syncModes(); }catch(_){ }
      try{ applyRenderMode(); }catch(_){ }
      try{ addMsg(window.DEBUG ? "DEBUG: ON" : "DEBUG: OFF"); }catch(_){}
      try{ renderGlyphCanvas(); }catch(_){}
    }
  });

(() => {
  // ============================================================
  // DUNGEONS DEEP ‚Äî Drop-in HTML
  // Key change (per request): keys are primarily stored in chests
  // so opening a chest grants a "keychain" all at once.
  // ============================================================

  // ---------- CONFIG ----------
  let DEBUG = false; // default ON: start with a full potion belt for testing

  const MAP_W = 80;
  const DUNGEON_H = 28;
  // Extra vertical space for embedded cave systems (below the main dungeon)
  const CAVE_PAD_H = 4;
  const CAVE_BAND_H = 20;
  const MAP_H = DUNGEON_H + CAVE_PAD_H + CAVE_BAND_H;
  const CAVE_Y0 = DUNGEON_H + CAVE_PAD_H;

  function isInCaves(y){ return y >= CAVE_Y0; }

  const VIEW_W = 60, VIEW_H = 18;

  // ---------- Scroll helper ----------
  // Reveal the entire current level by marking all tiles as "seen".
  function revealEntireLevel(lvl){
    if(!lvl || !lvl.seen) return;
    for(let x=0; x<MAP_W; x++){
      for(let y=0; y<MAP_H; y++){
        lvl.seen[x][y] = true;
      }
    }
  }

  // Vision (torch system)
  const VISION_DARK = 2;
  const VISION_DEFAULT = 8;
  const TORCH_CAP = 2;
  const TORCH_BURN_MOVES = 40;
  const TORCH_DIM_STEP_MOVES = 5;

  const ROOM_ATTEMPTS = 140;
  const ROOMS_MIN = 8, ROOMS_MAX = 14;
  const ROOM_W = [5, 13], ROOM_H = [4, 9];

  // Secret content tuning
  const SECRET_ROOM_MIN = 1;
  const SECRET_ROOM_MAX = 3;
  const SECRET_REVEAL_CHANCE = 0.50;
  const SECRET_SHORTCUT_CHANCE = 0.20;
  const SECRET_TRAP_MULT = 2.2;
  const SECRET_REWARD_MULT = 2;

  // Trader tuning
  const TRADER_SPAWN_CHANCE = 0.22;
  const TRADER_POTION_COST = 12;
  const TRADER_WEAPON_COST = 25;
  const TRADER_WEAPON_ATK_BONUS = 1;

  const POTION_CAP = 30;
const DEFAULT_HEAL_POTIONS = 3; // starting healing potions (non-debug)
  const KEY_CAP = 5;

  // Vitality Shrines
  const MAX_HP_CAP = 32;
  const VITALITY_SHRINE_CHANCE = 0.40; // per level (max 1)
  const DEBUG_FORCE_VITALITY_SHRINE = false; // debug only: force a vitality shrine in the start room
  const SHRINE_BASE_GOLD_COST = 25;
  const SHRINE_GOLD_PER_LEVEL = 2;

  // Altar tuning
  const ALTAR_CHANCE = 0.22; // per level (max 1)
  const ALTAR_GOLD_COST = 100;
  const ALTAR_HP_BOOST_MIN = 1;
  const ALTAR_HP_BOOST_MAX = 3;

  // Door tuning
  const DOOR_CHANCE = 0.22;
  const LOCKED_DOOR_CHANCE = 0.28;

  // Locked-door safety valve
  const LOCKED_DOOR_BREAKS_WITHOUT_KEY = true;
  const LOCK_BREAK_DAMAGE = 2;

// Torches spawn ‚Äúfairly liberally‚Äù
  const TORCH_BASE_COUNT = 4;
  const TORCH_PER_LEVEL_BONUS = 1;
  const TORCH_BONUS_EVERY_LEVELS = 4;

  // Potion tuning
  const POTION_HEAL_RANGE = [6, 10];
  const POISON_STEPS = 5;
  const POISON_DMG_RANGE = [1, 2];
  const INVIS_STEPS = 35;
  const TRANSMUTE_STEPS = 20;
  const INVINCIBLE_STEPS = 40;

  // ---------- GLYPHS ----------
  const TILE = {
    ROCK: ' ',
    FLOOR: '.',
    CORR: ',',
    CORPSE: '_',
    BRIDGE_SPAN: ':',   // bridge span (walkable)
    BRIDGE_L: ']',      // bridge anchor (blocked)
    BRIDGE_R: '[',      // bridge anchor (blocked)
    DOOR_C: '#',
    DOOR_O: '/',
    LDOOR_C: 'X',
    LDOOR_O: '/',
    SD_C: 'S',
    SD_O: 's',
    DOWN: '>',
    SDOWN: '¬ª',
    CAVE_C: 'o', // cave entrance (closed)
    CAVE_O: 'O' , // cave entrance (opened)
    // Chaos Relic (caves only)
    TILE_CHAOS_RELIC: 'A' // rendered as glyph

  };

  
  // --- Debug / Safe Mode coupling ---
  if(typeof window.DEBUG !== "boolean") window.DEBUG = false;
  if(typeof window.SAFE_MODE !== "boolean") window.SAFE_MODE = false;

  function syncModes(){
    // Hard rule: DEBUG implies SAFE MODE
    if(window.DEBUG) window.SAFE_MODE = true;
  }

  function applyRenderMode(){
    const screen = document.getElementById("screen");
    const wrap = document.getElementById("screenWrap") || screen;
    if(!$screenCanvas || !screen) return;

    syncModes();

    if(window.SAFE_MODE){
      screen.style.visibility = "visible";
      $screenCanvas.style.display = "none";
      if(__wrapRO){
        try{ __wrapRO.disconnect(); }catch(e){}
        __wrapRO = null;
      }
      return;
    }

    // Canvas mode
    $screenCanvas.style.display = "block";
    screen.style.visibility = "hidden";

    if(!__wrapRO && wrap && typeof ResizeObserver !== "undefined"){
      __wrapRO = new ResizeObserver(() => {
        try{ resizeGlyphCanvas(); }catch(_){}
        try{ renderGlyphCanvas(); }catch(_){}
      });
      __wrapRO.observe(wrap);
    }
    try{ resizeGlyphCanvas(); }catch(_){}
  }

  // Initialize mode once DOM exists
  window.addEventListener("DOMContentLoaded", () => {
    try{ syncModes(); }catch(_){}
    try{ applyRenderMode(); }catch(_){}
  });

const ENT = {
    // PLAYER GLYPH: ‚ú• (sigil)

    PLAYER: '‚ú•',
    POTION: '!',
    CHEST: '$',
    WEAPON: '∆™',
    TRAP: '^',
    TRADER: 'T',
    TORCH: 't',

    SHRINE: '¬•',
    ALTAR: '–®',
    GOBLIN: 'g',
    ORC: 'o',
    SNAKE: '~',
    CUBE: 'O',
    DRAGON: '√ê',
    CRAWLER: '∆∫',
    WALKER: '—™',
    WRAITH: 'œ£',
    CYCLOPS: 'œæ',
    CYCLOPS_CHIEF: 'œø',
    SPIDER: '–∂',
    SPIDER_QUEEN: '–ñ',
    WYRM: 'œ†',
    WYRM_ELDER: '—Ø',
    SKELETON: '¬ß',
     HORROR: '∆ü'
  };

  // --- Chest glyph replacement (graphic) ---
  let __CHEST_IMG = null;
  function getChestImg(){
    if(__CHEST_IMG) return __CHEST_IMG;
    const img = new Image();
    img.decoding = "async";
    img.src = "data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D%27http%3A//www.w3.org/2000/svg%27%20width%3D%2764%27%20height%3D%2764%27%20viewBox%3D%270%200%2064%2064%27%3E%0A%3Crect%20x%3D%2710%27%20y%3D%2722%27%20width%3D%2744%27%20height%3D%2732%27%20rx%3D%274%27%20fill%3D%27%236b3f1a%27%20stroke%3D%27%232b180a%27%20stroke-width%3D%273%27/%3E%0A%3Crect%20x%3D%2710%27%20y%3D%2722%27%20width%3D%2744%27%20height%3D%2712%27%20rx%3D%274%27%20fill%3D%27%237a4a20%27%20stroke%3D%27%232b180a%27%20stroke-width%3D%273%27/%3E%0A%3Crect%20x%3D%2710%27%20y%3D%2734%27%20width%3D%2744%27%20height%3D%276%27%20fill%3D%27%232b180a%27%20opacity%3D%270.35%27/%3E%0A%3Crect%20x%3D%2728%27%20y%3D%2732%27%20width%3D%278%27%20height%3D%2714%27%20rx%3D%272%27%20fill%3D%27%23d7b24c%27%20stroke%3D%27%236b4b10%27%20stroke-width%3D%272%27/%3E%0A%3Ccircle%20cx%3D%2732%27%20cy%3D%2739%27%20r%3D%272.2%27%20fill%3D%27%236b4b10%27/%3E%0A%3Ctext%20x%3D%2732%27%20y%3D%2752%27%20text-anchor%3D%27middle%27%20font-family%3D%27monospace%27%20font-size%3D%2722%27%20font-weight%3D%27700%27%20fill%3D%27%2363e6a6%27%3E%24%3C/text%3E%0A%3C/svg%3E";
    __CHEST_IMG = img;
    return __CHEST_IMG;
  }

  // ---------- CORPSE GLYPHS (PNG, tinted at runtime) ----------
  // Put these files next to the HTML:
  // corpse_1_transparent.png ... corpse_5_transparent.png
  let __CORPSE_IMGS = null;
  let __CORPSE_TINT_CACHE = new Map(); // key: "v|#rrggbb" -> canvas

  function getCorpseImgs(){
    if(__CORPSE_IMGS) return __CORPSE_IMGS;
    const files = [
      "corpse_1_transparent.png",
      "corpse_2_transparent.png",
      "corpse_3_transparent.png",
      "corpse_4_transparent.png",
      "corpse_5_transparent.png",
    ];
    __CORPSE_IMGS = files.map(src => {
      const img = new Image();
      img.decoding = "async";
      img.src = src;
      return img;
    });
    return __CORPSE_IMGS;
  }

  function __hexToRgb(hex){
    hex = (hex||"").toString().trim();
    if(hex[0] === '#') hex = hex.slice(1);
    if(hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
    const n = parseInt(hex || "000000", 16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }
  function __rgbToHsl(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h=0,s=0,l=(max+min)/2;
    const d=max-min;
    if(d !== 0){
      s = d / (1 - Math.abs(2*l - 1));
      switch(max){
        case r: h = ((g-b)/d) % 6; break;
        case g: h = (b-r)/d + 2; break;
        case b: h = (r-g)/d + 4; break;
      }
      h *= 60; if(h < 0) h += 360;
    }
    return { h, s, l };
  }
  function __hslToRgb(h,s,l){
    h = (h%360+360)%360;
    const c = (1 - Math.abs(2*l - 1)) * s;
    const x = c * (1 - Math.abs((h/60)%2 - 1));
    const m = l - c/2;
    let r=0,g=0,b=0;
    if(h<60){ r=c; g=x; b=0; }
    else if(h<120){ r=x; g=c; b=0; }
    else if(h<180){ r=0; g=c; b=x; }
    else if(h<240){ r=0; g=x; b=c; }
    else if(h<300){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    return { r: Math.round((r+m)*255), g: Math.round((g+m)*255), b: Math.round((b+m)*255) };
  }
  function __isBonePixel(r,g,b){
    const { s, l } = __rgbToHsl(r,g,b);
    // Bone is bright + low-sat (keeps your bone material readable across tints)
    return (l > 0.70 && s < 0.28);
  }
  function tintCorpseSprite(img, monsterHex, strength=0.85){
    const key = `${img.src}|${monsterHex}|${strength}`;
    const cached = __CORPSE_TINT_CACHE.get(key);
    if(cached) return cached;
    if(!img || !img.width || !img.height) return null;

    const { r:mr, g:mg, b:mb } = __hexToRgb(monsterHex || "#ff6b6b");
    const mhsl = __rgbToHsl(mr,mg,mb);

    const c = document.createElement('canvas');
    c.width = img.width;
    c.height = img.height;
    const ctx = c.getContext('2d', { willReadFrequently: true });
    ctx.imageSmoothingEnabled = false;
    ctx.clearRect(0,0,c.width,c.height);
    ctx.drawImage(img,0,0);

    const im = ctx.getImageData(0,0,c.width,c.height);
    const d = im.data;
    for(let i=0;i<d.length;i+=4){
      const a = d[i+3];
      if(a === 0) continue;
      const r=d[i], g=d[i+1], b=d[i+2];
      if(__isBonePixel(r,g,b)) continue;
      const phsl = __rgbToHsl(r,g,b);
      const dh = (((mhsl.h - phsl.h + 540) % 360) - 180);
      const newH = phsl.h + dh * strength;
      // Keep your shading (l) intact; keep saturation but softly align to monster
      const newS = Math.min(1, phsl.s * (0.85 + 0.15*mhsl.s));
      const newL = phsl.l;
      const out = __hslToRgb(newH, newS, newL);
      d[i]=out.r; d[i+1]=out.g; d[i+2]=out.b;
    }
    ctx.putImageData(im,0,0);
    __CORPSE_TINT_CACHE.set(key, c);
    return c;
  }

  // Potion types
  const POTION = {
    HEAL: "heal",
    POISON: "poison",
    INVIS: "invis",
    TRANSMUTE: "transmute",
    INVINC: "invinc",
    TELE: "tele"};

  // ---------- COLORS ----------
  const COL = {
    fg: '#cfd8dc',
    wall: '#9fb3bf',
    floor: '#93a4ad',
    corr: '#7f8f98',
    door: '#ffd166',
    locked: '#ffb703',
    sdoor: '#c8b6ff',
    stairs: '#4dd0e1',
    shortcut: '#80cbc4',

    chest: '#f6f740',
    cgold: '#b71c1c',
    weapon: '#a7ffeb',
    trap: '#ff5252',
    torch: '#ffcf6b',

    shrine: "#9be7ff",
    potion_purple: '#ff6bd6',
    potion_green:  '#68ff79',
    potion_grey:   '#b0bec5',
    potion_ochre:  '#d4a373',
    potion_red:    '#ff4d4d',

    monster: '#ff6b6b',
    boss: '#ff8a65',
    player: '#ffffff',
    trader: '#ffd166',
    dim: '#6b7b84',
    rock: '#0b0f12',
    statue: '#6fe7ff',
    bat: '#7a5a3a',

    chaosRelic: "#d47cff" // purple/pink standout
  };

  const MONSTER_COLOR = {
    [ENT.GOBLIN]: COL.monster,
    [ENT.ORC]: COL.monster,
    [ENT.SNAKE]: '#66ff66',
    [ENT.CUBE]: '#55aaff',
    [ENT.DRAGON]: '#ff4444',
    [ENT.CRAWLER]: '#ffb347',
    [ENT.WALKER]: '#f5f5f5',
    [ENT.WRAITH]: '#bbaaff',

    [ENT.CYCLOPS]: '#d9c6a5',
    [ENT.CYCLOPS_CHIEF]: '#f2d35e',
    [ENT.SPIDER]: '#9ad1a1',
    [ENT.SPIDER_QUEEN]: '#d7ffb0',
    [ENT.WYRM]: '#7fb6ff',
    [ENT.WYRM_ELDER]: '#c8f0ff',
     [ENT.SKELETON]: '#e7e7e7',
     [ENT.HORROR]: COL.boss,
  
     ['‚ï¨']: '#cfd8dc',
     ['^']: '#b0bec5'
  };

  const POTION_COLOR = {
    [POTION.HEAL]: COL.potion_purple,
    [POTION.POISON]: COL.potion_green,
    [POTION.INVIS]: COL.potion_grey,
    [POTION.TRANSMUTE]: COL.potion_ochre,
    [POTION.INVINC]: COL.potion_red,
    [POTION.TELE]: "#7f8cff"};

  // ---------- SCROLLS (pickup now; effects later) ----------
  const SCROLL_GLYPHS = ["‚òº","‚ñ≤","Œ®","¬§"];
  const SCROLL_NAME = { "‚òº":"Illumination", "‚ñ≤":"Grounding", "Œ®":"Attunement", "¬§":"Diminution" };
  const SCROLL_COLOR = { "‚òº":"#ffe9a6", "‚ñ≤":"#d7c9a1", "Œ®":"#b7f0ff", "¬§":"#e3c8ff" };
  const SCROLL_CAP = 12;

  const POTION_NAME = {
    [POTION.HEAL]: "Healing",
    [POTION.POISON]: "Poison",
    [POTION.INVIS]: "Invisibility",
    [POTION.TRANSMUTE]: "Transmutation",
    [POTION.INVINC]: "Invincibility",
    [POTION.TELE]: "Teleportation"};

  const GLYPH_REGISTRY = [
    { glyph: ENT.PLAYER, name: "Player", color: COL.player },
    { glyph: '+', name: "Wall +", color: COL.wall },
    { glyph: '‚Äì', name: "Wall ‚Äì", color: COL.wall },
    { glyph: '|', name: "Wall |", color: COL.wall },
    { glyph: TILE.FLOOR, name: "Floor", color: COL.floor },
    { glyph: TILE.CORR, name: "Hall", color: COL.corr },
    { glyph: TILE.CORPSE, name: "Corpse", color: COL.monster },
    { glyph: TILE.BRIDGE_L, name: "Bridge Anchor", color: COL.wall },
    { glyph: TILE.BRIDGE_SPAN, name: "Bridge", color: COL.corr },
    { glyph: TILE.BRIDGE_R, name: "Bridge Anchor", color: COL.wall },

    { glyph: TILE.DOOR_C, name: "Door", color: COL.door },
    { glyph: TILE.DOOR_O, name: "Open", color: COL.door },
    { glyph: TILE.LDOOR_C, name: "Locked", color: COL.locked },

    { glyph: ENT.TORCH, name: "Torch", color: COL.torch },

    { glyph: ENT.SHRINE, name: "Vitality Shrine", color: COL.shrine },

    { glyph: TILE.SD_C, name: "Secret", color: COL.sdoor },
    { glyph: TILE.SD_O, name: "Open", color: COL.sdoor },
    { glyph: TILE.DOWN, name: "Down", color: COL.stairs },
    { glyph: TILE.SDOWN, name: "Skip", color: COL.shortcut },

    { glyph: ENT.TRADER, name: "Trader", color: COL.trader },

    { glyph: ENT.POTION, name: "Heal (purple)", color: POTION_COLOR[POTION.HEAL] },
    { glyph: ENT.POTION, name: "Poison (green)", color: POTION_COLOR[POTION.POISON] },
    { glyph: ENT.POTION, name: "Invis (grey)", color: POTION_COLOR[POTION.INVIS] },
    { glyph: ENT.POTION, name: "Trans (ochre)", color: POTION_COLOR[POTION.TRANSMUTE] },
    { glyph: ENT.POTION, name: "Invinc (red)", color: POTION_COLOR[POTION.INVINC] },

    { glyph: ENT.CHEST, name: "Chest", color: COL.chest },
    { glyph: ENT.WEAPON, name: "Weapon", color: COL.weapon },
    { glyph: ENT.TRAP, name: "Trap", color: COL.trap },

    { glyph: ENT.GOBLIN, name: "Goblin", color: MONSTER_COLOR[ENT.GOBLIN] },
    { glyph: ENT.ORC, name: "Orc", color: MONSTER_COLOR[ENT.ORC] },
    { glyph: ENT.SNAKE, name: "Snake", color: MONSTER_COLOR[ENT.SNAKE] },
    { glyph: ENT.CUBE, name: "Cube", color: MONSTER_COLOR[ENT.CUBE] },
    { glyph: ENT.DRAGON, name: "Dragon", color: MONSTER_COLOR[ENT.DRAGON] },
    { glyph: ENT.CRAWLER, name: "Crawler", color: MONSTER_COLOR[ENT.CRAWLER] },
    { glyph: ENT.WALKER, name: "Walker", color: MONSTER_COLOR[ENT.WALKER] },
    { glyph: ENT.WRAITH, name: "Wraith", color: MONSTER_COLOR[ENT.WRAITH] },
    { glyph: ENT.CYCLOPS, name: "Cyclops", color: MONSTER_COLOR[ENT.CYCLOPS] },
    { glyph: ENT.CYCLOPS_CHIEF, name: "Cyclops Chieftain", color: MONSTER_COLOR[ENT.CYCLOPS_CHIEF] },
    { glyph: ENT.SPIDER, name: "Spider", color: MONSTER_COLOR[ENT.SPIDER] },
    { glyph: ENT.SPIDER_QUEEN, name: "Spider Queen", color: MONSTER_COLOR[ENT.SPIDER_QUEEN] },
    { glyph: ENT.WYRM, name: "Wyrm Minion", color: MONSTER_COLOR[ENT.WYRM] },
    { glyph: ENT.WYRM_ELDER, name: "Elder Wyrm", color: MONSTER_COLOR[ENT.WYRM_ELDER] },
    { glyph: ENT.SKELETON, name: "Skeleton Pack", color: MONSTER_COLOR[ENT.SKELETON] },
    { glyph: ENT.HORROR, name: "Horror", color: MONSTER_COLOR[ENT.HORROR] }
  ];

  const LEGEND_NOTE = `
    Visible tiles are bright; remembered tiles are dim.<br/>
    Start in darkness (vision ${VISION_DARK}). Torches restore vision and then dim as moves are made (carry ${TORCH_CAP}).<br/>
    Locked doors (X) can be unlocked with keys (now stored in chests), or forced with HP cost.<br/>
    Potions share glyph (!) but have different colors/effects. Effects tick on movement steps.
  `;

  // ---------- UI ----------
  const $screen = document.getElementById('screen');
  const $hud = document.getElementById('hud');
  const $log = document.getElementById('log');
  const $restartBtn = document.getElementById('restartBtn');
  const $legend = document.getElementById('legend');
  const $legendNote = document.getElementById('legendNote');

  
  // ---------- GLYPH CANVAS RENDERER ----------
  // Goal: exact ASCII look, but drawn onto canvas so we can later add subtle sprite-like effects.
  let $screenCanvas = null;
  let gctx = null;
  // Proof/diagnostic: gentle animated "ghost" pass so it's obvious this is canvas-drawn (not text).
  let glyphAnimOn = false;
  let glyphAnimRaf = 0;

  // --- Tile Animations (single-cell, visual-only) ---
  const tileAnims = new Map(); // key "x,y" -> {type, t0, ms, data}

  function animKey(x,y){ return `${x},${y}`; }

  function startTileAnim(x, y, type, ms=260, data=null){
    tileAnims.set(animKey(x,y), { type, t0: performance.now(), ms, data });
    requestGlyphAnimFrame();
  }

  function getTileAnim(x,y){
    const a = tileAnims.get(animKey(x,y));
    if(!a) return null;
    const t = performance.now() - a.t0;
    if(t >= a.ms){ tileAnims.delete(animKey(x,y)); return null; }
    return { ...a, t };
  }

  // Keep repainting while tile animations exist (does NOT affect game loop)
  let __tileAnimRaf = 0;
  function requestGlyphAnimFrame(){
    if(__tileAnimRaf) return;
    __tileAnimRaf = requestAnimationFrame(() => {
      __tileAnimRaf = 0;
      try{ renderGlyphCanvas(); }catch(_){}
      if(tileAnims.size) requestGlyphAnimFrame();
    });
  }

  // Tile setter with optional animation hooks (door/secret door)
  function setTileWithAnim(lvl, x, y, newT, reason=""){
    const oldT = lvl.tiles[x][y];
    if(oldT === newT) return;

    lvl.tiles[x][y] = newT;

    // Normal door: closed -> open
    if(oldT === TILE.DOOR_C && newT === TILE.DOOR_O){
      startTileAnim(x,y,"door_open",900,{start: oldT});
      return;
    }

    // Locked door forced/unlocked open
    if(oldT === TILE.LDOOR_C && (newT === TILE.LDOOR_O || newT === TILE.DOOR_O)){
      startTileAnim(x,y,"door_open",900,{start: oldT});
      return;
    }

    // Locked door unlocked (still closed)
    if(oldT === TILE.LDOOR_C && newT === TILE.DOOR_C){
      startTileAnim(x,y,"door_open",900,{start: oldT});
      return;
    }

    // Secret door reveal/open
    if(oldT === TILE.SD_C && newT === TILE.SD_O){
      startTileAnim(x,y,"secret_found",1200,{start: oldT});
      return;
    }
  }

  function initGlyphCanvas(){
    $screenCanvas = document.getElementById("screenCanvas");
    const $screen = document.getElementById("screen");
    if(!$screenCanvas || !$screen) return;
    gctx = $screenCanvas.getContext("2d");

    // Renderer mode (SAFE_MODE keeps DOM visible; otherwise canvas replaces DOM visually)
    applyRenderMode();
  }

  function resizeGlyphCanvas(){
    const $wrap = document.getElementById("screenWrap");
    if(!$screenCanvas || !gctx || !$wrap) return;
    const dpr = window.devicePixelRatio || 1;
    const w = Math.max(1, Math.floor($wrap.clientWidth));
    const h = Math.max(1, Math.floor($wrap.clientHeight));
    $screenCanvas.width = Math.floor(w * dpr);
    $screenCanvas.height = Math.floor(h * dpr);
    gctx.setTransform(dpr,0,0,dpr,0,0);
    renderGlyphCanvas(); // redraw after resize
  }

  
  // --- Color helpers for pulsing glyphs (potions/keys/scrolls) ---
  function __parseColorToRGB(c){
    if(!c) return {r:230,g:237,b:243};
    c = (""+c).trim();
    // rgb/rgba(...)
    let m = c.match(/^rgba?\(([^)]+)\)$/i);
    if(m){
      const parts = m[1].split(",").map(s=>parseFloat(s.trim()));
      return { r: parts[0]||0, g: parts[1]||0, b: parts[2]||0 };
    }
    // #rgb or #rrggbb
    if(c[0]==="#"){
      const hex = c.slice(1);
      if(hex.length===3){
        const r = parseInt(hex[0]+hex[0],16), g = parseInt(hex[1]+hex[1],16), b = parseInt(hex[2]+hex[2],16);
        return {r,g,b};
      }
      if(hex.length>=6){
        const r = parseInt(hex.slice(0,2),16), g = parseInt(hex.slice(2,4),16), b = parseInt(hex.slice(4,6),16);
        return {r,g,b};
      }
    }
    // fallback
    return {r:230,g:237,b:243};
  }

  function __mixToWhite(color, amt){
    // amt: 0..1 (0=no change, 1=white)
    amt = Math.max(0, Math.min(1, amt));
    const {r,g,b} = __parseColorToRGB(color);
    const rr = Math.round(r + (255 - r) * amt);
    const gg = Math.round(g + (255 - g) * amt);
    const bb = Math.round(b + (255 - b) * amt);
    return `rgb(${rr},${gg},${bb})`;
  }

  // --- Ambient FX repaint loop (so pulses are visible even when standing still) ---
  let __ambientRaf = 0;
  window.__ambientNeeded = false;
  function requestAmbientFrame(){
    if(__ambientRaf) return;
    __ambientRaf = requestAnimationFrame(() => {
      __ambientRaf = 0;
      if(window.__ambientNeeded){
        try{ renderGlyphCanvas(); }catch(_){}
      }
    });
  }

// ---- Corpse sprites (variants) ----
// IMPORTANT: This is intentionally isolated from the renderer logic.
// We only add additional Image() handles and pick between them at draw time.
const __corpseImg1 = new Image();
const __corpseImg2 = new Image();
const __corpseImg3 = new Image();
const __corpseImg4 = new Image();
const __corpseImg5 = new Image();

__corpseImg1.src = "/images/corpse_1_transparent.png";
__corpseImg2.src = "/images/corpse_2_transparent.png";
__corpseImg3.src = "/images/corpse_3_transparent.png";
__corpseImg4.src = "/images/corpse_4_transparent.png";
__corpseImg5.src = "/images/corpse_5_transparent.png";

const __corpseOnLoad = () => { try{ requestGlyphAnimFrame(); }catch(_e){} };
__corpseImg1.onload = __corpseOnLoad;
__corpseImg2.onload = __corpseOnLoad;
__corpseImg3.onload = __corpseOnLoad;
__corpseImg4.onload = __corpseOnLoad;
__corpseImg5.onload = __corpseOnLoad;

__corpseImg1.onerror = () => { try{ console.warn("Corpse PNG failed to load: corpse_1_transparent.png"); }catch(_e){} };
__corpseImg2.onerror = () => { try{ console.warn("Corpse PNG failed to load: corpse_2_transparent.png"); }catch(_e){} };
__corpseImg3.onerror = () => { try{ console.warn("Corpse PNG failed to load: corpse_3_transparent.png"); }catch(_e){} };
__corpseImg4.onerror = () => { try{ console.warn("Corpse PNG failed to load: corpse_4_transparent.png"); }catch(_e){} };
__corpseImg5.onerror = () => { try{ console.warn("Corpse PNG failed to load: corpse_5_transparent.png"); }catch(_e){} };

function renderGlyphCanvas(){
    if(!$screenCanvas || !gctx) return;
    try{ syncModes(); }catch(_){ }
    if(window.SAFE_MODE) return;

    const frame = window.__lastFrame;
    if(!frame || !frame.cells || !frame.cols || !frame.rows) return;

    const screen = document.getElementById("screen");
    const cs = getComputedStyle(screen);
    const fontSize = cs.fontSize;
    const fontFamily = cs.fontFamily;
    const lineHeight = parseFloat(cs.lineHeight) || parseFloat(fontSize);

    gctx.font = `${fontSize} ${fontFamily}`;
    gctx.textBaseline = "top";

    window.__ambientNeeded = false; // reset each render; set true when ambient tiles are in view

    const charW = gctx.measureText("M").width;
    const charH = lineHeight;

    const wrap = document.getElementById("screenWrap") || screen;
    const padL = parseFloat(cs.paddingLeft) || 0;
    const padT = parseFloat(cs.paddingTop) || 0;

    const w = wrap.clientWidth;
    const h = wrap.clientHeight;
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // DPR-aware canvas sizing for crisp glyphs
    $screenCanvas.style.width = w + "px";
    $screenCanvas.style.height = h + "px";
    const cw = Math.floor(w * dpr);
    const ch = Math.floor(h * dpr);
    if($screenCanvas.width !== cw) $screenCanvas.width = cw;
    if($screenCanvas.height !== ch) $screenCanvas.height = ch;

    // Draw in CSS pixels while backing store uses DPR
    gctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    gctx.clearRect(0, 0, w, h);

    const t = (performance.now() || Date.now()) / 1000;

    // Determine player position by scanning for the player glyph ('*')
    let px = -1, py = -1;
    for(let y=0; y<frame.rows; y++){
      for(let x=0; x<frame.cols; x++){
        const cell = frame.cells[y*frame.cols + x];
        if(cell && cell.ch === ENT.PLAYER){ px = x; py = y; break; }
      }
      if(px !== -1) break;
    }

    // Vision radius from game state if available, else approximate from visible area
    let vision = 2;
    try{
      if(window.game && window.game.torch){
        vision = window.game.torch && window.game.torch.lit ? window.game.torch.radius : (window.VISION_DARK || 2);
      } else if(window.VISION_DARK){
        vision = window.VISION_DARK;
      }
    }catch(e){}

    // Make the border/falloff VERY obvious (user requested)
    // Torch flicker (visual-only): modulates the lighting falloff without advancing game state.
    let flicker = 0.0;
    let torchLit = false;
    try{ torchLit = !!(window.game && window.game.torch && window.game.torch.lit); }catch(e){}
    if(torchLit){
      // Irregular, non-repeating-ish low-frequency blend (no RNG, stable & cheap)
      const a = Math.sin(t * 3.7);
      const b = Math.sin(t * 6.1 + 1.3);
      const c = Math.sin(t * 9.9 + 2.7);
      const n = (a*0.55 + b*0.30 + c*0.15); // -1..1-ish
      flicker = n * 0.95; // strength (more visible)
    }

    const baseInner = Math.max(1.5, vision - 1.2); // fully bright area
    const baseOuter = Math.max(baseInner + 1.8, vision + 1.8); // fade zone extends past vision edge

    // Apply flicker: slightly expand/contract the falloff band
    const INNER = baseInner + flicker * 0.45;
    const OUTER = baseOuter + flicker * 1.10;
    const DIM_ALPHA = 0.18;   // how dim at the edge
    const MIN_VISIBLE_ALPHA = 0.08;

    // If we couldn't locate the player glyph, disable falloff (avoid weirdness)
    const useFalloff = (px !== -1);


    for(let y=0; y<frame.rows; y++){
      for(let x=0; x<frame.cols; x++){
        gctx.save();
        try{
        const cell = frame.cells[y*frame.cols + x] || { ch:" ", color: cs.color, dim:true };
        let ch = cell.ch || " ";
        let glyphColor = cell.color || cs.color || "#e6edf3";

        // --- CORPSE RENDER OVERRIDE (safe, no full screen rebuild) ---
        // If the *live* level tile is a corpse, allow the glyph layer to render the corpse sprite
        // immediately after death dissolve, even if the cached frame still shows floor.
        let __corpseMeta = null;
        try{
          const __lvlC = (window.game && typeof getLevel === 'function') ? getLevel(game.depth) : null;
          if(__lvlC && cell && cell.x!=null && cell.y!=null && __lvlC.tiles && __wx!=null && __wy!=null && __lvlC.tiles[__wx]){
            if(__lvlC.tiles[__wx][__wy] === TILE.CORPSE && __lvlC.corpses){
              const __ck = keyXY(__wx, __wy);
              __corpseMeta = __lvlC.corpses.get(__ck) || null;
              if(__corpseMeta && (ch === TILE.FLOOR || ch === TILE.CORR || ch === TILE.CORPSE)){
                // Treat as corpse for rendering so '.' / ',' doesn't draw over the sprite.
                ch = TILE.CORPSE;
                glyphColor = __corpseMeta.color || glyphColor;
              }
            }
          }
        }catch(_){ __corpseMeta = null; }

        let __skipCell = false;

        // snap to integer pixel boundaries for crisp text
        const drawX = Math.round(padL + x * charW);
        const drawY = Math.round(padT + y * charH);

        // Base alpha from visibility/dim state
        let a = cell.dim ? 0.32 : 1.0;

        // Distance-based falloff to soften fog-of-war edge
        if(useFalloff){
          const dx = x - px;
          const dy = y - py;
          const d = Math.sqrt(dx*dx + dy*dy);

          if(d <= INNER){
            // keep a
          } else if(d >= OUTER){
            a = Math.min(a, MIN_VISIBLE_ALPHA);
          } else {
            const u = (d - INNER) / (OUTER - INNER); // 0..1
            const fade = (1 - u);                    // 1..0
            const target = DIM_ALPHA + fade*(1 - DIM_ALPHA); // DIM_ALPHA..1
            a = Math.min(a, target);
          }
        }

        // --- per-tile anim override (single cell, visual-only) ---
        const __anim = (cell && cell.x!=null && cell.y!=null) ? getTileAnim(cell.x, cell.y) : null;
        let __ox = 0, __oy = 0;
        let __alphaMul = 1.0;
        if(__anim){
          const uAnim = __anim.t / __anim.ms; // 0..1

          // obvious: pulsing highlight box under the glyph
          const pulse = 0.25 + 0.75*Math.sin(uAnim * Math.PI); // 0..1..0
          gctx.save();
          
          if(__anim.type === "monster_death"){
            // Monster death: dissolve top->bottom into a pool using the monster's own color.
            const data = __anim.data || {};
            const g = data.glyph || ch;
            const c = data.color || glyphColor;

            const u = Math.min(1, Math.max(0, uAnim));
            const poolH = Math.max(2, Math.round(charH * 0.18 * u));
            const clipY = Math.round(drawY + charH * u);
            const clipH = Math.max(0, Math.round(charH * (1 - u)));

            gctx.save();
            // draw remaining glyph portion (bottom part) as it dissolves
            if(clipH > 0){
              gctx.globalAlpha = a;
              gctx.fillStyle = c;
              gctx.beginPath();
              gctx.rect(drawX, clipY, charW, clipH);
              gctx.clip();
              gctx.fillText(g, drawX, drawY);
            }

            // draw the pooling color at the bottom
            gctx.globalAlpha = a * (0.65 + 0.35*u);
            gctx.fillStyle = c;
            gctx.fillRect(drawX + Math.round(charW*0.12), drawY + charH - poolH, Math.round(charW*0.76), poolH);

            gctx.restore();

            __skipCell = true;
          } else if(__anim.type === "door_open"){
            // Normal door: warm hinge-swing glow (NOT a smash)
            gctx.globalAlpha = a * 0.55 * pulse;
            gctx.fillStyle = "rgba(255,200,80,1)";
            const w = Math.max(2, Math.floor(charW * 0.35));
            gctx.fillRect(drawX + (charW - w), drawY, w, lineHeight);
          } else if(__anim.type === "secret_found"){
            // Secret reveal: cyan outline + scanline (NOT a smash)
            gctx.globalAlpha = a * (0.25 + 0.55*pulse);
            gctx.strokeStyle = "rgba(80,220,255,1)";
            gctx.lineWidth = 2;
            gctx.strokeRect(drawX+1, drawY+1, charW-2, lineHeight-2);

            // moving scanline
            const yy = drawY + Math.floor(lineHeight * uAnim);
            gctx.globalAlpha = a * 0.55 * pulse;
            gctx.fillStyle = "rgba(120,240,255,1)";
            gctx.fillRect(drawX+2, yy, charW-4, 2);
          } else if(__anim.type === "locked_bump"){
            gctx.globalAlpha = a * 0.75 * pulse;
            gctx.fillStyle = "rgba(255,80,80,1)";
            gctx.fillRect(drawX, drawY, charW, lineHeight);
          } else if(__anim.type === "spark"){
            gctx.globalAlpha = a * 0.55 * pulse;
            gctx.fillStyle = "rgba(255,255,255,1)";
            gctx.fillRect(drawX, drawY, charW, lineHeight);
          }
          gctx.restore();

          // swap the glyph during the animation (super obvious)
          if(__anim.type === "door_open"){
            // Hinge swing: closed stays for a beat, then cleanly becomes open "/"
            const startCh = (__anim.data && __anim.data.start) ? __anim.data.start : "#";
            if(uAnim < 0.45){
              ch = startCh;
              __ox = 0;
            }else{
              ch = "/";
              // tiny "swing" offset as it opens (contained to this tile)
              const swing = Math.sin((uAnim-0.45)/0.55 * Math.PI);
              __ox = Math.round(swing * 2);
            }
          } else if(__anim.type === "secret_found"){
            // Reveal: hold S, then fade into s (no flashing back and forth)
            if(uAnim < 0.60){
              ch = "S";
              __alphaMul = 0.90;
            }else{
              ch = "s";
              __alphaMul = 0.25 + 0.75 * ((uAnim-0.60)/0.40);
            }
          } else if(__anim.type === "locked_bump"){
            // obvious: jitter + flash between X and ‚úñ
            const jit = Math.round(Math.sin(uAnim * Math.PI * 10) * 2);
            __ox = jit;
            __oy = 0;
            ch = (Math.sin(uAnim * Math.PI * 6) > 0) ? "X" : "‚úñ";
          }
}

        

        

        // --- Trap visibility (proximity-based; hidden until close; NO reveal FX) ---

        // buildScreenFrame marks hidden traps with cell.trapHidden while leaving DOM glyph as floor.
        // We render the trap '^' in faint-to-bright red based on proximity.
        // Hard-but-fair: visible at distance 5 faintly, clearer as you close.

        let __cellDone = false;
        if(__skipCell) __cellDone = true;

        if(!__cellDone && cell && cell.trapHidden){
          try{
            const lvl = getLevel(game.depth);
            const px = lvl.player.x, py = lvl.player.y;
            if(cell.x!=null && cell.y!=null){
              const d = Math.max(Math.abs(cell.x - px), Math.abs(cell.y - py));

              // Do not draw when standing on it (player glyph covers); fairness comes from seeing it BEFORE.
              if(d > 0 && d <= 5){
                // Discrete bands for clarity (boosted visibility): 5 faint, 4 medium, 3 bright, <=2 very bright
                let e;
                if(d <= 2) e = 1.00;
                else if(d === 3) e = 0.80;
                else if(d === 4) e = 0.60;
                else e = 0.42; // d === 5

                // Boost overall brightness/alpha ~50% vs prior subtle fades
                const alpha = Math.min(1, (0.55 + 0.45 * e) * 0.60); // visibility -40%
                const r = Math.round(150 + 85 * e);
                const g = Math.round(25 + 35 * e);
                const b = Math.round(25 + 35 * e);

                gctx.save();
                gctx.globalAlpha = a * alpha;
                gctx.fillStyle = `rgb(${r},${g},${b})`;
                gctx.fillText(ENT.TRAP, drawX, drawY);
                gctx.restore();
                __cellDone = true;
                // do not draw base glyph this cell
              }
            }
          }catch(_){ }
        }

        if(!__cellDone && ch !== " " ){
          gctx.globalAlpha = a * __alphaMul;

          let __customDrawn = false;

          // If a corpse exists on this world cell but an actor/item is drawn here,
          // draw the corpse sprite *under* the primary glyph (side-view remains).
          if(__corpseMeta && ch !== TILE.CORPSE){
            try{
              const v = __corpseMeta.v ? __corpseMeta.v : 1;
              const color = __corpseMeta.color ? __corpseMeta.color : glyphColor;
              const imgs = getCorpseImgs();
              const base = imgs && imgs[v-1];
              if(base && base.complete){
                const pad = Math.max(0, Math.round(Math.min(charW, lineHeight) * 0.02));
                const spr = tintCorpseSprite(base, color, 0.85) || base;
                gctx.save();
                gctx.beginPath();
                gctx.rect(drawX, drawY, charW, lineHeight);
                gctx.clip();
                gctx.globalAlpha = a * __alphaMul;
                gctx.imageSmoothingEnabled = false;
                gctx.drawImage(spr, drawX + pad, drawY + pad, charW - pad*2, lineHeight - pad*2);
                gctx.restore();
              }
            }catch(_){ }
          }

          // Replace '$' with a chest graphic (single tile, clipped)
          if(ch === ENT.CHEST){
            const __img = getChestImg();
            if(__img && __img.complete){
              const pad = Math.max(1, Math.round(Math.min(charW, lineHeight) * 0.10));
              gctx.save();
              gctx.beginPath();
              gctx.rect(drawX, drawY, charW, lineHeight);
              gctx.clip();
              // subtle warm backdrop inside tile (not a big highlight box)
              gctx.globalAlpha = (a * __alphaMul) * 0.22;
              gctx.fillStyle = "rgba(255,200,80,1)";
              gctx.fillRect(drawX+1, drawY+1, charW-2, lineHeight-2);
              // draw the chest icon
              gctx.globalAlpha = a * __alphaMul;
              gctx.imageSmoothingEnabled = true;
              gctx.drawImage(__img, drawX + pad, drawY + pad, charW - pad*2, lineHeight - pad*2);
              gctx.restore();
              __customDrawn = true;
            }
          }

          // Corpse remains: draw a small transparent PNG and tint it toward the monster's color
          if(!__customDrawn && ch === TILE.CORPSE){
            try{
              const lvl = getLevel(game.depth);
              const key =
                (cell && cell.mx!=null && cell.my!=null) ? keyXY(cell.mx, cell.my) :
                ((cell && cell.x!=null && cell.y!=null) ? keyXY(cell.x, cell.y) : null);
              const meta = (lvl && lvl.corpses && key) ? lvl.corpses.get(key) : null;
              const v = meta && meta.v ? meta.v : 1;
              const color = meta && meta.color ? meta.color : glyphColor;
              const imgs = getCorpseImgs();
              const base = imgs && imgs[v-1];
              if(base && base.complete){
                const pad = Math.max(0, Math.round(Math.min(charW, lineHeight) * 0.02));
                const spr = tintCorpseSprite(base, color, 0.85) || base;
                gctx.save();
                gctx.beginPath();
                gctx.rect(drawX, drawY, charW, lineHeight);
                gctx.clip();
                gctx.globalAlpha = a * __alphaMul;
                gctx.imageSmoothingEnabled = false;
                gctx.drawImage(spr, drawX + pad, drawY + pad, charW - pad*2, lineHeight - pad*2);
                gctx.restore();
                __customDrawn = true;
              }
            }catch(_){ }
          }

          if(!__customDrawn){

          // DEBUG proof artifacts: ghost + notch (very visible)
          if(window.DEBUG){
            const wob = 1.5 + Math.sin(t*6 + x*0.3 + y*0.2)*0.8;
            gctx.fillStyle = "rgba(0,255,255,0.65)";
            gctx.fillText(ch, drawX + wob + __ox, drawY - wob + __oy);
            gctx.fillStyle = "rgba(255,0,255,0.70)";
            gctx.fillRect(drawX + charW - 3, drawY + 1, 2, 2);
          }

          // Potion / Key / Scroll: obvious color pulse by type (single tile, no movement)
          // (Scroll reserved for future: '?' or '¬ß' if you add them later)
          const isPotionGlyph = (ch === ENT.POTION);
          const isKeyGlyph = (ch === "k");
          const isScrollGlyph = (ch === "‚òº" || ch === "‚ñ≤" || ch === "Œ®" || ch === "¬§");
          if(isPotionGlyph || isKeyGlyph || isScrollGlyph){
            window.__ambientNeeded = true;

            // slow, deliberate pulse (~1.2s cycle), phase-offset by tile so fields don't sync perfectly
            const phase = (t * (Math.PI * 2) / 1.2) + x*0.18 + y*0.11;
            const pulse = 0.5 + 0.5*Math.sin(phase); // 0..1

            // very obvious brightening towards white
            const amt = isKeyGlyph ? (0.25 + 0.70*pulse) : (0.18 + 0.68*pulse);

            glyphColor = __mixToWhite(glyphColor, amt);

            // slight thickness / emphasis: draw a second "ghost" pass during peaks (still same tile)
            if(pulse > 0.78){
              gctx.save();
              gctx.globalAlpha = a * 0.55;
              gctx.fillStyle = __mixToWhite(glyphColor, 0.45);
              gctx.fillText(ch, drawX + __ox + 0.6, drawY + __oy + 0.6);
              gctx.restore();
            }
          }


// Stairs (>) directional pulse (single-tile, slow & obvious)
if(ch === TILE.DOWN){
  const phase = (performance.now()*0.001);
  const pulse = 0.5 + 0.5*Math.sin((phase*2*Math.PI)/1.4); // ~1.4s cycle
  // directional wedge glow on the right side (clipped to tile)
  gctx.save();
  gctx.beginPath();
  gctx.rect(drawX, drawY, charW, lineHeight);
  gctx.clip();
  gctx.globalAlpha = (a * __alphaMul) * (0.12 + 0.28*pulse);
  gctx.fillStyle = "rgba(120,190,255,1)";
  gctx.fillRect(drawX + charW*0.55, drawY+1, charW*0.45-1, lineHeight-2);
  gctx.restore();

  // brighten the glyph itself
  const bright = __mixToWhite(glyphColor, 0.35 + 0.55*pulse);
  gctx.fillStyle = bright;
  gctx.fillText(ch, drawX + __ox, drawY + __oy);
  continue;
}

          // main glyph

// CORPSE_CANVAS_REPLACE: replace '_' with corpse sprite in the canvas layer.
if(ch === TILE.CORPSE){
  // Pick variant (1..5). If metadata missing, default to 1.
  let __v = 1;
  let __hex = null;
  try{
    if(__corpseMeta){
      __v = (__corpseMeta.v|0) || 1;
      __hex = __corpseMeta.color || null;
    }
  }catch(_){ __v = 1; __hex = null; }
  if(__v < 1) __v = 1;
  if(__v > 5) __v = 5;

  const __corpseImg = (__v === 1) ? __corpseImg1 :
                     (__v === 2) ? __corpseImg2 :
                     (__v === 3) ? __corpseImg3 :
                     (__v === 4) ? __corpseImg4 :
                                 __corpseImg5;

  if(__corpseImg && __corpseImg.complete && __corpseImg.naturalWidth > 0){
    const pad = Math.max(0, Math.round(Math.min(charW, lineHeight) * 0.02));
    let spr = __corpseImg;
    if(__hex) spr = tintCorpseSprite(__corpseImg, __hex, 0.85) || __corpseImg;

    gctx.save();
    gctx.beginPath();
    gctx.rect(drawX, drawY, charW, lineHeight);
    gctx.clip();
    gctx.globalAlpha = Math.max(a * __alphaMul, 0.20);
    gctx.imageSmoothingEnabled = false;
    gctx.drawImage(spr, drawX + pad, drawY + pad, charW - pad*2, lineHeight - pad*2);
    gctx.restore();
  }
  continue;
}

          gctx.fillStyle = glyphColor;
          // Special-case: shrink skull glyph to fit grid nicely
          if(ch === '‚ò†'){
            const fs = parseFloat(fontSize) || 16;
            const small = Math.max(10, fs * 0.78);
            gctx.save();
            gctx.font = `${small}px ${fontFamily}`;
            const mw = gctx.measureText(ch).width;
            const ox = (charW - mw) * 0.5;
            const oy = (charH - small) * 0.5;
            gctx.fillText(ch, drawX + __ox + ox, drawY + __oy + oy);
            gctx.restore();
          } else {
            gctx.fillText(ch, drawX + __ox, drawY + __oy);
          }
// Torch item sparkle (single-tile, contained): keep 't' static, add a pixel-spark at the tip (font-safe)
if(ch === ENT.TORCH){
  window.__ambientNeeded = true;

  // Slow looping sparkle: bright peak + dim tail (obvious but not noisy)
  const phase = (t * (Math.PI * 2) / 1.35) + x*0.21 + y*0.17; // ~1.35s cycle, de-synced per tile
  const pulse = 0.5 + 0.5*Math.sin(phase); // 0..1

  // Clip to THIS tile so nothing bleeds into neighbors
  gctx.save();
  gctx.beginPath();
  gctx.rect(drawX + __ox, drawY + __oy, charW, charH);
  gctx.clip();

  // Position near the "tip" of the 't' (upper middle of the cell)
  const sx = drawX + __ox + charW*0.58;
  const sy = drawY + __oy + charH*0.18;

  // Intensity ramps up near the peak
  const alpha = (a * __alphaMul) * (0.05 + 0.70*Math.pow(pulse, 2.8));

  // Use "lighter" so it reads as a bright glint without adding blocks
  gctx.globalCompositeOperation = "lighter";
  gctx.globalAlpha = alpha;
  gctx.fillStyle = "rgba(255,245,210,1)";

  // Tiny 5-pixel sparkle cross (font-safe)
  const px1 = Math.max(1, Math.round(Math.min(charW, charH) * 0.06));
  const cx = Math.round(sx);
  const cy = Math.round(sy);
  gctx.fillRect(cx, cy, px1, px1); // center
  gctx.fillRect(cx - px1*2, cy, px1, px1); // left
  gctx.fillRect(cx + px1*2, cy, px1, px1); // right
  gctx.fillRect(cx, cy - px1*2, px1, px1); // up
  gctx.fillRect(cx, cy + px1*2, px1, px1); // down

  // Extra diagonal twinkle only at the peak (more "spark")
  if(pulse > 0.78){
    gctx.globalAlpha = alpha * 0.85;
    gctx.fillRect(cx - px1*2, cy - px1*2, px1, px1);
    gctx.fillRect(cx + px1*2, cy - px1*2, px1, px1);
    gctx.fillRect(cx - px1*2, cy + px1*2, px1, px1);
    gctx.fillRect(cx + px1*2, cy + px1*2, px1, px1);
  }

  gctx.restore();
  gctx.globalCompositeOperation = "source-over";
  gctx.globalAlpha = 1.0;
}

// Weapon item shimmer (single-tile, contained): *slow* metallic sweep + obvious glyph shine
          if(ch === ENT.WEAPON){
            // Much slower + more obvious than before
            const phase = t*0.55 + x*0.12 - y*0.10;
            const sweep = 0.5 + 0.5*Math.sin(phase);            // 0..1
            const sx = drawX + __ox + (sweep*1.25 - 0.12)*charW; // band travels across cell

            gctx.save();
            gctx.beginPath();
            gctx.rect(drawX + __ox, drawY + __oy, charW, charH);
            gctx.clip();

            gctx.globalCompositeOperation = "lighter";

            // Moving sheen band (brighter + wider so it's detectable)
            const g = gctx.createLinearGradient(sx - charW*0.40, 0, sx + charW*0.40, 0);
            g.addColorStop(0.00, "rgba(255,255,255,0)");
            g.addColorStop(0.40, `rgba(210,230,255,${0.14 + 0.26*sweep})`);
            g.addColorStop(0.50, `rgba(255,255,255,${0.22 + 0.40*sweep})`);
            g.addColorStop(0.60, `rgba(210,230,255,${0.14 + 0.26*sweep})`);
            g.addColorStop(1.00, "rgba(255,255,255,0)");

            gctx.globalAlpha = a;
            gctx.fillStyle = g;
            gctx.fillRect(drawX + __ox, drawY + __oy, charW, charH);

            // Make the weapon GLYPH itself catch the light (more obvious)
            gctx.globalAlpha = a * (0.35 + 0.55*sweep);
            gctx.fillStyle = "rgba(245,250,255,1)";
            gctx.fillText(ch, drawX + __ox, drawY + __oy);

            // Sparkle when the sheen is near peak (still inside tile)
            if(sweep > 0.86){
              gctx.globalAlpha = a * 0.85;
              gctx.fillStyle = "rgba(255,255,255,1)";
              gctx.fillText("‚ú¶", drawX + __ox + charW*0.66, drawY + __oy + charH*0.40);
            }

            gctx.restore();
          }

          // sparkle overlay
          if(__anim && __anim.type === "spark"){
            const u2 = __anim.t / __anim.ms;
            const pulse = 0.25 + 0.75 * Math.sin(u2 * Math.PI); // 0..1..0
            gctx.save();
            gctx.globalAlpha = a * 0.8 * pulse;
            gctx.fillStyle = "rgba(255,255,255,1)";
            gctx.fillText("‚ú∂", drawX + __ox, drawY + __oy);
gctx.restore();
          }

          }

          gctx.globalAlpha = 1.0;
        }
        } finally { gctx.restore(); }
      }
    }
    // Torch glow (visual-only): subtle warm pulse layered over the lit area (no blur on glyphs)
    if(torchLit){
      const cx = Math.round(padL + px * charW + charW * 0.5);
      const cy = Math.round(padT + py * charH - charH * 0.4);
      const glow = Math.max(0, 0.08 + (flicker * 0.04)); // 0.04..0.12-ish
      const r0 = Math.max(6, (vision - 0.5) * Math.min(charW, charH));
      const r1 = Math.max(r0 + 40, (vision + 2.5) * Math.min(charW, charH));
      gctx.save();
      gctx.globalCompositeOperation = "screen";
      const gr = gctx.createRadialGradient(cx, cy, r0 * 0.15, cx, cy, r1);
      gr.addColorStop(0.0, `rgba(255,190,110,${glow})`);
      gr.addColorStop(0.35, `rgba(255,160,80,${glow*0.55})`);
      gr.addColorStop(1.0, "rgba(0,0,0,0)");
      gctx.fillStyle = gr;
      gctx.fillRect(0, 0, w, h);
      gctx.restore();
    }

    // Always show a small on-canvas DEBUG tag so you know artifacts should appear
    if(window.DEBUG){
      gctx.save();
      gctx.globalAlpha = 0.9;
      gctx.fillStyle = "rgba(255,80,80,0.85)";
      gctx.font = `bold ${Math.max(12, Math.floor(parseFloat(fontSize)*0.9))}px ${fontFamily}`;
      gctx.fillText("DEBUG", padL + 6, padT + 6);
      gctx.restore();
    }

    gctx.globalAlpha = 1.0;
  }


// ---------- ASSET PATHS (single source of truth) ----------
// NOTE: Keep this block ABOVE the audio/SFX systems so it is defined before first use.
const ASSET = {
  img:   "/images/",
  music: "/music/",
  sfx:   "/sounds/"
};

function __isSpecialUrl(s){
  return /^(data:|blob:|https?:)/i.test(String(s || ""));
}

// If src is already a path (contains '/'), or a special URL, leave it alone.
// Otherwise prefix with the folder for that asset kind.
function resolveAsset(kind, src){
  if(!src) return src;
  if(__isSpecialUrl(src)) return src;
  if(String(src).includes("/")) return src;
  return (ASSET[kind] || "") + src;
}

// Try URLs in order; return the first successful response (resp.ok).
async function fetchWithFallback(urls, fetchOpts){
  let lastErr = null;
  for(const u of urls){
    try{
      const resp = await fetch(u, fetchOpts);
      if(resp && resp.ok) return resp;
      lastErr = new Error(`HTTP ${resp ? resp.status : "?"} for ${u}`);
    }catch(e){
      lastErr = e;
    }
  }
  throw lastErr || new Error("fetchWithFallback failed");
}

// ---------- AUDIO + MUSIC ENGINE ----------
  // Single-channel BGM player that can switch between base theme and situational clips.
  const $bgm = document.getElementById('bgm');
  const $muteBtn = document.getElementById('muteBtn');
  const $skipBtn = document.getElementById('skipBtn');
  const __ddMutedSaved = localStorage.getItem("dd_muted");
  let uiMuted = (__ddMutedSaved === null ? true : (__ddMutedSaved === "1")); // default muted
  let pendingPlay = false;

  // Music catalog (scale-friendly: add more pools/triggers as you create clips)
  const INTRO_LOCK_MS = 15000; // minimum time before triggers (45s)
  const SKIP_PLAYLIST = [
    "dungeons deep.mp3",
    "music_active.mp3",
    "music_active2.mp3",
    "music_medium2.mp3",
    "music_medium3.mp3",
    "music_slow1.mp3",
    "music_slow2.mp3",
    "music_slow3.mp3",
    "music_adventuring.mp3",
    "music_adventuring2.mp3",
    "music_adventuring3.mp3",
    "music_adventuring4.mp3",
    "music_adventuring5.mp3",
    "music2_transitions_descending.mp3",
    "music2_transitions2.mp3",
    "music2_transitions3.mp3",
    "dungeons-evenstar.mp3",
    "Dungeons-forest.mp3",
    "dungeons-forest3.mp3",
    "Dungeons-overworld-epic.mp3",
    "music_adventuring_elven.mp3",
    "music_elvish_travelling_tune.mp3",
    "music_elvish_travelling_tune_epic.mp3",
    "music_prologue_foreset1.mp3",
    "music_prologue_foreset2.mp3",
    "music_prologue_ocean1.mp3",
    "music4_encounter_chant.mp3",
    "music4_encounter_chant2.mp3",
    "music4_encounter_religious.mp3",
    "music4_encounter_religious2.mp3",
    "music4_encounter_religious3.mp3",
    "music4_encounter_religious4.mp3",
    "music4_room_discovery.mp3",
    "music4_room_discovery2.mp3",
    "music5_treasure_discovery.mp3",
    "music6_low_hp_danger.mp3",
    "music_adventuring10.mp3",
    "music_adventuring11.mp3",
    "music_adventuring6.mp3",
    "music_adventuring7.mp3",
    "music_adventuring8.mp3",
    "music_adventuring9.mp3",
    "music_adventuring_dwarven_chant1.mp3",
    "music_adventuring_dwarven_chant2.mp3",
    "music_adventuring_dwarven_chant3.mp3",
    "music_adventuring_dwarven_chant4.mp3",
    "music_adventuring_dwarven_chant4dark.mp3",
    "music_adventuring_dwarven_chant4dark0.mp3",
    "music_adventuring_dwarven_chant4dark2.mp3",
    "music_adventuring_dwarven_chant4dark3.mp3",
    "music_adventuring_dwarven_chant4darkelf1.mp3",
    "music_adventuring_dwarven_chant4darkelf2.mp3",
    "music_adventuring_elven_lament1.mp3",
    "music_adventuring_elven_lament2.mp3",
    "music_adventuring_elven_lament_epic.mp3",
    "music_end_theme1.mp3",
    "music_end_theme_epic(intro-only).mp3",
    "music_end_theme_epic.mp3",
    "Music-dungeons-doom-fight.mp3",
    "music3_first_monster_encounter.mp3",
    "music3_first_monster_encounter2.mp3",
    "music3_monster_encounter.mp3",
    "music3_monster_encounter2.mp3",
    "music3_monster_encounter_boss.mp3",
    "music3_monster_encounter_boss2.mp3",
    "music3_monster_encounter_boss3.mp3",
    "music2_transitions4.mp3",
    "music_transitions4.mp3",
    "music_transitions5.mp3",
    "music_transitions6p.mp3",
    "music_enter_cave1.mp3",
    "music_enter_cave2.mp3",
    "music_cave1.mp3",
    "music_cave2.mp3",
    "music_dwarven_themes2.mp3",
    "music_dwarven_themes1.mp3",
    "music_elvish_lament_main_theme5_instrumental.mp3",
    "music_elvish_lament_main_theme4.mp3",
    "music_elvish_lament_main_theme2.mp3",
    "music_elvish_lament_main_theme1PRIME.mp3",

      "music_alter_encounter_horror.mp3",
    "music_alter_encounter_evil.mp3",
    "music_alter_encounter_hardship.mp3",
    "music_alter_encounter_woe.mp3",
];

  const Music = {
    base: { src: "dungeons deep.mp3", loop: true },

    // pools = collections of clips that a trigger may pick from
    pools: {
      active: [
        { src: "music_active.mp3", weight: 1 },
        { src: "music_active2.mp3", weight: 1 },
        { src: "Music-dungeons-doom-fight.mp3", weight: 1 },
        { src: "music3_first_monster_encounter.mp3", weight: 1 },
        { src: "music3_first_monster_encounter2.mp3", weight: 1 },
        { src: "music3_monster_encounter.mp3", weight: 1 },
        { src: "music3_monster_encounter2.mp3", weight: 1 },
        { src: "music3_monster_encounter_boss.mp3", weight: 1 },
        { src: "music3_monster_encounter_boss2.mp3", weight: 1 },
        { src: "music3_monster_encounter_boss3.mp3", weight: 1 },
      ],
      medium: [
        { src: "music_medium2.mp3", weight: 1 },
        { src: "music_medium3.mp3", weight: 1 },
        { src: "music_adventuring.mp3",  weight: 1 },
        { src: "music_adventuring2.mp3", weight: 1 },
        { src: "music_adventuring3.mp3", weight: 1 },
        { src: "music_adventuring4.mp3", weight: 1 },
        { src: "music_adventuring5.mp3", weight: 1 },
        { src: "music4_encounter_chant.mp3", weight: 1 },
        { src: "music4_encounter_chant2.mp3", weight: 1 },
        { src: "music4_encounter_religious.mp3", weight: 1 },
        { src: "music4_encounter_religious2.mp3", weight: 1 },
        { src: "music4_encounter_religious3.mp3", weight: 1 },
        { src: "music4_encounter_religious4.mp3", weight: 1 },
        { src: "music4_room_discovery.mp3", weight: 1 },
        { src: "music4_room_discovery2.mp3", weight: 1 },
        { src: "music5_treasure_discovery.mp3", weight: 1 },
        { src: "music6_low_hp_danger.mp3", weight: 1 },
        { src: "music_adventuring10.mp3", weight: 1 },
        { src: "music_adventuring11.mp3", weight: 1 },
        { src: "music_adventuring6.mp3", weight: 1 },
        { src: "music_adventuring7.mp3", weight: 1 },
        { src: "music_adventuring8.mp3", weight: 1 },
        { src: "music_adventuring9.mp3", weight: 1 },
        { src: "music_adventuring_dwarven_chant1.mp3", weight: 1 },
        { src: "music_adventuring_dwarven_chant2.mp3", weight: 1 },
        { src: "music_adventuring_dwarven_chant3.mp3", weight: 1 },
        { src: "music_adventuring_dwarven_chant4.mp3", weight: 1 },
        { src: "music_adventuring_dwarven_chant4dark.mp3", weight: 1 },
        { src: "music_adventuring_dwarven_chant4dark0.mp3", weight: 1 },
        { src: "music_adventuring_dwarven_chant4dark2.mp3", weight: 1 },
        { src: "music_adventuring_dwarven_chant4dark3.mp3", weight: 1 },
        { src: "music_adventuring_dwarven_chant4darkelf1.mp3", weight: 1 },
        { src: "music_adventuring_dwarven_chant4darkelf2.mp3", weight: 1 },
      ],
      slow: [
        { src: "music_slow1.mp3", weight: 1 },
        { src: "music_slow2.mp3", weight: 1 },
        { src: "music_slow3.mp3", weight: 1 },
        { src: "music_adventuring_elven_lament1.mp3", weight: 1 },
        { src: "music_adventuring_elven_lament2.mp3", weight: 1 },
        { src: "music_adventuring_elven_lament_epic.mp3", weight: 1 },
        { src: "music_end_theme1.mp3", weight: 1 },
        { src: "music_end_theme_epic(intro-only).mp3", weight: 1 },
        { src: "music_end_theme_epic.mp3", weight: 1 },
      ],

      // Mixed roaming pool: mostly slow, occasionally medium
      roam: [
        { src: "music_slow1.mp3",        weight: 3 },
        { src: "music_slow2.mp3",        weight: 3 },
        { src: "music_slow3.mp3",        weight: 3 },
        { src: "music_medium2.mp3",      weight: 1 },
        { src: "music_medium3.mp3",      weight: 1 },
        { src: "music_adventuring.mp3",  weight: 2 },
        { src: "music_adventuring2.mp3", weight: 2 },
        { src: "music_adventuring3.mp3", weight: 2 },
        { src: "music_adventuring4.mp3", weight: 2 },
        { src: "music_adventuring5.mp3", weight: 2 },
        { src: "dungeons-evenstar.mp3", weight: 3 },
        { src: "Dungeons-forest.mp3", weight: 1 },
        { src: "dungeons-forest3.mp3", weight: 1 },
        { src: "Dungeons-overworld-epic.mp3", weight: 1 },
        { src: "music_adventuring_elven.mp3", weight: 2 },
        { src: "music_elvish_travelling_tune.mp3", weight: 2 },
        { src: "music_elvish_travelling_tune_epic.mp3", weight: 2 },
        { src: "music_prologue_foreset1.mp3", weight: 2 },
        { src: "music_prologue_foreset2.mp3", weight: 2 },
        { src: "music_prologue_ocean1.mp3", weight: 2 },
        { src: "music_dwarvish_crumbling_stair.mp3", weight: 2 },
        { src: "music_the_mourning_childrens_choir.mp3", weight: 2 },
        // --- Soundtrack (/music/soundtrack) ---
        { src: "/music/soundtrack/02 Adventuring.mp3", weight: 0.25 },
        { src: "/music/soundtrack/03 Miserere.mp3", weight: 0.5 },
        { src: "/music/soundtrack/04 The Mourning of Eve.mp3", weight: 0.5 },
        { src: "/music/soundtrack/05 Don't Sleep.mp3", weight: 1 },
        { src: "/music/soundtrack/06 Dungeon March.mp3", weight: 1 },
        { src: "/music/soundtrack/07 Ilqua Vanda.mp3", weight: 0.5 },
        { src: "/music/soundtrack/08 Liturgy of Valor.mp3", weight: 0.5 },
        { src: "/music/soundtrack/09 Alter.mp3", weight: 0.25 },
        { src: "/music/soundtrack/10 Return.mp3", weight: 0.5 },
        { src: "/music/soundtrack/11 Metal and Stone.mp3", weight: 1 },
        { src: "/music/soundtrack/12 Gorgy.mp3", weight: 0.5 },
        { src: "/music/soundtrack/13 The Mourning of Eve (Interlude).mp3", weight: 2 },
        { src: "/music/soundtrack/14 Mother's Lament.mp3", weight: 0.5 },
        { src: "/music/soundtrack/15 River to Light.mp3", weight: 0.5 },
        { src: "/music/soundtrack/16 The Intercessor.mp3", weight: 0.75 },
        { src: "/music/soundtrack/17 Unwelcome Party.mp3", weight: 0.25 },
        { src: "/music/soundtrack/18 River to Light (Interlude).mp3", weight: 1.5 },
        { src: "/music/soundtrack/19 Venite Exultemus.mp3", weight: 0.25 },
        { src: "/music/soundtrack/20 Antiphonary.mp3", weight: 0.5 },
        { src: "/music/soundtrack/21 River to Light (Instrumental).mp3", weight: 0.5 },
        { src: "/music/soundtrack/23 River to Light (Reprise).mp3", weight: 0.5 },
        { src: "/music/soundtrack/24 End Theme.mp3", weight: 0.25 },
      ],
      transitions: [
        { src: "music2_transitions_descending.mp3", weight: 1 },
        { src: "music2_transitions2.mp3", weight: 1 },
        { src: "music2_transitions3.mp3", weight: 1 },
        { src: "music2_transitions4.mp3", weight: 1 },
        { src: "music_transitions4.mp3", weight: 1 },
        { src: "music_transitions5.mp3", weight: 1 },
        { src: "music_transitions6p.mp3", weight: 1 },
      ],
      caveEnter: [
        { src: "music_enter_cave1.mp3", weight: 1 },
        { src: "music_enter_cave2.mp3", weight: 1 },
      ],
      caveLoop: [
        { src: "music_cave1.mp3", weight: 1 },
        { src: "music_cave2.mp3", weight: 1 },
      ],
      ritualChamber: [
        { src: "music_alter_encounter_horror.mp3",   weight: 1 },
        { src: "music_alter_encounter_evil.mp3",     weight: 1 },
        { src: "music_alter_encounter_hardship.mp3", weight: 1 },
        { src: "music_alter_encounter_woe.mp3",      weight: 1 },
      ]
    },

    // triggers = rule definitions (probability + cooldown + pool)
    triggers: {
      monsterEncounter: { prob: 0.50, cooldownMs: 8000, pool: "active" },
      roam:            { prob: 0.20, cooldownMs: 12000, pool: "roam" },
      descend:         { prob: 1.00, cooldownMs: 0,     pool: "transitions" }
    },

    state: {
      fadeRaf: 0,
      fading: false,

      mode: "base", // "base" | "clip"
      skipIndex: 0,
      introPlaying: true,
      introStart: 0,
      pending: [],
      pendingTimer: null,
      lastFire: { monsterEncounter: 0, roam: 0 },
      userActive: false,
      inRitual: false,
      savedRitualTrack: "",
      savedRitualTime: 0,
      savedRitualLoop: true,

      clipSource: 'auto'
    }
  };

  function musicAllTracks(){
    const seen = new Set();
    const out = [];

    // base first
    if(Music.base && Music.base.src){
      seen.add(Music.base.src);
      out.push(Music.base.src);
    }

    // pools in stable order
    const poolOrder = Object.keys(Music.pools || {});
    for(const poolName of poolOrder){
      const pool = Music.pools[poolName] || [];
      for(const it of pool){
        const src = it && it.src;
        if(src && !seen.has(src)){
          seen.add(src);
          out.push(src);
        }
      }
    }
    return out;
  }

  function musicSkipNext(){
    if(!$bgm) return;

    // Skipping is a user action: clear intro locks so cycling is responsive.
    Music.state.introPlaying = false;
    Music.state.introStart = 0;

    const list = SKIP_PLAYLIST || [];
    if(list.length === 0) return;

    const cur = ($bgm.getAttribute("src") || $bgm.currentSrc || "").split("/").pop();

    // Avoid repeating the current track and the last few skips if possible
    Music.state.recentSkips = Array.isArray(Music.state.recentSkips) ? Music.state.recentSkips : [];
    const recent = new Set(Music.state.recentSkips.slice(-3).filter(Boolean));
    if(cur) recent.add(cur);

    // Pick random with a few retries; fall back to any track
    let next = null;
    for(let i=0;i<8;i++){
      const cand = list[(Math.random()*list.length)|0];
      if(!recent.has(cand)){
        next = cand;
        break;
      }
    }
    if(!next){
      next = list[(Math.random()*list.length)|0];
    }

    // Update recent history
    Music.state.recentSkips.push(next);
    if(Music.state.recentSkips.length > 8) Music.state.recentSkips = Music.state.recentSkips.slice(-8);

    // Treat base theme as looping, all others as clips (non-loop)
    const isBase = (next === (Music.base && Music.base.src));
    Music.state.mode = isBase ? "base" : "clip";
    Music.state.clipSource = "manual";

    musicTransitionTo(next, isBase);
    try{ $bgm.currentTime = 0; }catch(e){}
    musicPlay();
  }

  function setMuted(v){
    uiMuted = !!v;
    localStorage.setItem("dd_muted", uiMuted ? "1" : "0");
    if($bgm) $bgm.muted = uiMuted;
    if($muteBtn){
      $muteBtn.classList.toggle("is-muted", uiMuted);
      $muteBtn.setAttribute("aria-pressed", uiMuted ? "true" : "false");
      $muteBtn.textContent = uiMuted ? "üîá" : "üîä";
    }
    if(uiMuted && $bgm) $bgm.pause();
  }

  function weightedPick(arr){
    const total = arr.reduce((s,it)=>s+(it.weight||1),0);
    let r = Math.random()*total;
    for(const it of arr){
      r -= (it.weight||1);
      if(r <= 0) return it;
    }
    return arr[arr.length-1];
  }

  function musicSetSrc(src, loop){
    if(!$bgm) return;
    
    src = resolveAsset("music", src);
if($bgm && !$bgm.paused){ try{$bgm.pause();}catch(e){} }
    if($bgm.getAttribute("src") !== src){
      $bgm.setAttribute("src", src);
      $bgm.load();
    }
    $bgm.loop = !!loop;
  }

  function musicSetSrcHard(src, loop){
    if(!$bgm) return;
    
    src = resolveAsset("music", src);
try{ $bgm.pause(); }catch(e){}
    // Use property assignment so currentSrc updates reliably
    $bgm.src = src;
    $bgm.loop = !!loop;
    try{ $bgm.load(); }catch(e){}
  }
  function musicPlay(){
    if(!$bgm || uiMuted) return;
    const p = $bgm.play();
    if(p && typeof p.catch === "function"){
      p.catch(() => { pendingPlay = true; });
    }
  }
  
  // Smooth fade between tracks so triggers don't feel abrupt.
  const MUSIC_FADE_OUT_MS = 650;
  const MUSIC_FADE_IN_MS  = 450;

  function musicStopFade(){
    if(Music.state.fadeRaf){
      try{ cancelAnimationFrame(Music.state.fadeRaf); }catch(e){}
      Music.state.fadeRaf = 0;
    }
    Music.state.fading = false;
  }

  function musicFadeTo(target, ms, onDone){
    if(!$bgm) { if(onDone) onDone(); return; }
    musicStopFade();
    const startVol = (typeof $bgm.volume === "number") ? $bgm.volume : 1;
    const endVol = Math.max(0, Math.min(1, target));
    const t0 = performance.now();
    Music.state.fading = true;

    const step = (t) => {
      const k = Math.max(0, Math.min(1, (t - t0) / Math.max(1, ms)));
      // ease-in-out
      const e = (k < 0.5) ? (2*k*k) : (1 - Math.pow(-2*k + 2, 2)/2);
      const v = startVol + (endVol - startVol) * e;
      try{ $bgm.volume = v; }catch(err){}
      if(k >= 1){
        Music.state.fadeRaf = 0;
        Music.state.fading = false;
        if(onDone) onDone();
        return;
      }
      Music.state.fadeRaf = requestAnimationFrame(step);
    };
    Music.state.fadeRaf = requestAnimationFrame(step);
  }

  function musicTransitionTo(src, loop){
    if(!$bgm) return;
    // If muted, just swap silently.
    if(uiMuted){
      musicSetSrcHard(src, loop);
      return;
    }

    // If nothing playing yet, start immediately (no fade-out needed)
    const isIdle = ($bgm.paused || !$bgm.getAttribute("src"));
    if(isIdle){
      try{ $bgm.volume = 1; }catch(e){}
      musicSetSrcHard(src, loop);
      try{ $bgm.currentTime = 0; }catch(e){}
      musicPlay();
      return;
    }

    // Fade out, swap, then fade in.
    musicFadeTo(0, MUSIC_FADE_OUT_MS, () => {
      try{ $bgm.pause(); }catch(e){}
      musicSetSrcHard(src, loop);
      try{ $bgm.currentTime = 0; }catch(e){}
      // Restore volume low before play to avoid click
      try{ $bgm.volume = 0; }catch(e){}
      musicPlay();
      musicFadeTo(1, MUSIC_FADE_IN_MS);
    });
  }
  
  function onEnterCaves() {
    if (Music.state.inCave) return; // Already in cave mode
    
    Music.state.inCave = true;

    // --- LORE: cave threshold recognition (single beat, no UI) ---
    if(!game.loreFired) initLore();
    const RECOG_THRESHOLD = 6;
    if((game.loreWeight|0) >= RECOG_THRESHOLD){
      fireLoreOnce('cave_enter_recog', 'Stone closes behind you‚Äîremembering the shape of your passing.');
    } else {
      fireLoreOnce('cave_enter_base', 'Stone closes behind you, as if it never opened.');
    }
    Music.state.savedTrack = $bgm.getAttribute("src") || "";
    Music.state.savedTime = $bgm.currentTime || 0;
    Music.state.savedLoop = $bgm.loop;

    // Play the cave entry sting
    const entryTrack = pickFromPool("caveEnter");
    if (entryTrack) {
      musicTransitionTo(entryTrack, false); // false = no loop on the sting
    }

    // After the entry sting ends, switch to the cave loop
    $bgm.onended = function() {
      if (Music.state.inCave) {
        const caveLoop = pickFromPool("caveLoop");
        if (caveLoop) {
          musicTransitionTo(caveLoop, true); // true = loop the cave track
        }
      }
    };
  }

  function onExitCaves() {
    if (!Music.state.inCave) return;

    Music.state.inCave = false;
    
    // Fade back to the saved track and position
    musicTransitionTo(Music.state.savedTrack, Music.state.savedLoop);
    $bgm.currentTime = Music.state.savedTime;
  }

  function onEnterRitualChamber(){
    // Don't fight with cave mode; caves get priority.
    if (Music.state.inCave) return;

    if (Music.state.inRitual) return;
    Music.state.inRitual = true;

    // Save current playing state so we can restore on exit.
    Music.state.savedRitualTrack = ($bgm.getAttribute("src") || "");
    Music.state.savedRitualTime  = ($bgm.currentTime || 0);
    Music.state.savedRitualLoop  = $bgm.loop;

    const t = pickFromPool("ritualChamber");
    if (t){
      // Loop as ambience until you leave.
      musicTransitionTo(t, true);
    }
  }

  function onExitRitualChamber(){
    if (!Music.state.inRitual) return;
    Music.state.inRitual = false;

    const src = Music.state.savedRitualTrack || Music.base.src;
    const loop = (typeof Music.state.savedRitualLoop === "boolean") ? Music.state.savedRitualLoop : true;

    musicTransitionTo(src, loop);
    try { $bgm.currentTime = (Music.state.savedRitualTime || 0); } catch(e) {}
  }


  function playTheme(){
    if(!$bgm || uiMuted) return;

    // Intro lock: let the theme play through once before any other music can trigger
    Music.state.mode = "base";
    Music.state.introPlaying = true;
    Music.state.introStart = Date.now();
    musicSetSrc(Music.base.src, false); // play once (no loop) for the intro
    try{ $bgm.currentTime = 0; }catch(e){}
    musicPlay();

    // fresh run
    Music.state.lastFire.monsterEncounter = 0;
    Music.state.lastFire.roam = 0;
    Music.state.skipIndex = -1;
  }

  function playClip(src){
    if(!$bgm) return;
    Music.state.mode = "clip";
    Music.state.clipSource = 'manual';
    Music.state.clipSource = 'auto';
    musicTransitionTo(src, false);
  }

  function resumeBase(){
    if(!$bgm) return;
    Music.state.mode = "base";
    Music.state.introPlaying = false;
    musicTransitionTo(Music.base.src, true);
  }


  // ----------------- CAVE MUSIC (enter sting + loop + restore) -----------------
  function musicSaveCurrent(){
    if(!$bgm) return;
    Music.state.saved = {
      src: $bgm.getAttribute("src") || (Music.base && Music.base.src) || "",
      time: (() => { try { return $bgm.currentTime || 0; } catch(e){ return 0; } })(),
      loop: !!$bgm.loop,
      mode: Music.state.mode || "base",
      introPlaying: !!Music.state.introPlaying,
      introStart: Music.state.introStart || 0
    };
  }

  function musicRestoreSaved(){
    if(!$bgm) return;
    const s = Music.state.saved;
    if(!s || !s.src){
      // fallback
      resumeBase();
      return;
    }

    // Restore whatever was playing, at the same time index
    Music.state.mode = s.mode || "base";
    Music.state.introPlaying = !!s.introPlaying;
    Music.state.introStart = s.introStart || 0;

    // Do a fade swap but then set currentTime to saved time
    musicFadeTo(0, MUSIC_FADE_OUT_MS, () => {
      try{ $bgm.pause(); }catch(e){}
      musicSetSrcHard(s.src, !!s.loop);
      try{ $bgm.currentTime = Math.max(0, s.time || 0); }catch(e){}
      try{ $bgm.volume = 0; }catch(e){}
      musicPlay();
      musicFadeTo(1, MUSIC_FADE_IN_MS);
    });
  }

  function playCaveEnter(src){
    if(!$bgm) return;
    Music.state.mode = "caveEnter";
    musicTransitionTo(src, false);
  }
  function playCaveLoop(src){
    if(!$bgm) return;
    Music.state.mode = "caveLoop";
    musicTransitionTo(src, true);
  }

  function onEnterCaves(){
    if(!$bgm) return;
    if(Music.state.inCave) return;

    Music.state.inCave = true;
    musicSaveCurrent();

    // Enter sting (one-shot), then handleBgmEnded will roll into cave loop.
    const pool = (Music.pools && Music.pools.caveEnter) ? Music.pools.caveEnter : [];
    const pick = pool.length ? weightedPick(pool).src : null;
    if(pick){
      playCaveEnter(pick);
    } else {
      // If no sting, go straight to loop
      const loopPool = (Music.pools && Music.pools.caveLoop) ? Music.pools.caveLoop : [];
      const lp = loopPool.length ? weightedPick(loopPool).src : null;
      if(lp) playCaveLoop(lp);
    }
  }

  function onExitCaves(){
    if(!Music.state.inCave) return;
    Music.state.inCave = false;
    musicRestoreSaved();
  }
  // end caves music

  function queueMusicTrigger(triggerName, retryInMs){
    //logMsg(`[Music] Queued ${triggerName}`);
    // de-dupe
    if(!Music.state.pending.includes(triggerName)){
      Music.state.pending.push(triggerName);
    }
    // schedule a retry when the lock is likely to clear
    if(Music.state.pendingTimer) return;
    const wait = Math.max(250, Math.min(60000, retryInMs || 1000));
    Music.state.pendingTimer = setTimeout(() => {
      Music.state.pendingTimer = null;
      processPendingMusicTriggers();
    }, wait);
  }

  function processPendingMusicTriggers(){
    if(!$bgm || uiMuted) return;
    if(Music.state.mode === "clip") return;

    // If still in intro, keep waiting
    if(Music.state.introStart){
      const elapsed = Date.now() - Music.state.introStart;
      if(elapsed < INTRO_LOCK_MS || Music.state.introPlaying){
        queueMusicTrigger(Music.state.pending[0] || "roam", INTRO_LOCK_MS - elapsed);
        return;
      }
    }

    // Try pending triggers in FIFO order
    while(Music.state.pending.length){
      const tname = Music.state.pending.shift();
      // Try without queue to avoid infinite loops
      musicMaybeTrigger(tname, false);
      if(Music.state.mode === "clip") break;
    }

    // ---- LIGHTING: soften the edge between visible torch radius and darkness ----
    try{
      const lvl = (game && game.levels) ? game.levels[game.depth] : null;
      const pl = lvl && lvl.player ? lvl.player : null;
      if(pl){
        const tileSize = Math.max(charW, charH);
        const visionTiles = (game.torch && game.torch.lit) ? game.torch.radius : (typeof VISION_DARK !== "undefined" ? VISION_DARK : 2);
        const FADE_TILES = 4.0; // width of the soft border (in tiles)
        const rOuter = Math.max(0.5, visionTiles + 0.25) * tileSize;
        const rInner = Math.max(0.0, (visionTiles - FADE_TILES)) * tileSize;

        const cx = (padL + pl.x * charW) + charW * 0.5;
        const cy = (padT + pl.y * charH) + charH * 0.55;

        // Darken outside radius with a smooth falloff.
        const grad = gctx.createRadialGradient(cx, cy, rInner, cx, cy, rOuter);
        grad.addColorStop(0.00, "rgba(0,0,0,0.00)");
        grad.addColorStop(0.55, "rgba(0,0,0,0.12)");
        grad.addColorStop(0.80, "rgba(0,0,0,0.45)");
        grad.addColorStop(1.00, "rgba(0,0,0,0.92)");
        gctx.save();
        gctx.globalCompositeOperation = "source-over";
        gctx.fillStyle = grad;
        gctx.fillRect(0,0,w,h);
        gctx.restore();
      }
    }catch(e){}

  }
function musicUserActivity(){
    // Called on first player movement (keyboard interaction) to unlock dynamic music flow.
    if(Music.state.userActive) return;
    Music.state.userActive = true;

    // Once the player starts moving, let triggers take over immediately (no intro lock).
    Music.state.introPlaying = false;
    Music.state.introStart = 0;

    // If unmuted and base track is loaded but not playing (autoplay restrictions), try to start it now.
    if(!$bgm || uiMuted) return;
    try{
      if($bgm.paused && $bgm.getAttribute("src")){
        musicPlay();
      }
    }catch(e){}
  }

function musicMaybeTrigger(triggerName, allowQueue=false){
    if(!$bgm || uiMuted) return;

    const t = Music.triggers[triggerName];
    if(!t) return;

    const now = Date.now();
    const last = Music.state.lastFire[triggerName] || 0;
    if(now - last < t.cooldownMs) return;

    // Once the player starts moving, let the system flow immediately (no intro lock).
    if(!Music.state.userActive){
      // Hard intro time lock: do not allow situational music before minimum time
      if(Music.state.introStart){
        const elapsed = Date.now() - Music.state.introStart;
        if(elapsed < INTRO_LOCK_MS){
          if(allowQueue) queueMusicTrigger(triggerName, INTRO_LOCK_MS - elapsed);
          return;
        }
      }

      // Soft intro lock: even after 45s, do not interrupt until the intro has finished
      if(Music.state.introPlaying){
        if(allowQueue) queueMusicTrigger(triggerName, 1000);
        return;
      }

      // If we're in caves, keep cave ambience stable (no roam/encounter overrides)
      if(Music.state.inCave){
        return;
      }

    }

    // Interrupt rules:
    // - Strong triggers (monsterEncounter, descend) may interrupt MANUAL clips.
    // - Weak triggers (roam) never interrupt an existing clip.
    if(Music.state.mode === "clip"){
      const strong = (triggerName === "monsterEncounter" || triggerName === "descend");
      if(!(strong && Music.state.clipSource === "manual")){
        return;
      }
    }

    if(Math.random() > t.prob) return;

    const pool = Music.pools[t.pool] || [];
    if(pool.length === 0) return;

    const pick = weightedPick(pool);
    Music.state.lastFire[triggerName] = now;
    playClip(pick.src);
  }

  // When a situational clip ends, return to base theme
  
  function handleBgmEnded(){

    // If cave enter sting ended, roll into cave loop (while still in cave)
    if(Music.state.mode === "caveEnter"){
      if(Music.state.inCave){
        const loopPool = (Music.pools && Music.pools.caveLoop) ? Music.pools.caveLoop : [];
        const lp = loopPool.length ? weightedPick(loopPool).src : null;
        if(lp) playCaveLoop(lp);
        return;
      } else {
        // somehow left cave during sting
        musicRestoreSaved();
        return;
      }
    }

    // If a situational clip ended, return to base loop
    if(Music.state.mode === "clip"){
      resumeBase();
      return;
    }

    // If the base intro finished, switch to looping base theme
    if(Music.state.mode === "base" && Music.state.introPlaying){
      Music.state.introPlaying = false;
      Music.state.introStart = 0;
      musicSetSrc(Music.base.src, true);
      try{ $bgm.currentTime = 0; }catch(e){}
      musicPlay();
    }
  }

    // Ensure we always respond when a track ends (clips, cave enter stings, etc.)
    if($bgm){
    $bgm.addEventListener("ended", handleBgmEnded);
    }

    // Autoplay fallback: retry once user interacts (browser policy)
    (function armAutoplayFallback(){
    const kick = () => {
        if(!pendingPlay) return;
        pendingPlay = false;
        musicPlay();
        // NOTE: do NOT remove listeners; pendingPlay can happen again later
    };
    window.addEventListener("keydown", kick, true);
    window.addEventListener("mousedown", kick, true);
    window.addEventListener("touchstart", kick, true);
    })();

  // Mute toggle (one-click unmute + immediate playback)
  if($muteBtn){
    $muteBtn.addEventListener("click", (e) => {
      e.preventDefault();
      const nextMuted = !uiMuted;
      setMuted(nextMuted);
      if(!nextMuted){
        musicPlay();
      }
    });
  }
  
  // Skip button: jump to end of current track (intro/clip/base). Useful for testing.
  if($skipBtn){
    $skipBtn.addEventListener("click", (e) => {
      e.preventDefault();
      musicSkipNext();
    });
  }

setMuted(uiMuted);

  
  // ---------- SFX ENGINE (plays over music) ----------
  // WebAudio-based (more reliable than <audio> nodes across browsers) + easy to extend.
  const SFX_MASTER = 0.55; // global SFX loudness (0..1)

  const SFX_DEFS = {
    step:    { src: "sfx_step.wav",        vol: 0.35 },
    bump:    { src: "sfx_wall_bump.wav",   vol: 0.55 },
    pickup:  { src: "sfx_pickup.wav",      vol: 0.55 },
    drink:   { src: "sfx_drink.wav",       vol: 0.50 },
    attack:  { src: "sfx_attack.wav",      vol: 0.60 },
    damage:  { src: "sfx_damage.wav",      vol: 0.70 },
    descend: { src: "sfx_descend.wav",     vol: 0.60 },
    wait:    { src: "sfx_wait.wav",        vol: 0.30 }
  };

  let sfxCtx = null;
  let sfxMasterGain = null;
  const sfxBuffers = {}; // name -> AudioBuffer
  let sfxReady = false;

  async function initSfxWebAudio(){
    try{
      sfxCtx = new (window.AudioContext || window.webkitAudioContext)();
      sfxMasterGain = sfxCtx.createGain();
      sfxMasterGain.gain.value = Math.max(0, Math.min(1, SFX_MASTER));
      sfxMasterGain.connect(sfxCtx.destination);

      const entries = Object.entries(SFX_DEFS);
      for(const [name, def] of entries){
        const primary = resolveAsset("sfx", def.src);
        const resp = await fetchWithFallback([primary, def.src], { cache: "no-store" });
        const arr = await resp.arrayBuffer();
        const buf = await sfxCtx.decodeAudioData(arr);
        sfxBuffers[name] = buf;
      }
      sfxReady = true;
    }catch(e){
      console.warn("SFX WebAudio init failed (check wav paths / browser):", e);
      sfxReady = false;
    }
  }

  function ensureSfxContextResumed(){
    if(!sfxCtx) return;
    if(sfxCtx.state === "suspended"){
      sfxCtx.resume().catch(()=>{});
    }
  }

  function playSfx(name){
    if(uiMuted) return;
    if(!sfxReady || !sfxCtx) return;
    const buf = sfxBuffers[name];
    if(!buf) return;

    ensureSfxContextResumed();

    const src = sfxCtx.createBufferSource();
    src.buffer = buf;

    const g = sfxCtx.createGain();
    const vol = (SFX_DEFS[name]?.vol ?? 0.5);
    g.gain.value = Math.max(0, Math.min(1, vol));

    src.connect(g);
    g.connect(sfxMasterGain);

    try{ src.start(0); }catch(e){}
  }

  // Kick off loading immediately; actual playback requires a user gesture to resume AudioContext (handled below).
  initSfxWebAudio();

  // Resume SFX context on first user gesture (keydown/click/touch)
  (function armSfxGestureResume(){
    const kick = () => {
      ensureSfxContextResumed();
      window.removeEventListener("keydown", kick, true);
      window.removeEventListener("mousedown", kick, true);
      window.removeEventListener("touchstart", kick, true);
    };
    window.addEventListener("keydown", kick, true);
    window.addEventListener("mousedown", kick, true);
    window.addEventListener("touchstart", kick, true);
  })();

  // Tiny self-test: press "V" to play a pickup sound (does not affect gameplay)
  window.addEventListener("keydown", (e) => {
    if(e.key === "v" || e.key === "V"){
      playSfx("pickup");
    }
  }, true);

// legend collapse controls
  const $legendToggle = document.getElementById('legendToggle');
  const $legendBody = document.getElementById('legendBody');
  let legendCollapsed = (localStorage.getItem("dd_legend_collapsed") ?? "1") === "1";
  function setLegendCollapsed(v){
    legendCollapsed = v;
    $legendBody.setAttribute('data-collapsed', legendCollapsed ? 'true' : 'false');
    $legendToggle.setAttribute('aria-expanded', legendCollapsed ? 'false' : 'true');
    localStorage.setItem("dd_legend_collapsed", legendCollapsed ? "1" : "0");
  }
  $legendToggle.addEventListener('click', () => setLegendCollapsed(!legendCollapsed));
  setLegendCollapsed(legendCollapsed);

  // Controls + Tips collapse (same pattern as Legend)
  const $controlsToggle = document.getElementById('controlsToggle');
  const $controlsBody = document.getElementById('controlsBody');
  const $tipsToggle = document.getElementById('tipsToggle');
  const $tipsBody = document.getElementById('tipsBody');

  function setCollapsed($toggle, $body, collapsed, key){
    if(!$toggle || !$body) return;
    $toggle.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
    $body.dataset.collapsed = collapsed ? 'true' : 'false';
    try{ localStorage.setItem(key, collapsed ? "1" : "0"); }catch(_){}
  }
  function getCollapsed(key, fallback){
    try{
      const v = localStorage.getItem(key);
      if(v === null) return fallback;
      return v === "1";
    }catch(_){ return fallback; }
  }

  let controlsCollapsed = getCollapsed("dd_controls_collapsed", false);
  let tipsCollapsed = getCollapsed("dd_tips_collapsed", false);

  if($controlsToggle){
    $controlsToggle.addEventListener('click', () => {
      controlsCollapsed = !controlsCollapsed;
      setCollapsed($controlsToggle, $controlsBody, controlsCollapsed, "dd_controls_collapsed");
    });
    setCollapsed($controlsToggle, $controlsBody, controlsCollapsed, "dd_controls_collapsed");
  }

  if($tipsToggle){
    $tipsToggle.addEventListener('click', () => {
      tipsCollapsed = !tipsCollapsed;
      setCollapsed($tipsToggle, $tipsBody, tipsCollapsed, "dd_tips_collapsed");
    });
    setCollapsed($tipsToggle, $tipsBody, tipsCollapsed, "dd_tips_collapsed");
  }

  function escapeHtml(s){
    return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
    // keep subtle pulses visible even when player is standing still
    if(window.__ambientNeeded){ requestAmbientFrame(); }
  }

  function renderLegend(){
    $legend.innerHTML = GLYPH_REGISTRY.map(row => {
      const g = row.glyph === ' ' ? '&nbsp;' : escapeHtml(row.glyph);
      return `
        <div class="legend-item">
          <div class="glyph" style="color:${row.color}">${g}</div>
          <div>${escapeHtml(row.name)}</div>
        </div>
      `;
    }).join('');
    $legendNote.innerHTML = LEGEND_NOTE;
  }

  // ---------- HELPERS ----------
  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
function choice(arr){ return arr[randInt(0, arr.length-1)]; }

function weightedChoice(items, weights){
  const total = weights.reduce((a,b)=>a+b,0);
  let r = Math.random()*total;
  for(let i=0;i<items.length;i++){
    r -= weights[i];
    if(r <= 0) return items[i];
  }
  return items[items.length-1];
}


  function shuffleInPlace(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function chance(p){ return Math.random() < p; }
  function keyXY(x,y){ return `${x},${y}`; }
  function parseKey(k){ const [x,y]=k.split(',').map(Number); return {x,y}; }

  // Consume a specific potion type regardless of pickup order (no FIFO/LIFO).
  function consumePotionByType(type){
    const inv = game.inv.potions;
    if(!Array.isArray(inv) || inv.length === 0) return false;
    const idx = inv.indexOf(type);
    if(idx === -1) return false;
    inv.splice(idx, 1);
    return true;
  }

  function debugFillPotions(){
    // Fill the potion belt to POTION_CAP with a balanced mix (healing favored).
    game.inv.potions.length = 0;

    // Target mix totals to exactly POTION_CAP (adjusts automatically if cap changes).
    const target = {
      [POTION.HEAL]: Math.round(POTION_CAP * 0.36),
      [POTION.POISON]: Math.round(POTION_CAP * 0.16),
      [POTION.INVIS]: Math.round(POTION_CAP * 0.16),
      [POTION.TRANSMUTE]: Math.round(POTION_CAP * 0.14),
      [POTION.INVINC]: Math.round(POTION_CAP * 0.13),
      [POTION.TELE]: Math.round(POTION_CAP * 0.05),
    };

    // Normalize in case rounding drifts.
    let total = Object.values(target).reduce((a,b)=>a+b,0);
    while(total > POTION_CAP){ target[POTION.HEAL]--; total--; }
    while(total < POTION_CAP){ target[POTION.HEAL]++; total++; }

    for(const [type, n] of Object.entries(target)){
      for(let i=0;i<n;i++) game.inv.potions.push(type);
    }
  }


  function countPotionsByType(){
    const counts = {
      [POTION.HEAL]: 0,
      [POTION.POISON]: 0,
      [POTION.INVIS]: 0,
      [POTION.TRANSMUTE]: 0,
      [POTION.INVINC]: 0,
      [POTION.TELE]: 0};
    for(const p of game.inv.potions){
      if(p in counts) counts[p] += 1;
    }
    return counts;
  }

  function makeGrid(w,h, fill){
    const g = new Array(w);
    for(let x=0;x<w;x++){
      g[x] = new Array(h);
      for(let y=0;y<h;y++) g[x][y] = fill;
    }
    return g;
  }

  // ---------- GAME STATE ----------
  let game;
  // Chaos-spawn tracking (unique IDs so kills still count after monsters move)
  let CHAOS_ID = 1;

  function newGame(){
    game = {
      depth: 1,
      maxDepth: 20,
      hpMax: 18,
      hp: 18,
      restFrac: 0,
      restHealedThisLevel: 0,
      restCapMsgShown: false,
      corpseTripLoreShown: false,
      corpseFieldLoreShown: false,
      seenAltar: false,
      atk: 3,
      weaponName: "Bare Hands",
      weaponEquipped: false,
      gold: 0,
      cgold: 0,
      inv: {
        potions: [],
        scrolls: [],
        keys: 0,
        torches: 0
      },
      effects: {
        grounding: false,
        poison: 0,
        invis: 0,
        transmute: 0,
        invincible: 0
      },
      torch: {
        lit: false,
        radius: VISION_DARK,
        burnLeft: 0,
        dimStepLeft: 0
      },
      msg: [],
      levels: {},
      prompt: null,
      slimeWait: false,
      ended: false,
      victory: null
    };

  // --- Intro Tome (lore) ---
  // Pre-seed lore lines so we don't touch startup flow (prevents blank viewport regressions)
  game.msg = [
    { type: "lore", text: "You descend upon a tattered tome that reads:" },
    { type: "lore", text: "No record agrees when these passages were writ, yet stone and steel bear the marks of forgotten tools and forgotten souls." },
    { type: "lore", text: "At the twentieth descent, even the will to live is put to question." },
    { type: "lore", text: "Whether this is an ending‚Äîor only a new beginning‚Äînone but you may say." }
  ];


    // Default starting supplies
    for(let i=0;i<DEFAULT_HEAL_POTIONS;i++) game.inv.potions.push(POTION.HEAL);
    if(DEBUG){
      debugFillPotions();
      logMsg("DEBUG: Potion belt filled for testing.");
    }

    loadLevel(1);
    logMsg("");
    logMsg("");
logMsg("");
    renderAll();
  }

  function endGameWin(){
    if(game.ended) return;
    game.ended = true;
    game.victory = true;
    logMsg("you win!");
    logMsg("Reset to play again.");
    renderAll(true);
  }

  function endGameLose(){
    if(game.ended) return;
    game.ended = true;
    game.victory = false;
    logMsg("Defeat ‚Äî the depths claim another explorer.");
    logMsg("Reset to try again.");
    renderAll(true);
  }

  function setPrompt(p){ game.prompt = p; updateContextPrompt(); }
  function clearPrompt(){
    // Remove prompt message from queue
    game.msg = game.msg.filter(m => m.type !== 'prompt');
    game.activePromptKey = null;
    renderMessages();
  }

  function setPromptMessage(text, key){
    if(!text){
      if(game.activePromptKey !== null) clearPrompt();
      return;
    }
    if(game.activePromptKey === key) return;

    // Replace any existing prompt
    game.msg = game.msg.filter(m => m.type !== 'prompt');
    game.msg.unshift({ text, type: 'prompt' });
    game.msg = game.msg.slice(0, 7);
    game.activePromptKey = key;
    renderMessages();
  }

  function updateContextPrompt(){
    const lvl = getLevel(game.depth);
    const ctx = getContextPrompt(lvl);

    if(!ctx){
      // If we just walked away from a relic prompt without claiming it, add a lore aftertaste.
      if(game.activePromptKey && typeof game.activePromptKey === 'string' && game.activePromptKey.startsWith('relic:')){
        const inCaves = isInCaves(game.player.y);
        if(inCaves && !game.relicJustClaimed){
          fireLoreOnce('cave_relic_refused', 'Some offerings are refused by both sides.');
        }
      }
      game.relicJustClaimed = false;
      setPromptMessage('', null);
      return;
    }

    if(ctx.type === 'trade'){
      const selLabel = (ctx.selection === 'A') ? 'Potion' : 'Weapon Upgrade';
      const promptText =
        `TRADER offers: A) Potion (${ctx.costPotion}GP) or B) Weapon Upgrade (${ctx.costUpgrade}GP)  Selected: ${selLabel}  [Y] to Buy`;
      setPromptMessage(promptText, `trade:${ctx.selection}:${game.gold}:${game.inv.keys}:${game.inv.torches}:${game.inv.potions.length}`);
      return;
    }

    if(ctx.type === 'relic'){
      fireLoreOnce('lore_relic', 'Something ancient seeks an audience.');
      setPromptMessage('Relic ‚Äî Press [Y] to claim', `relic:${ctx.id}`);
      return;
    }

    if(ctx.type === 'altar'){
      const txt = ctx.first ? 'Sacrifice at the alter?' : `Sacrifice ${ALTAR_GOLD_COST}GP at the alter?`;
      if(ctx.first) game.seenAltar = true;
      setPromptMessage(txt, `altar:${ctx.id}:${game.gold}:${game.hpMax}:${game.hp}`);
      return;
    }

    if(ctx.type === 'shrine'){
      fireLoreOnce('lore_shrine', 'Something listens.');
      setPromptMessage('Shrine ‚Äî Press [Y] to pray', `shrine:${ctx.id}`);
      return;
    }
  }

  
  // Context prompt state (trader selection persists while standing on trader)
  let TRADE_SELECTION = 'A'; // 'A' potion, 'B' upgrade
  let _wasOnTrader = false;
  let _noGoldWarnPotion = false;
  let _noGoldWarnUpgrade = false;

  function isOnTrader(lvl){
    const p = lvl.player;
    return lvl.traders && lvl.traders.has(keyXY(p.x, p.y));
  }

  function getContextPrompt(lvl){
    const p = lvl.player;
    const onTrader = isOnTrader(lvl);

    // Reset selection when leaving trader
    if(_wasOnTrader && !onTrader){
      TRADE_SELECTION = 'A';
      _noGoldWarnPotion = false;
      _noGoldWarnUpgrade = false;
    }
    _wasOnTrader = onTrader;

    if(onTrader){
      return {
        type: 'trade',
        selection: TRADE_SELECTION,
        costPotion: TRADER_POTION_COST,
        costUpgrade: TRADER_WEAPON_COST,
        atkBonus: TRADER_WEAPON_ATK_BONUS
      };
    }

    const k = keyXY(p.x, p.y);
    const it = lvl.items && lvl.items.get(k);
    if(!it) return null;

    if(it.type === ENT.SHRINE) return { type:'shrine', id: k };
    if(it.type === ENT.ALTAR) return { type:'altar', id: k, first: !game.seenAltar };
    // Chaos relic uses item type 'A' in this build
    if(it.type === 'A') return { type:'relic', id: k };

    return null;
  }

  function buyTraderPotion(){
    if(game.gold < TRADER_POTION_COST){
      logMsg(`Not enough gold. Potion costs ${TRADER_POTION_COST}g.`);
      return;
    }
    if(game.inv.potions.length >= POTION_CAP){
      logMsg(`Potion satchel is full (cap ${POTION_CAP}).`);
      return;
    }
    const __cost = TRADER_POTION_COST;
    const __usedC = Math.min(__cost, game.cgold || 0);
    const __usedG = __cost - __usedC;
    game.gold -= __cost;
    game.cgold = Math.max(0, (game.cgold || 0) - __usedC);
    if(__usedC > 0){
      const __lvl = getLevel(game.depth);
      __lvl.traderScurry = __lvl.traderScurry || new Set();
      __lvl.traderScurry.add(keyXY(__lvl.player.x, __lvl.player.y));
    }
    const potion = chance(0.60) ? POTION.HEAL : rollPotionType(game.depth);
    game.inv.potions.push(potion);
    logMsg(`Bought a ${POTION_NAME[potion]} potion for ${TRADER_POTION_COST}g.${__usedC>0 ? (' (spent ' + __usedC + ' blood-gold and ' + __usedG + ' gold).') : ''}`);
    if(__usedC>0 && (game.cgold||0) === 0){ logMsg('The last of the tainted coin leaves your purse.'); }
  }

  function buyTraderUpgrade(){
    if(game.gold < TRADER_WEAPON_COST){
      logMsg(`Not enough gold. Weapon upgrade costs ${TRADER_WEAPON_COST}g.`);
      return;
    }
    const __cost = TRADER_WEAPON_COST;
    const __usedC = Math.min(__cost, game.cgold || 0);
    const __usedG = __cost - __usedC;
    game.gold -= __cost;
    game.cgold = Math.max(0, (game.cgold || 0) - __usedC);
    if(__usedC > 0){
      const __lvl = getLevel(game.depth);
      __lvl.traderScurry = __lvl.traderScurry || new Set();
      __lvl.traderScurry.add(keyXY(__lvl.player.x, __lvl.player.y));
    }
    game.atk += TRADER_WEAPON_ATK_BONUS;
    game.weaponName = `${game.weaponName}+`;
    game.weaponEquipped = true;
    logMsg(`Upgraded weapon! ATK +${TRADER_WEAPON_ATK_BONUS} for ${TRADER_WEAPON_COST}g.${__usedC>0 ? (' (spent ' + __usedC + ' blood-gold and ' + __usedG + ' gold).') : ''}`);
    if(__usedC>0 && (game.cgold||0) === 0){ logMsg('The last of the tainted coin leaves your purse.'); }
  }

  function esc(s){ return escapeHtml(s); }
  function span(cls, s){ return `<span class="${cls}">${esc(s)}</span>`; }

  function formatMessageHTML(msg){
    const text = msg.text || "";
    const type = msg.type || "log";

    // --- Prompt highlight for relic (full line), with contrasting [Y] ---
    if(type === "prompt" && text === "Relic ‚Äî Press [Y] to claim"){
      return `<span class="msg-prompt-hl">Relic ‚Äî Press ${span("msg-key","[Y]")} to claim</span>`;
    }

    // Intro/system lines
    if(text === "" ||
       text.startsWith("It is dark. Vision is only") ||
       text === ""){
      return `<span class="msg-intro">${esc(text)}</span>`;
    }

    // Treasure: highlight '$' and '+N gold'
    let m = text.match(/^Found treasure \(\$\): \+(\d+) gold\.$/);
    if(m){
      const n = m[1];
      return `Found treasure (${span("msg-gold","$")}): ${span("msg-gold",`+${n} gold`)}.`;
    }

    // Drink Healing: color Healing and +N HP
    m = text.match(/^Drank Healing \(purple\)\. \+(\d+) HP\.$/);
    if(m){
      const n = m[1];
      return `Drank ${span("msg-potion-heal","Healing")} (purple). ${span("msg-potion-heal",`+${n} HP`)}.`;
    }

    // Picked up a KEY: color only the word key
    if(text === "Picked up a key."){
      return `Picked up a ${span("msg-key","key")}.`;
    }

    // Picked up potion: color potion name by type
    m = text.match(/^Picked up a (Healing|Poison|Invisibility|Transmutation|Invincibility) potion \(!\)\.$/);
    if(m){
      const nm = m[1];
      const clsMap = {
        "Healing":"msg-potion-heal",
        "Poison":"msg-potion-poison",
        "Invisibility":"msg-potion-invis",
        "Transmutation":"msg-potion-trans",
        "Invincibility":"msg-potion-invinc"
      };
      const cls = clsMap[nm] || "";
      return `Picked up a ${span(cls, nm)} potion (!).`;
    }

    // Secret: only color the word 'secret'
    if(/secret/i.test(text)){
      // Common lines: "Opened a secret door." / "Secret shortcut! ..."
      return esc(text).replace(/secret/ig, (w)=>`<span class="msg-secret">${w}</span>`);
    }

    // Scrolls: color only the scroll name (Illumination/Grounding/Attunement/Diminution)
    if(text.toLowerCase().includes("scroll of ")){
      return esc(text).replace(/scroll of ([A-Za-z]+)/i, (full, nm)=>{
        return `scroll of <span class="msg-scroll">${esc(nm)}</span>`;
      });
    }

    // Weapon found: color weapon name only
    m = text.match(/^Weapon found \([^)]+\): (.+?) \(ATK (\d+)\)\.$/);
    if(m){
      const nm = m[1];
      const atk = m[2];
      return `Weapon found (∆™): ${span("msg-weapon", nm)} (ATK ${esc(atk)}).`;
    }

    // Default: no special formatting
    return esc(text).replace(/blood-gold/ig,(w)=>`<span class="msg-cgold">${w}</span>`);
  }

function renderMessages(){
    const nearTop = ($log.scrollTop <= 24);
    const lines = game.msg.map(m => {
      const cls = m.type ? `logline ${m.type}` : 'logline';
      return `<div class="${cls}">${formatMessageHTML(m)}</div>`;
    }).join('');
    $log.innerHTML = `<h3>Messages</h3>${lines}`;
    if(nearTop) $log.scrollTop = 0;
  }

  function logMsg(text, type='log'){
    // Infer message type for styling when caller doesn't specify
    if(type === 'log'){
      const t = String(text||'');

      // damage taken / harm (keep broad but safe)
      if(/\bhits\b/i.test(t) && /\bfor\b/i.test(t)) type = 'hit';
      else if(/\b-\d+\s*HP\b/i.test(t)) type = 'hit';

      // loot / pickups / purchases
      else if(/^Picked up\b/i.test(t) || /^Found treasure\b/i.test(t) || /^Weapon found\b/i.test(t) || /^Bought\b/i.test(t) || /\+\d+\s*gold\b/i.test(t)) type = 'loot';

      // warnings / not enough / locked
      else if(/Not enough gold/i.test(t) || /\blocked\b/i.test(t) || /\bcannot\b/i.test(t)) type = 'warn';
    }

    // Global dedupe: don't repeat exact same message back-to-back
    if(game.msg.length && game.msg[0].text === text && game.msg[0].type === type) return;

    // Remove any existing prompt if we're logging a normal message
    if(type !== 'prompt' && type !== 'lore') {
      game.msg = game.msg.filter(m => m.type !== 'prompt');
      game.activePromptKey = null;
    }

    game.msg.unshift({ text, type });
    game.msg = game.msg.slice(0, 7);
    renderMessages();
  }

// ---------- LORE (run-persistent, non-blocking) ----------
function initLore(){
  game.loreFired = new Set();
  game.loreCooldown = 0;
  game.weaponUpgradeCount = 0;
  game.loreWeight = 0; // invisible "recognition" score
}
function tickLoreCooldown(){
  if(game.loreCooldown > 0) game.loreCooldown--;
}

// Lore metadata (internal only). Keep this tiny; it drives the cave "recognition" moment.
const LORE_META = {
  lore_relic:   { weight: 4, counts: true },
  lore_shrine:  { weight: 3, counts: true },
  lore_altar:   { weight: 4, counts: true },
  weapon_first: { weight: 2, counts: true },
  weapon_up1:   { weight: 2, counts: true },
  // Repeatable weapon-upgrade line intentionally does NOT add weight (prevents farming).
  // Env keys are dynamic (env_water_<depth>, etc.) and are handled by prefix in loreWeightForKey().
};

function loreWeightForKey(key){
  const m = LORE_META[key];
  if(m && m.counts) return m.weight|0;
  // Dynamic, once-per-level environment beats:
  if(key.startsWith('env_water_') || key.startsWith('env_fire_') || key.startsWith('env_mist_') || key.startsWith('env_slime_')){
    return 1;
  }
  return 0;
}

function loreAddWeight(key){
  if(!game.loreFired) initLore();
  const add = loreWeightForKey(key);
  if(add > 0) game.loreWeight = (game.loreWeight|0) + add;
}
function fireLoreOnce(key, text){
  if(!game.loreFired) initLore();
  if(game.loreFired.has(key)) return;
  if(game.loreCooldown > 0) return;
  logMsg(text, 'lore');
  game.loreFired.add(key);
  loreAddWeight(key);
  game.loreCooldown = 12; // spacing so lore never gets chatty
}
function fireLoreRepeat(text){
  // repeatable lore: respects cooldown but does not mark a key as fired
  if(!game.loreFired) initLore();
  if(game.loreCooldown > 0) return;
  logMsg(text, 'lore');
  game.loreCooldown = 12;
}


// ---------- CAVE LORE HELPERS ----------

// ---------- DANGER LORE (proximity, pre-combat, additive) ----------
function initDangerLore(){
  if(!game.dangerLoreFired) game.dangerLoreFired = new Set();
  if(typeof game.dangerLoreCooldown !== "number") game.dangerLoreCooldown = 0;
  if(!game.dangerLoreLastTurn) game.dangerLoreLastTurn = -1;
}

function tickDangerLoreCooldown(){
  if(game.dangerLoreCooldown > 0) game.dangerLoreCooldown--;
}

function dangerLoreEmitOnce(key, text){
  initDangerLore();
  if(game.dangerLoreFired.has(key)) return false;
  if(game.dangerLoreCooldown > 0) return false;
  logMsg(text, 'lore');
  game.dangerLoreFired.add(key);
  game.dangerLoreCooldown = 12;
  return true;
}

function dangerLoreEmitRepeat(text){
  initDangerLore();
  if(game.dangerLoreCooldown > 0) return false;
  logMsg(text, 'lore');
  game.dangerLoreCooldown = 12;
  return true;
}

// Detect high-salience threats nearby BEFORE combat starts.
// Called after computeFov so we can prefer visible threats, but it will also work without visibility.
function dangerLoreTick(lvl){
  if(!lvl || !lvl.player || game.ended) return;
  initDangerLore();
  tickDangerLoreCooldown();

  // prevent multiple danger loredrops within the same player turn
  if(game.turn != null && game.dangerLoreLastTurn === game.turn) return;

  const p = lvl.player;
  const px = p.x, py = p.y;

  // Helper: Chebyshev distance
  function cheb(x,y){ return Math.max(Math.abs(x-px), Math.abs(y-py)); }

  // Gather nearby monsters with distances; ignore if already adjacent (combat effectively started)
  const near = [];
  for(const [k,m] of lvl.monsters){
    if(!m) continue;
    const d = cheb(m.x, m.y);
    if(d <= 8) near.push({m,d});
  }
  if(!near.length) return;

  // If any monster is adjacent, do not fire danger lore (too late / already engaged)
  if(near.some(o => o.d <= 1)) return;

  // Prefer visible threats when possible
  const vis = (lvl.visible ? (x,y)=> !!(lvl.visible[x] && lvl.visible[x][y]) : null);
  const nearVis = vis ? near.filter(o => vis(o.m.x, o.m.y)) : [];

  // Count types in proximity (for packs/hordes)
  const countGlyph = (arr, glyphs) => arr.filter(o => glyphs.includes(o.m.glyph)).length;

  // Priority order: Dragon ‚Üí Elder Wyrm/Wyrm ‚Üí Horror ‚Üí Cyclops/Chief ‚Üí Spider/Queen ‚Üí Skeleton pack
  // Dragon (mythic restraint): once per run
  if(countGlyph(nearVis.length?nearVis:near, [ENT.DRAGON]) > 0){
    if(dangerLoreEmitOnce("danger_dragon", "The world already knows this name.")){
      game.dangerLoreLastTurn = (game.turn!=null?game.turn:game.dangerLoreLastTurn);
    }
    return;
  }

  // Wyrms: minion/elder escalation (once per level)
  if(countGlyph(nearVis.length?nearVis:near, [ENT.WYRM_ELDER, ENT.WYRM]) > 0){
    const key = "danger_wyrm_"+game.depth;
    if(dangerLoreEmitOnce(key, "The ground trembles. The walls are disturbed.")){
      game.dangerLoreLastTurn = (game.turn!=null?game.turn:game.dangerLoreLastTurn);
    }
    return;
  }

  // Horror: destabilization (once per level)
  if(countGlyph(nearVis.length?nearVis:near, [ENT.HORROR]) > 0){
    const key = "danger_horror_"+game.depth;
    if(dangerLoreEmitOnce(key, "Meaning thins nearby.")){
      game.dangerLoreLastTurn = (game.turn!=null?game.turn:game.dangerLoreLastTurn);
    }
    return;
  }

  // Cyclops / Chieftain: command & rank (once per level)
  if(countGlyph(nearVis.length?nearVis:near, [ENT.CYCLOPS, ENT.CYCLOPS_CHIEF]) > 0){
    const key = "danger_cyclops_"+game.depth;
    if(dangerLoreEmitOnce(key, "A fell calling from the captain echoes through the rank.")){
      game.dangerLoreLastTurn = (game.turn!=null?game.turn:game.dangerLoreLastTurn);
    }
    return;
  }

  // Spiders: anticipation (cooldown-limited, can repeat across levels)
  if(countGlyph(nearVis.length?nearVis:near, [ENT.SPIDER, ENT.SPIDER_QUEEN]) > 0){
    dangerLoreEmitRepeat("Your presence here seems anticipated.");
    game.dangerLoreLastTurn = (game.turn!=null?game.turn:game.dangerLoreLastTurn);
    return;
  }

  // Skeleton packs: many gather (once per level when >=2 skeletons nearby)
  const skCount = countGlyph(nearVis.length?nearVis:near, [ENT.SKELETON]);
  if(skCount >= 2){
    const key = "danger_skeleton_"+game.depth;
    if(dangerLoreEmitOnce(key, "Many gather.")){
      game.dangerLoreLastTurn = (game.turn!=null?game.turn:game.dangerLoreLastTurn);
    }
    return;
  }
}

function caveLoreCheck(lvl){
  if(!lvl || !lvl.player) return;
  const p = lvl.player;
  const inCave = (p.y >= CAVE_Y0) || (lvl.caveMask && lvl.caveMask[p.x] && lvl.caveMask[p.x][p.y]);
  if(!inCave) return;

  // 1) First sighting of skeleton packs in the dark (once per level)
  if(lvl.monsters && lvl.visible){
    for(const [k,m] of lvl.monsters.entries()){
      if(!m) continue;
      // Skeletons are marked via glyph, and often move in packs (packId).
      if(m.glyph !== ENT.SKELETON) continue;
      const pos = parseKey(k);
      if(lvl.visible[pos.x] && lvl.visible[pos.x][pos.y]){
        fireLoreOnce(`cave_skeleton_${game.depth}`, "Bones clatter where breath should be.");
        break;
      }
    }
  }

  // 2) First sighting of a Chaos Relic in a cave (once per level)
  if(lvl.items && lvl.visible){
    for(const [k,it] of lvl.items.entries()){
      if(!it || it.type !== 'A') continue;
      const pos = parseKey(k);
      if(lvl.visible[pos.x] && lvl.visible[pos.x][pos.y]){
        fireLoreOnce(`cave_relic_seen_${game.depth}`, "Something ancient seeks an audience.");
        break;
      }
    }
  }
}

  function getLevel(depth){ return game.levels[depth]; }
  function setLevel(depth, lvl){ game.levels[depth] = lvl; }

  function loadLevel(depth){
    let lvl = getLevel(depth);
    if(!lvl){
      lvl = generateLevel(depth);
      setLevel(depth, lvl);
    }
    game.depth = depth;
    game.restFrac = 0;
    game.restHealedThisLevel = 0;
    game.restCapMsgShown = false;
    // assign values for Corpse Field effect
    game.corpseWait = false;
    //game.corpseSlowLoreShown = false;
    game.corpseTripLoreShown = false;
    game.corpseFieldLoreShown = false;

    // Scroll effect reset: Diminution (invisibility) does not carry between levels.
    game.effects.invis = 0;
    game.effects.grounding = false;
    lvl.player = { ...lvl.startPos };
    clearPrompt();
    computeFov(lvl);
      try{ caveLoreCheck(lvl); }catch(_){ }
  }

  // ---------- EFFECTS ----------
  function hasInvincible(){ return game.effects.invincible > 0; }
  function hasInvis(){ return game.effects.invis > 0; }
  function hasTransmute(){ return game.effects.transmute > 0; }

  function tickEffectsOnStep(){
    if(game.effects.poison > 0){
      const dmg = randInt(POISON_DMG_RANGE[0], POISON_DMG_RANGE[1]);
      if(!hasInvincible()){
        game.hp -= dmg;
        logMsg(`Poison burns. -${dmg} HP (${game.effects.poison-1} steps left).`);
        if(game.hp <= 0){
          game.hp = 0;
          endGameLose();
          return;
        }
      } else {
        logMsg(`Poison tries to bite‚Ä¶ but invincibility holds (${game.effects.poison-1}).`);
      }
      game.effects.poison--;
    }

    if(game.effects.invis > 0){
      game.effects.invis--;
      if(game.effects.invis === 0) logMsg("Invisibility fades.");
    }
    if(game.effects.transmute > 0){
      game.effects.transmute--;
      if(game.effects.transmute === 0) logMsg("Transmutation ends.");
    }
    if(game.effects.invincible > 0){
      game.effects.invincible--;
      if(game.effects.invincible === 0) logMsg("Invincibility fades.");
    }
  }

  // ---------- TORCH ----------
  
  // ---------- ENVIRONMENT MECHANICS ----------
  function envAt(lvl, x, y){
    if(!lvl.env || !lvl.env[x]) return 0;
    return lvl.env[x][y];
  }

  // Fire environment lore on close proximity (doorway/edge), not only when standing inside.
  function envLoreProximity(lvl, x, y){
    const R = 2;
    let sawWater=false, sawMist=false, sawFire=false, sawSlime=false;
    for(let dx=-R; dx<=R; dx++){
      for(let dy=-R; dy<=R; dy++){
        if(dx===0 && dy===0) continue;
        const e = envAt(lvl, x+dx, y+dy);
        if(e === 'water') sawWater = true;
        else if(e === 'mist') sawMist = true;
        else if(e === 'fire') sawFire = true;
        else if(e === 'slime') sawSlime = true;
      }
    }
    if(sawWater) fireLoreOnce(`env_water_${game.depth}`, "This room is drowned in its own reflections.");
    if(sawMist)  fireLoreOnce(`env_mist_${game.depth}`,  "The air here is opaque as white silk.");
    if(sawFire)  fireLoreOnce(`env_fire_${game.depth}`,  "These cinders cast a dim indifference to pain.");
    if(sawSlime) fireLoreOnce(`env_slime_${game.depth}`, "A seething slog seeps across slimy stone.");
  }


  function handleWaterEffectsOnEnter(lvl){
    // Extinguish lit torch immediately
    if(game.torch.lit){
      game.torch.lit = false;
      game.torch.radius = VISION_DARK;
      game.torch.burnLeft = 0;
      game.torch.dimStepLeft = 0;
      logMsg("Water extinguishes your torch.");
    }

    // Drop any spare torches carried
    if(game.inv.torches > 0){
      const dropCount = game.inv.torches;
      game.inv.torches = 0;
      logMsg("You drop your saturated torches.");

      const p = lvl.player;
      const k = keyXY(p.x, p.y);
      if(lvl.items.has(k)){
        // If something already exists here, we just lose them (rare)
      } else {
        lvl.items.set(k, { type: ENT.TORCH, count: dropCount });
      }
    }
  }

  function applyEnvironmentOnEnter(lvl, prevX, prevY, newX, newY){
    // Environment lore triggers when near an environment region
    envLoreProximity(lvl, newX, newY);
    const e = envAt(lvl, newX, newY);

    if(e === 'water'){
      // Flavor message + then apply torch/gear effects
      fireLoreOnce(`env_water_${game.depth}`, "This room is drowned in its own reflections.");
      handleWaterEffectsOnEnter(lvl);
} else if(e === 'mist'){
      fireLoreOnce(`env_mist_${game.depth}`, "The air here is opaque as white silk.");
} else if(e === 'slime'){
      fireLoreOnce(`env_slime_${game.depth}`, "A seething slog seeps across slimy stone.");

} else if(e === 'fire'){
      fireLoreOnce(`env_fire_${game.depth}`, "These cinders cast a dim indifference to pain.");
if(!hasInvincible()){
        game.hp -= 2;
        logMsg("Fire scorches you. -2 HP.");
        if(game.hp <= 0){
          game.hp = 0;
          endGameLose();
          return;
        }
      }
    }
    // Slime remains handled by the movement-slow logic (as-is)
  }
function currentVisionRadius(){
    const lvl = getLevel(game.depth);
    const p = lvl.player;

    // Blackout rooms: torches have no effect; clamp FOV to 1.
    if(lvlIsInBlackoutRoom(lvl, p.x, p.y)) return 1;

    const e = envAt(lvl, p.x, p.y);
    if(e === 'mist'){
      return game.torch.lit ? 1 : 0;
    }
    return game.torch.radius;
  }

  function startNewTorchBurn(){
    game.torch.lit = true;
    game.torch.radius = VISION_DEFAULT;
    game.torch.burnLeft = TORCH_BURN_MOVES;
    game.torch.dimStepLeft = TORCH_DIM_STEP_MOVES;
  }

  function maybeAutoLightTorch(){
    if(game.torch.lit) return;
    if(game.inv.torches <= 0) return;
    game.inv.torches--;
    startNewTorchBurn();
    logMsg("A torch flares to life. The darkness retreats.");
  }

  function extinguishTorch(){
    game.torch.lit = false;
    game.torch.radius = VISION_DARK;
    game.torch.burnLeft = 0;
    game.torch.dimStepLeft = 0;
    logMsg("The torch sputters out. Darkness returns.");
    maybeAutoLightTorch();
  }

  function advanceTorchOnMove(){
    if(!game.torch.lit) return;

    if(game.torch.burnLeft > 0){
      game.torch.burnLeft--;
      if(game.torch.burnLeft === 0){
        logMsg("Your torch grows dim.");
      }
      return;
    }

    game.torch.dimStepLeft--;
    if(game.torch.dimStepLeft > 0) return;

    game.torch.dimStepLeft = TORCH_DIM_STEP_MOVES;
    if(game.torch.radius > VISION_DARK){
      game.torch.radius--;
      if(game.torch.radius > VISION_DARK){
      } else {
        extinguishTorch();
      }
    } else {
      extinguishTorch();
    }
  }

  // ---------- GENERATION HELPERS ----------
  function rectsOverlapInflated(a,b,pad){
    const ax1=a.x-pad, ay1=a.y-pad, ax2=a.x+a.w+pad, ay2=a.y+a.h+pad;
    const bx1=b.x, by1=b.y, bx2=b.x+b.w, by2=b.y+b.h;
    return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;
  }

  function carveRoom(tiles, r, secretGrid=null){
    for(let x=r.x;x<r.x+r.w;x++){
      for(let y=r.y;y<r.y+r.h;y++){
        tiles[x][y] = TILE.FLOOR;
        if(secretGrid) secretGrid[x][y] = true;
      }
    }
  }

  function carveH(tiles, x1,x2,y, secretGrid=null){
    const [a,b] = x1<x2 ? [x1,x2] : [x2,x1];
    for(let x=a;x<=b;x++){
      if(tiles[x][y] === TILE.ROCK) tiles[x][y] = TILE.CORR;
      if(secretGrid) secretGrid[x][y] = true;
    }
  }

  function carveV(tiles, y1,y2,x, secretGrid=null){
    const [a,b] = y1<y2 ? [y1,y2] : [y2,y1];
    for(let y=a;y<=b;y++){
      if(tiles[x][y] === TILE.ROCK) tiles[x][y] = TILE.CORR;
      if(secretGrid) secretGrid[x][y] = true;
    }
  }

  function carveCorridor(tiles, x1,y1,x2,y2){
    if(Math.random()<0.5){
      carveH(tiles, x1,x2,y1);
      carveV(tiles, y1,y2,x2);
    } else {
      carveV(tiles, y1,y2,x1);
      carveH(tiles, x1,x2,y2);
    }
  }

  function findOpenSpot(tiles, room){
    for(let tries=0; tries<2000; tries++){
      const x = randInt(room.x+1, room.x+room.w-2);
      const y = randInt(room.y+1, room.y+room.h-2);
      const t = tiles[x][y];
      if(t===TILE.FLOOR || t===TILE.CORR) return {x,y};
    }
    for(let x=1;x<MAP_W-1;x++){
      for(let y=1;y<DUNGEON_H-1;y++){
        const t = tiles[x][y];
        if(t===TILE.FLOOR || t===TILE.CORR) return {x,y};
      }
    }
    return {x:2,y:2};
  }

    function findRandomOpenTile(lvl){
    let x, y, tries = 0;
    do{
      x = randInt(1, MAP_W - 2);
      y = randInt(1, MAP_H - 2);
      tries++;
      if(tries > 4000) break;

      const k = keyXY(x,y);

      if(lvl.tiles[x][y] !== TILE.FLOOR) continue;
      if(lvl.player && lvl.player.x === x && lvl.player.y === y) continue;
      if(lvl.monsters && lvl.monsters.has && lvl.monsters.has(k)) continue;
      if(lvl.traders && lvl.traders.has && lvl.traders.has(k)) continue;

      return {x,y};
    }while(true);

    // fallback: keep current position
    return {x: lvl.player.x, y: lvl.player.y};
  }

  function scatter(map, tiles, count, makeObj, canPlaceFn=null, forbidFn=null){
    let placed=0;
    for(let tries=0; tries<25000 && placed<count; tries++){
      const x = randInt(2, MAP_W-3);
      const y = randInt(2, MAP_H-3);
      if(canPlaceFn && !canPlaceFn(x,y)) continue;
      if(forbidFn && forbidFn(x,y)) continue;

      const k = keyXY(x,y);
      if(map.has(k)) continue;

      const t = tiles[x][y];
      if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
      if(t===TILE.DOWN || t===TILE.SDOWN) continue;
      if(t===TILE.DOOR_C || t===TILE.DOOR_O || t===TILE.LDOOR_C) continue;

      map.set(k, makeObj(x,y));
      placed++;
    }
  }

  function weaponNameForDepth(d){
    if(d<6) return "Short Sword";
    if(d<12) return "Long Sword";
    if(d<18) return "Runed Blade";
    return "Deepsteel Edge";
  }
  function weaponAtkForDepth(d){
    if(d<6) return 4;
    if(d<12) return 6;
    if(d<18) return 8;
    return 10;
  }

  function monsterPoolForDepth(d){
    const pool = [
      { glyph: ENT.GOBLIN, name: "Goblin", hp:[4,7], atk:[1,3], weight: 6 },
      { glyph: ENT.ORC,    name: "Orc",    hp:[7,12], atk:[2,5], weight: 4 }
    ];
    if(d >= 3)  pool.push({ glyph: ENT.SNAKE,  name:"Green Snake",           hp:[5,9],  atk:[2,4], weight: 4 });
    if(d >= 6)  pool.push({ glyph: ENT.CUBE,   name:"Blue Gelatinous Cube",  hp:[9,14], atk:[3,5], weight: 3 });
    if(d >= 9)  pool.push({ glyph: ENT.DRAGON, name:"Red Fire Dragon",       hp:[14,20],atk:[5,8], weight: 2 });
    if(d >= 12) pool.push({ glyph: ENT.CRAWLER,name:"Orange Carrion Crawler",hp:[12,18],atk:[4,7], weight: 3 });
    if(d >= 15) pool.push({ glyph: ENT.WALKER, name:"White Undead Walker",   hp:[16,24],atk:[5,8], weight: 3 });
    if(d >= 18) pool.push({ glyph: ENT.WRAITH, name:"Elder Ringwraith",      hp:[22,30],atk:[7,10],weight: 2 });
    return pool;
  }

  function pickWeighted(pool){
    const total = pool.reduce((s,p)=>s+p.weight,0);
    let r = Math.random()*total;
    for(const p of pool){
      r -= p.weight;
      if(r <= 0) return p;
    }
    return pool[pool.length-1];
  }

  function makeMonsterForDepth(d){
    const base = pickWeighted(monsterPoolForDepth(d));
    return {
      glyph: base.glyph,
      name: base.name,
      hp: randInt(base.hp[0], base.hp[1]),
      atk: randInt(base.atk[0], base.atk[1])
    };
  }

// ---------- SKELETON PACKS ----------
let SKELETON_PACK_ID = 1;

function makeSkeletonForDepth(d){
  // Slightly tougher than an orc, weaker than a walker
  const hp = randInt(6, 10) + Math.floor(d/4);
  const atk = randInt(2, 4) + Math.floor(d/10);
  return { glyph: ENT.SKELETON, name: "Skeleton", hp, atk, packId: 0, packLeader: false };
}

function spawnSkeletonPacks(lvl, depth, monsters, tiles, isNormal, forbidOnTrader, startPos){
  // Skeletons do NOT spawn as singles. Packs of 2‚Äì5, moving as a herd.
  if (depth < 1) return 0;

  const MAX_SKELETONS_PER_LEVEL = (depth <= 1) ? 5 : 10; // hard cap per floor for testing/balance

  const minDistFromStart = (depth <= 1) ? 12 : 7;
  const packChance = (depth <= 1) ? 0.75 : (depth < 10) ? 0.35 : (depth < 16) ? 0.45 : 0.55;
  const maxPacks   = (depth <= 1) ? 1 : (depth < 10) ? 1 : 2;

  let spawned = 0;

  for(let pack=0; pack<maxPacks; pack++){
    if(spawned >= MAX_SKELETONS_PER_LEVEL) break;
    if(Math.random() > packChance) continue;

    // Pick a leader location first
    let lx=-1, ly=-1;
    let placedLeader = false;

    for(let tries=0; tries<12000 && !placedLeader; tries++){
      const x = randInt(2, MAP_W-3);
      const y = randInt(2, MAP_H-3);
      if(!isNormal(x,y)) continue;
      if(forbidOnTrader(x,y)) continue;
      if(Math.max(Math.abs(x-startPos.x), Math.abs(y-startPos.y)) < minDistFromStart) continue;

      const t = tiles[x][y];
      if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
      if(t===TILE.DOWN || t===TILE.SDOWN) continue;
      if(t===TILE.DOOR_C || t===TILE.DOOR_O || t===TILE.LDOOR_C) continue;

      const k = keyXY(x,y);
      if(monsters.has(k) || lvl.traders.has(k)) continue;

      lx=x; ly=y; placedLeader = true;
    }

    if(!placedLeader) continue;

    const packId = SKELETON_PACK_ID++;
    // Respect per-floor cap (prevents "11 skeletons on level 1" surprises)
    const remaining = MAX_SKELETONS_PER_LEVEL - spawned;
    if(remaining < 2) break; // a pack must be at least 2
    const n = Math.min(randInt(2,5), remaining); // pack size 2‚Äì5 (clamped by remaining cap)

    // Place leader
    {
      const k = keyXY(lx,ly);
      const m = makeSkeletonForDepth(depth);
      m.packId = packId;
      m.packLeader = true;
      monsters.set(k, m);
      spawned++;
    }

    // Place the rest near the leader (true BFS around leader so packs stay clustered)
let placed = 1;
const dirs = [
  {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},
  {dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}
];

function isSkeletonSpawnOK(x,y){
  if(x<2||y<2||x>=MAP_W-2||y>=MAP_H-2) return false;
  if(!isNormal(x,y)) return false;
  if(forbidOnTrader(x,y)) return false;
  const t = tiles[x][y];
  // Only on walkable carved space (works in both dungeon + caves because caves use FLOOR too)
  if(!(t===TILE.FLOOR || t===TILE.CORR)) return false;
  // Never on stairs/doors
  if(t===TILE.DOWN || t===TILE.SDOWN) return false;
  if(t===TILE.DOOR_C || t===TILE.DOOR_O || t===TILE.LDOOR_C) return false;
  const k = keyXY(x,y);
  if(monsters.has(k) || lvl.traders.has(k)) return false;
  return true;
}

// BFS from leader to collect nearest valid cells
const q = [{x: lx, y: ly}];
const seen = new Set([keyXY(lx,ly)]);
const candidates = [];

while(q.length && candidates.length < 80){
  const cur = q.shift();
  // randomize neighbor order a bit
  for(let i=0;i<dirs.length;i++){
    const d = dirs[randInt(0, dirs.length-1)];
    const nx = cur.x + d.dx, ny = cur.y + d.dy;
    const kk = keyXY(nx,ny);
    if(seen.has(kk)) continue;
    seen.add(kk);
    if(nx<1||ny<1||nx>=MAP_W-1||ny>=MAP_H-1) continue;

    // expand through walkable-ish tiles so we stay in the same region
    const tt = tiles[nx][ny];
    const walk = (tt===TILE.FLOOR || tt===TILE.CORR || tt===TILE.DOOR_C || tt===TILE.DOOR_O || tt===TILE.SD_C || tt===TILE.SD_O || tt===TILE.CAVE_C || tt===TILE.CAVE_O || tt===TILE.DOWN || tt===TILE.SDOWN);
    if(walk) q.push({x:nx,y:ny});

    if(isSkeletonSpawnOK(nx,ny)){
      candidates.push({x:nx,y:ny});
      if(candidates.length >= 80) break;
    }
  }
}

// Prefer the closest tiles to leader, then place until n reached
candidates.sort((a,b)=>{
  const da = Math.max(Math.abs(a.x-lx), Math.abs(a.y-ly));
  const db = Math.max(Math.abs(b.x-lx), Math.abs(b.y-ly));
  return da - db;
});

for(const c of candidates){
  if(placed >= n) break;
  const x = c.x, y = c.y;
  const k = keyXY(x,y);
  if(monsters.has(k) || lvl.traders.has(k)) continue;

  const m = makeSkeletonForDepth(depth);
  m.packId = packId;
  m.packLeader = false;
  monsters.set(k, m);
  placed++; spawned++;
}
  }

  return spawned;
}

// ---------- HERD PACKS (Cyclops / Spiders / Wyrms) ----------
let HERD_PACK_ID = 1000;

function makeHerdMonster(spec, depth, isLeader){
  // Higher-tier herd mobs (depth 9+) should outclass baseline monsters at that depth.
  const hp = randInt(spec.hp[0], spec.hp[1]) + Math.floor(depth/2);
  const atk = randInt(spec.atk[0], spec.atk[1]) + Math.floor(depth/10);

  const m = {
    glyph: isLeader ? spec.leaderGlyph : spec.glyph,
    name:  isLeader ? spec.leaderName  : spec.name,
    hp: isLeader ? hp + randInt(spec.leaderHpBonus[0], spec.leaderHpBonus[1]) : hp,
    atk: isLeader ? atk + randInt(spec.leaderAtkBonus[0], spec.leaderAtkBonus[1]) : atk,
    packId: 0,
    packLeader: !!isLeader,
    herdType: spec.key
  };
  return m;
}

function spawnHerdPacks(lvl, depth, monsters, tiles, isNormal, forbidOnTrader, startPos, spec){
  if(depth < spec.minDepth) return 0;

  const maxPacks = spec.maxPacks(depth);
  const packChance = spec.packChance(depth);
  const capPerFloor = spec.capPerFloor(depth);

  const minDistFromStart = (depth <= 10) ? 8 : 6;

  let spawned = 0;

  for(let pack=0; pack<maxPacks; pack++){
    if(spawned >= capPerFloor) break;
    if(Math.random() > packChance) continue;

    // Pick a leader location first
    let lx=-1, ly=-1;
    let placedLeader = false;

    for(let tries=0; tries<9000 && !placedLeader; tries++){
      const x = randInt(2, MAP_W-3);
      const y = randInt(2, MAP_H-3);

      if(startPos){
        const dx = x - startPos.x, dy = y - startPos.y;
        if(Math.sqrt(dx*dx + dy*dy) < minDistFromStart) continue;
      }
      if(!isNormal(x,y)) continue;
      if(forbidOnTrader(x,y)) continue;

      const t = tiles[x][y];
      if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
      if(t===TILE.DOWN || t===TILE.SDOWN) continue;
      if(t===TILE.DOOR_C || t===TILE.DOOR_O || t===TILE.LDOOR_C) continue;

      const k = keyXY(x,y);
      if(monsters.has(k) || lvl.traders.has(k)) continue;

      lx=x; ly=y; placedLeader = true;
    }

    if(!placedLeader) continue;

    const packId = HERD_PACK_ID++;
    const remaining = capPerFloor - spawned;
    if(remaining < 2) break;

    const n = Math.min(randInt(spec.packSize[0], spec.packSize[1]), remaining);

    // Place leader
    {
      const k = keyXY(lx,ly);
      const m = makeHerdMonster(spec, depth, true);
      m.packId = packId;
      monsters.set(k, m);
      spawned++;
    }

    // Place followers near leader (BFS around leader)
    let placed = 1;
    const dirs = [
      {dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1},
      {dx:1,dy:1},{dx:1,dy:-1},{dx:-1,dy:1},{dx:-1,dy:-1}
    ];

    function isHerdSpawnOK(x,y){
      if(x<2||y<2||x>=MAP_W-2||y>=MAP_H-2) return false;
      if(!isNormal(x,y)) return false;
      if(forbidOnTrader(x,y)) return false;
      const t = tiles[x][y];
      if(!(t===TILE.FLOOR || t===TILE.CORR)) return false;
      if(t===TILE.DOWN || t===TILE.SDOWN) return false;
      if(t===TILE.DOOR_C || t===TILE.DOOR_O || t===TILE.LDOOR_C) return false;
      const k = keyXY(x,y);
      if(monsters.has(k) || lvl.traders.has(k)) return false;
      return true;
    }

    const q = [{x:lx,y:ly}];
    const seen = new Set([keyXY(lx,ly)]);
    while(q.length && placed < n){
      const cur = q.shift();
      for(const d0 of dirs){
        const nx = cur.x + d0.dx, ny = cur.y + d0.dy;
        const kk = keyXY(nx,ny);
        if(seen.has(kk)) continue;
        seen.add(kk);
        if(isHerdSpawnOK(nx,ny)){
          const m = makeHerdMonster(spec, depth, false);
          m.packId = packId;
          m.packLeader = false;
          monsters.set(kk, m);
          placed++; spawned++;
          if(placed >= n) break;
        }
        q.push({x:nx,y:ny});
      }
    }
  }

  return spawned;
}

const HERD_SPECS = [
  {
    key: "cyclops",
    name: "Cyclops",
    leaderName: "Cyclops Chieftain",
    glyph: ENT.CYCLOPS,
    leaderGlyph: ENT.CYCLOPS_CHIEF,
    minDepth: 9,
    hp: [22, 30],
    atk: [6, 9],
    leaderHpBonus: [6, 12],
    leaderAtkBonus: [2, 4],
    packSize: [2, 4],
    capPerFloor: (d)=> (d < 16 ? 6 : 8),
    maxPacks: (d)=> (d < 16 ? 1 : 2),
    packChance: (d)=> (d < 12 ? 0.22 : d < 16 ? 0.30 : 0.36)
  },
  {
    key: "spider",
    name: "Spider",
    leaderName: "Spider Queen",
    glyph: ENT.SPIDER,
    leaderGlyph: ENT.SPIDER_QUEEN,
    minDepth: 11,
    hp: [18, 26],
    atk: [5, 8],
    leaderHpBonus: [8, 14],
    leaderAtkBonus: [2, 4],
    packSize: [3, 6],
    capPerFloor: (d)=> (d < 16 ? 7 : 10),
    maxPacks: (d)=> (d < 16 ? 1 : 2),
    packChance: (d)=> (d < 14 ? 0.25 : d < 18 ? 0.33 : 0.40)
  },
  {
    key: "wyrm",
    name: "Wyrm Minion",
    leaderName: "Elder Wyrm",
    glyph: ENT.WYRM,
    leaderGlyph: ENT.WYRM_ELDER,
    minDepth: 13,
    hp: [26, 36],
    atk: [7, 11],
    leaderHpBonus: [10, 18],
    leaderAtkBonus: [3, 5],
    packSize: [2, 5],
    capPerFloor: (d)=> (d < 18 ? 6 : 9),
    maxPacks: (d)=> (d < 18 ? 1 : 2),
    packChance: (d)=> (d < 16 ? 0.20 : d < 20 ? 0.28 : 0.34)
  }
];

  function isAreaAllRock(tiles, x0,y0,w,h){
    for(let x=x0; x<x0+w; x++){
      for(let y=y0; y<y0+h; y++){
        if(x<1||y<1||x>=MAP_W-1||y>=MAP_H-1) return false;
        if(tiles[x][y] !== TILE.ROCK) return false;
      }
    }
    return true;
  }

  function addSecretRooms(lvl, depth){
    const tiles = lvl.tiles;
    const secret = lvl.secret;
    const secretDoors = lvl.secretDoors;

    const secretCount = randInt(SECRET_ROOM_MIN, SECRET_ROOM_MAX);
    const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];

    let placed = 0;
    for(let attempts=0; attempts<2200 && placed<secretCount; attempts++){
      const ax = randInt(2, MAP_W-3);
      const ay = randInt(2, MAP_H-3);
      const at = tiles[ax][ay];
      if(!(at===TILE.FLOOR || at===TILE.CORR)) continue;
      if(secret[ax][ay]) continue;

      const dir = dirs[randInt(0, dirs.length-1)];
      const wx = ax + dir.dx;
      const wy = ay + dir.dy;
      if(wx<2||wy<2||wx>=MAP_W-2||wy>=MAP_H-2) continue;
      if(tiles[wx][wy] !== TILE.ROCK) continue;

      const len = randInt(2, 5);
      const rw = randInt(4, 8);
      const rh = randInt(4, 7);
      const endx = wx + dir.dx * len;
      const endy = wy + dir.dy * len;

      let rx, ry;
      if(dir.dx !== 0){
        rx = endx + (dir.dx > 0 ? 0 : -rw+1);
        ry = endy - Math.floor(rh/2);
      } else {
        rx = endx - Math.floor(rw/2);
        ry = endy + (dir.dy > 0 ? 0 : -rh+1);
      }

      let corridorOk = true;
      for(let i=1;i<=len;i++){
        const x = wx + dir.dx*i;
        const y = wy + dir.dy*i;
        if(x<1||y<1||x>=MAP_W-1||y>=MAP_H-1) { corridorOk=false; break; }
        if(tiles[x][y] !== TILE.ROCK) { corridorOk=false; break; }
      }
      if(!corridorOk) continue;
      if(!isAreaAllRock(tiles, rx, ry, rw, rh)) continue;

      const wk = keyXY(wx,wy);
      if(secretDoors.has(wk)) continue;
      secretDoors.set(wk, { discovered:false });

      for(let i=1;i<=len;i++){
        const x = wx + dir.dx*i;
        const y = wy + dir.dy*i;
        tiles[x][y] = TILE.CORR;
        secret[x][y] = true;
      }
      carveRoom(tiles, {x:rx,y:ry,w:rw,h:rh}, secret);

      if(chance(SECRET_SHORTCUT_CHANCE) && depth < 20){
        const sx = randInt(rx+1, rx+rw-2);
        const sy = randInt(ry+1, ry+rh-2);
        tiles[sx][sy] = TILE.SDOWN;
      }

      placed++;
    }
  }

  // ---------- DOORS ----------
  function isPassableForDoorCandidate(t){ return (t === TILE.FLOOR || t === TILE.CORR); }
  function isWall(t){ return (t === TILE.ROCK); }
  function inBounds(x,y){ return x>=1 && y>=1 && x<MAP_W-1 && y<MAP_H-1; }
  function isExistingDoor(t){
    return (t === TILE.DOOR_C || t === TILE.DOOR_O || t === TILE.LDOOR_C || t === TILE.SD_C || t === TILE.SD_O);
  }

  function placeDoorsOnChokepoints(lvl){
    const tiles = lvl.tiles;
    const candidates = [];

    for(let x=2; x<MAP_W-2; x++){
      for(let y=2; y<DUNGEON_H-2; y++){
        const t = tiles[x][y];
        if(!isPassableForDoorCandidate(t)) continue;
        if(t === TILE.DOWN || t === TILE.SDOWN) continue;
        if(lvl.secret[x][y]) continue;

        const n = tiles[x][y-1], s = tiles[x][y+1], w = tiles[x-1][y], e = tiles[x+1][y];

        const passN = isPassableForDoorCandidate(n) || n === TILE.DOWN || n === TILE.SDOWN;
        const passS = isPassableForDoorCandidate(s) || s === TILE.DOWN || s === TILE.SDOWN;
        const passW = isPassableForDoorCandidate(w) || w === TILE.DOWN || w === TILE.SDOWN;
        const passE = isPassableForDoorCandidate(e) || e === TILE.DOWN || e === TILE.SDOWN;

        const wallN = isWall(n);
        const wallS = isWall(s);
        const wallW = isWall(w);
        const wallE = isWall(e);

        const verticalChoke = passN && passS && wallW && wallE;
        const horizChoke    = passW && passE && wallN && wallS;

        if(!(verticalChoke || horizChoke)) continue;

        candidates.push({x,y});
      }
    }

    for(let i=candidates.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
    }

    const doors = [];
    for(const c of candidates){
      if(!chance(DOOR_CHANCE)) continue;

      let nearStairs = false;
      for(let dx=-1; dx<=1; dx++){
        for(let dy=-1; dy<=1; dy++){
          const nx=c.x+dx, ny=c.y+dy;
          if(!inBounds(nx,ny)) continue;
          const tt = tiles[nx][ny];
          if(tt === TILE.DOWN || tt === TILE.SDOWN){ nearStairs = true; break; }
        }
        if(nearStairs) break;
      }
      if(nearStairs) continue;

      let adjDoor = false;
      for(let dx=-1; dx<=1; dx++){
        for(let dy=-1; dy<=1; dy++){
          if(dx===0 && dy===0) continue;
          const nx=c.x+dx, ny=c.y+dy;
          if(!inBounds(nx,ny)) continue;
          if(isExistingDoor(tiles[nx][ny])) { adjDoor=true; break; }
        }
        if(adjDoor) break;
      }
      if(adjDoor) continue;

      tiles[c.x][c.y] = TILE.DOOR_C;
      doors.push({x:c.x, y:c.y});
    }

    return doors;
  }

  function lockDoorsNoAdjacency(tiles, doorCoords, startPos){
    const lockedSet = new Set();
    const isDoorTile = (t) => (t===TILE.DOOR_C || t===TILE.LDOOR_C || t===TILE.DOOR_O);

    for(const d of doorCoords){
      if(!chance(LOCKED_DOOR_CHANCE)) continue;
      const dist = Math.max(Math.abs(d.x-startPos.x), Math.abs(d.y-startPos.y));
      if(dist < 4) continue;
      tiles[d.x][d.y] = TILE.LDOOR_C;
      lockedSet.add(keyXY(d.x,d.y));
    }

    const q = Array.from(lockedSet).map(parseKey);
    const seen = new Set(lockedSet);

    while(q.length){
      const cur = q.pop();
      for(let dx=-1; dx<=1; dx++){
        for(let dy=-1; dy<=1; dy++){
          if(dx===0 && dy===0) continue;
          const nx = cur.x + dx, ny = cur.y + dy;
          if(nx<1||ny<1||nx>=MAP_W-1||ny>=MAP_H-1) continue;
          const t = tiles[nx][ny];
          if(!isDoorTile(t)) continue;
          const nk = keyXY(nx,ny);
          if(seen.has(nk)) continue;

          tiles[nx][ny] = TILE.LDOOR_C;
          lockedSet.add(nk);
          seen.add(nk);
          q.push({x:nx,y:ny});
        }
      }
    }

    return Array.from(lockedSet).map(parseKey);
  }

  // ---------- Key chests placement ----------
  function findRoomContaining(lvl, pos){
    const tiles = lvl.tiles;
    const {x:cx,y:cy} = pos;
    if(tiles[cx][cy] !== TILE.FLOOR) return null;
    let x1=cx, x2=cx, y1=cy, y2=cy;
    while(x1>1 && tiles[x1-1][cy]===TILE.FLOOR) x1--;
    while(x2<MAP_W-2 && tiles[x2+1][cy]===TILE.FLOOR) x2++;
    while(y1>1 && tiles[cx][y1-1]===TILE.FLOOR) y1--;
    while(y2<MAP_H-2 && tiles[cx][y2+1]===TILE.FLOOR) y2++;
    return { x:x1, y:y1, w:(x2-x1+1), h:(y2-y1+1) };
  }

  function placeKeyChests(lvl, depth){
    const tiles = lvl.tiles;
    const neededKeys = lvl.lockedDoors.length;
    if(neededKeys <= 0) return;

    const keyChestCount =
      neededKeys <= 2 ? 1 :
      neededKeys <= 5 ? 2 : 3;

    let remaining = neededKeys;
    const keyCounts = [];
    for(let i=0;i<keyChestCount;i++){
      if(i === keyChestCount - 1){
        keyCounts.push(remaining);
      } else {
        const give = Math.max(1, Math.floor(remaining / (keyChestCount - i)));
        const jitter = Math.random() < 0.4 ? 0 : 1;
        const amt = Math.min(remaining - (keyChestCount - i - 1), give + jitter);
        keyCounts.push(amt);
        remaining -= amt;
      }
    }

    const startRoom = findRoomContaining(lvl, lvl.startPos);
    const isNormal = (x,y) => !lvl.secret[x][y];

    function canPlaceChestAt(x,y){
      const t = tiles[x][y];
      if(!(t===TILE.FLOOR || t===TILE.CORR)) return false;
      if(t === TILE.DOWN || t === TILE.SDOWN) return false;
      if(t === TILE.DOOR_C || t === TILE.DOOR_O || t === TILE.LDOOR_C) return false;
      if(!isNormal(x,y)) return false;

      if(startRoom && x>=startRoom.x && x<startRoom.x+startRoom.w && y>=startRoom.y && y<startRoom.y+startRoom.h){
        return false;
      }

      const k = keyXY(x,y);
      if(lvl.items.has(k) || lvl.traps.has(k) || lvl.monsters.has(k) || lvl.traders.has(k)) return false;
      return true;
    }

    for(const kc of keyCounts){
      let placed = false;

      for(let tries=0; tries<20000 && !placed; tries++){
        const x = randInt(2, MAP_W-3);
        const y = randInt(2, MAP_H-3);
        if(!canPlaceChestAt(x,y)) continue;

        const baseGold = randInt(6,16) + depth*2;
        const cgold = chance(0.28) ? randInt(1, Math.max(1, Math.floor(baseGold*0.6))) : 0;
        lvl.items.set(keyXY(x,y), { type: ENT.CHEST, gold: baseGold - cgold, cgold, keys: kc });
        placed = true;
      }

      if(!placed){
        for(let tries=0; tries<20000 && !placed; tries++){
          const x = randInt(2, MAP_W-3);
          const y = randInt(2, MAP_H-3);
          if(!isNormal(x,y)) continue;
          const t = tiles[x][y];
          if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
          const k = keyXY(x,y);

// Corpse tint: inherit the stored monster color so remains match the fallen creature.
if(t === TILE.CORPSE && lvl.corpses && lvl.corpses.has(k)){
  const meta = lvl.corpses.get(k);
  if(meta && meta.color) color = meta.color;
}
          if(lvl.items.has(k) || lvl.traps.has(k) || lvl.monsters.has(k) || lvl.traders.has(k)) continue;
          const baseGold = randInt(6,16) + depth*2;
          const cgold = chance(0.28) ? randInt(1, Math.max(1, Math.floor(baseGold*0.6))) : 0;
          lvl.items.set(k, { type: ENT.CHEST, gold: baseGold - cgold, cgold, keys: kc });
          placed = true;
        }
      }
    }

    // Optional: allow exactly one loose key sometimes in the start room (tutorial feel)
    // Comment out this entire block to enforce chest-only keys.
    if(startRoom && Math.random() < 0.20){
      for(let tries=0; tries<4000; tries++){
        const x = randInt(startRoom.x+1, startRoom.x+startRoom.w-2);
        const y = randInt(startRoom.y+1, startRoom.y+startRoom.h-2);
        const t = tiles[x][y];
        if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
        const k = keyXY(x,y);
        if(lvl.items.has(k) || lvl.traps.has(k) || lvl.monsters.has(k) || lvl.traders.has(k)) continue;
        lvl.items.set(k, { type: "__LOOSE_KEY__" }); // internal marker, rendered as k-less; picked up as 1 key
        break;
      }
    }
  }

  // ---------- Potion selection ----------
  function rollPotionType(depth){
    const d = Math.min(20, Math.max(1, depth));
    const k = d - 1; // 0..19

    // Base weights match the debug mix (36/16/16/14/13/5), then shift gently with depth
    const wHeal   = Math.max(18, 36 - Math.floor(k * 0.6));
    const wPoison = 16 + Math.floor(k * 0.05);
    const wInvis  = 16 + Math.floor(k * 0.05);
    const wTrans  = 14 + Math.floor(k * 0.20);
    const wInvinc = 13 + Math.floor(k * 0.20);
    const wTele   =  5 + Math.floor(k * 0.15);

    const items   = [POTION.HEAL, POTION.POISON, POTION.INVIS, POTION.TRANSMUTE, POTION.INVINC, POTION.TELE];
    const weights = [wHeal,       wPoison,       wInvis,       wTrans,          wInvinc,        wTele];

    return weightedChoice(items, weights);
  }

  
  // ---------- ENVIRONMENT (Step 3: room-only placement; render-only overlays) ----------
  const ENV_ROOM_CHANCE = 1.0; // chance a given eligible room becomes an env room (when a level theme is active) // per room
  const ENV_MAX_FRACTION = 0.42;
  const ENV_MIN_DEPTH = 2; // no environments on level 1
    const ENV_LEVEL_CHANCE = 0.60; // chance a level gets an environmental theme at all
    const ENV_ROOMS_MIN = 1;
    const ENV_ROOMS_MAX = 3; // fewer, more cohesive rooms per level
    const ENV_THEMES = [
      { name: 'water+slime', types: ['water','slime'], weights: [0.65, 0.35] },
      { name: 'fire+mist',  types: ['fire','mist'],   weights: [0.60, 0.40] }
    ];
  

  const ENV_GLYPH = {
    water: '‚âà',
    slime: '~',
    fire:  'x',
    mist:  '‚ñë',
    // Intercessor Stage overlays (visual-only)
    ritual: '¬∑',
    intercessor: '‚ï¨',
    supplicant: '^'
  };
  const ENV_COLOR = {
    water: '#57c7ff',
    slime: '#6fcf6a',
    fire:  '#ff7043',
    mist:  '#b6c0c8',
    // Intercessor Stage overlays (visual-only)
    ritual: '#93a4ad',
    intercessor: '#cfd8dc',
    supplicant: '#b0bec5'
  };

  function placeLevelEnvironments(lvl, rooms, depth, startPos){
  // Environments are purely visual overlays (passable). Keep them cohesive per level.

  // DEBUG: force environments in every room starting at level 1 for testing.
  // Cycles room-by-room through the available environment types so each room is different.
  if(DEBUG){
    if(!rooms || rooms.length === 0) return;
    const debugTypes = ['water','slime','fire','mist'];
    lvl.envTheme = 'debug';
    for(let i=0;i<rooms.length;i++){
      const r = rooms[i];
      if(!r) continue;
      const area = r.w * r.h;
      const cap = Math.floor(area * ENV_MAX_FRACTION);
      if(cap <= 0) continue;
      //const target = Math.min(cap, Math.max(4, Math.floor(cap * 0.75))); // fairly full but always under cap
      const target = Math.min(cap, Math.max(2, Math.floor(cap * 0.0))); // 0.15 is light sprinkle
      const envType = debugTypes[i % debugTypes.length];

      // Seed position inside room interior
      let sx = randInt(r.x + 1, r.x + r.w - 2);
      let sy = randInt(r.y + 1, r.y + r.h - 2);

      const q = [[sx, sy]];
      const seen = new Set();
      let placed = 0;

      while(q.length && placed < target){
        const [x,y] = q.shift();
        const k = keyXY(x,y);
        if(seen.has(k)) continue;
        seen.add(k);

        if(x < r.x || x >= r.x + r.w || y < r.y || y >= r.y + r.h) continue;
        if(lvl.tiles[x][y] !== TILE.FLOOR) continue;
        if(lvl.env[x][y]) continue;

        lvl.env[x][y] = envType;
        placed++;

        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        shuffleInPlace(dirs);
        for(const [dx,dy] of dirs){
          const nx = x + dx, ny = y + dy;
          if(nx < r.x || nx >= r.x + r.w || ny < r.y || ny >= r.y + r.h) continue;
          const nk = keyXY(nx,ny);
          if(seen.has(nk)) continue;
          if(Math.random() < 0.85) q.push([nx,ny]);
        }
      }
    }
    return;
  }
  if(!rooms || rooms.length === 0) return;
  if(depth < ENV_MIN_DEPTH) return;
  if(Math.random() > ENV_LEVEL_CHANCE) return;

  const theme = choice(ENV_THEMES);
  lvl.envTheme = theme.name;

  const startRoom = findRoomContaining(lvl, startPos);

  // Eligible rooms: exclude the start room so the opening stays readable.
  const eligible = rooms.filter(r => {
    if(!r) return false;
    if(startRoom && r === startRoom) return false;
    // Also skip tiny rooms to avoid visual clutter.
    return (r.w * r.h) >= 30;
  });

  if(eligible.length === 0) return;

  // Pick a small number of rooms for cohesive patches.
  shuffleInPlace(eligible);
  const maxRooms = Math.min(ENV_ROOMS_MAX, eligible.length);
  const minRooms = Math.min(ENV_ROOMS_MIN, maxRooms);
  const roomCount = randInt(minRooms, maxRooms);
  const chosenRooms = eligible.slice(0, roomCount);

  for(const r of chosenRooms){
    if(Math.random() > ENV_ROOM_CHANCE) continue;

    const area = r.w * r.h;
    const cap = Math.floor(area * ENV_MAX_FRACTION);
    if(cap <= 0) continue;

    // Target fill: less random, more cohesive (closer to cap but still under it)
    const target = randInt(Math.max(4, Math.floor(cap * 0.45)), cap);

    const envType = weightedChoice(theme.types, theme.weights);

    // Seed position inside room interior
    let sx = randInt(r.x + 1, r.x + r.w - 2);
    let sy = randInt(r.y + 1, r.y + r.h - 2);

    // Grow a patch by BFS
    const q = [[sx, sy]];
    const seen = new Set();
    let placed = 0;

    while(q.length && placed < target){
      const [x,y] = q.shift();
      const k = keyXY(x,y);
      if(seen.has(k)) continue;
      seen.add(k);

      // Only overlay on floor inside this room
      if(x < r.x || x >= r.x + r.w || y < r.y || y >= r.y + r.h) continue;
      if(lvl.tiles[x][y] !== TILE.FLOOR) continue;

      // Don't overwrite existing environment
      if(lvl.env[x][y]) continue;

      lvl.env[x][y] = envType;
      placed++;

      // Push neighbors with slight bias (keeps it blobby)
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      shuffleInPlace(dirs);
      for(const [dx,dy] of dirs){
        const nx = x + dx, ny = y + dy;
        if(nx < r.x || nx >= r.x + r.w || ny < r.y || ny >= r.y + r.h) continue;
        const nk = keyXY(nx,ny);
        if(seen.has(nk)) continue;
        if(Math.random() < 0.85) q.push([nx,ny]);
      }
    }
  }
}


// ---------- INTERCESSOR STAGE (visual-only v0, ENV overlays; tiles remain normal) ----------
function placeIntercessorStageEnv(lvl, room){
  if(!lvl || !room || !lvl.env) return false;

  const tiles = lvl.tiles;
  const env = lvl.env;

  // Bias toward "far" side of the room so it feels like an end-of-level discovery.
  const baseX = room.cx;
  const baseY = Math.min(room.y + room.h - 3, room.cy + 1);

  function inRoomInner(x,y){
    return (x >= room.x + 1 && x <= room.x + room.w - 2 && y >= room.y + 1 && y <= room.y + room.h - 2);
  }
  function canWrite(x,y){
    if(!inRoomInner(x,y)) return false;
    const t = tiles[x][y];
    // Only overlay on normal passable terrain; never touch doors/stairs/etc.
    if(!(t === TILE.FLOOR || t === TILE.CORR)) return false;
    // Don't overwrite existing overlays
    if(env[x][y]) return false;
    // Don't overwrite items/traps/monsters/trader footprints
    const k = keyXY(x,y);
    if(lvl.items && lvl.items.has(k)) return false;
    if(lvl.traps && lvl.traps.has(k)) return false;
    if(lvl.monsters && lvl.monsters.has(k)) return false;
    if(lvl.traders && lvl.traders.has(k)) return false;
    return true;
  }
  function setEnv(x,y,type){
    if(!canWrite(x,y)) return;
    env[x][y] = type;
  }

  const x0 = baseX, y0 = baseY;

  // Pattern (centered around x0/y0), using ENV overlays only:
  //   row -2:      ¬∑¬∑¬∑¬∑¬∑¬∑¬∑
  //   row -1:   ¬∑¬∑¬∑   ‚ï¨   ¬∑¬∑¬∑
  //   row  0:  ¬∑¬∑  ^^^^  ¬∑¬∑
  //   row +1:   ¬∑¬∑¬∑       ¬∑¬∑¬∑

  // row -2 ritual bar
  for(let dx=-3; dx<=3; dx++) setEnv(x0+dx, y0-2, 'ritual');

  // row -1 wings + intercessor
  for(let dx=-3; dx<=-1; dx++) setEnv(x0+dx, y0-1, 'ritual');
  setEnv(x0, y0-1, 'intercessor');
  for(let dx=1; dx<=3; dx++) setEnv(x0+dx, y0-1, 'ritual');

  // row 0 supplicants (^^^^) with a couple ritual pavers flanking the crowd
  setEnv(x0-2, y0, 'ritual');
  setEnv(x0+3, y0, 'ritual');
  for(let dx=-1; dx<=2; dx++) setEnv(x0+dx, y0, 'supplicant');

  // row +1 wings
  for(let dx=-3; dx<=-1; dx++) setEnv(x0+dx, y0+1, 'ritual');
  for(let dx=1; dx<=3; dx++) setEnv(x0+dx, y0+1, 'ritual');


// Record stage metadata for triggers/awakening (does not affect tiles/pathing).
lvl.intercessorStage = {
  room: { x: room.x, y: room.y, w: room.w, h: room.h, cx: room.cx, cy: room.cy },
  ix: x0,
  iy: y0-1,
  supplicants: [
    {x: x0-1, y: y0},
    {x: x0,   y: y0},
    {x: x0+1, y: y0},
    {x: x0+2, y: y0}
  ],
  awakened: false,
  loreFired: false,
  packId: 0
};
  // Ensure the intercessor is always placed; if it failed due to conflicts, report false.
  return (env[x0][y0-1] === 'intercessor');
}


/**
 * Intercessor Stage v1 (active):
 * - Lore fires once when entering ritual field.
 * - Encounter awakens only if player steps onto the Intercessor ('‚ï¨') or a Supplicant ('^') overlay.
 * - On awakening, spawn monsters (Intercessor + Supplicants) that defend the Intercessor using pack cohesion.
 */
let INTERCESSOR_PACK_ID = 5000;

function intercessorStageCheckOnPlayerStep(lvl, prevX, prevY, px, py){
  const st = lvl && lvl.intercessorStage;
  if(!st) return;

  const e = envAt(lvl, px, py);
  const wasE = envAt(lvl, prevX, prevY);

  const inFieldNow = (e === 'ritual' || e === 'intercessor' || e === 'supplicant');
  const inFieldPrev = (wasE === 'ritual' || wasE === 'intercessor' || wasE === 'supplicant');
  // Music: ritual chamber ambience while inside the ritual ROOM (not just the tiles).
  // This should start as soon as the player enters the chamber, even if they never step onto the ritual pavers.
  const r = st.room;
  const inRoomNow  = !!(r && px >= r.x && px < (r.x + r.w) && py >= r.y && py < (r.y + r.h));
  const inRoomPrev = !!(r && prevX >= r.x && prevX < (r.x + r.w) && prevY >= r.y && prevY < (r.y + r.h));

  if(inRoomNow && !inRoomPrev){
    onEnterRitualChamber();
  }
  if(!inRoomNow && inRoomPrev){
    onExitRitualChamber();
  }

  // Lore: first time entering the field (any of the overlays)
  if(inFieldNow && !inFieldPrev && !st.loreFired){
    st.loreFired = true;
    fireLoreOnce('lore_intercessor', 'The air tightens. A rite unfolds ‚Äî unbroken.');
  }

  // Engagement: only if stepping onto the Intercessor or a Supplicant position
  if(!st.awakened && (e === 'intercessor' || e === 'supplicant')){
    awakenIntercessorStage(lvl);
  }
}

function awakenIntercessorStage(lvl){
  const st = lvl && lvl.intercessorStage;
  if(!st || st.awakened) return;
  st.awakened = true;


  // Lore: the rite is disturbed (fires once per run)
  fireLoreOnce('lore_intercessor_disturb', 'You have no idea what you‚Äôve done.');
  // Reserve a unique pack id for the supplicants so they herd together.
  st.packId = INTERCESSOR_PACK_ID++;

  const ix = st.ix, iy = st.iy;

  // Spawn the Intercessor as a stationary monster (presence that can still strike if adjacent).
  // NOTE: We do NOT change tiles; we only add monsters.
  const ik = keyXY(ix, iy);
  if(!lvl.monsters.has(ik)){
    const depth = game.depth || 1;
    lvl.monsters.set(ik, {
      glyph: '‚ï¨',
      name: "Fell Intercessor",
      hp: randInt(14, 18) + Math.floor(depth/3),
      atk: randInt(3, 5) + Math.floor(depth/10),
      immobile: true,
      isIntercessor: true
    });
  }

  // Spawn supplicants (horde) that defend the Intercessor.
  // Leader is the one closest to the Intercessor (first entry) for stability.
  const depth = game.depth || 1;
  let leaderPlaced = false;

  for(const s of st.supplicants){
    const k = keyXY(s.x, s.y);
    if(lvl.monsters.has(k)) continue;

    const m = {
      glyph: '^',
      name: "Supplicant",
      hp: randInt(6, 10) + Math.floor(depth/4),
      atk: randInt(2, 4) + Math.floor(depth/10),
      packId: st.packId,
      packLeader: !leaderPlaced,
      guardIntercessor: true,
      guardX: ix,
      guardY: iy
    };
    leaderPlaced = true;
    lvl.monsters.set(k, m);
  }

  // Optional: subtle immediate feedback without freezing flow.
  logMsg("A hush falls. The faithful rise.");
}

// ---------- AMBUSH STAGE (latent room encounter; empty until player commits to center) ----------
// Uses normal monster map only. No env overlays. No tile edits.
// Boss glyph: Œ¶ (U+03A6), minion glyph: ‚äó (U+2297)

function __ambush_inRoom(r, x, y){
  return !!(r && x >= r.x && x < (r.x + r.w) && y >= r.y && y < (r.y + r.h));
}
function __ambush_inRoomInner(r, x, y){
  return !!(r && x >= r.x + 1 && x <= (r.x + r.w - 2) && y >= r.y + 1 && y <= (r.y + r.h - 2));
}
function __ambush_inCenter3x3(r, x, y){
  if(!r) return false;
  const cx = r.cx, cy = r.cy;
  return (x >= cx-1 && x <= cx+1 && y >= cy-1 && y <= cy+1);
}

// AMBUSHES
function placeAmbushStage(lvl, rooms, depth, startPos, downPos){
  if(!lvl || !rooms || rooms.length < 2) return;

  // Guaranteed debug hook: if window.DEBUG is true, ALWAYS arm an ambush on Level 1.
  const debugOn =
    (typeof window !== 'undefined' && window.DEBUG === true) ||
    (typeof DEBUG  !== 'undefined' && DEBUG === true);

  const want = (debugOn && depth === 1) ? 1 : (chance(0.18) ? 1 : 0);
  if(!want) return;

  const inRoom = (r, p) => (p && typeof p.x==='number' && typeof p.y==='number') ? __ambush_inRoom(r, p.x, p.y) : false;

  const MIN_PASSABLE = (debugOn && depth === 1) ? 15 : 20; // aggressive; tune later

  const candidates = rooms.filter(r=>{
    if(inRoom(r, startPos) || inRoom(r, downPos)) return false;
    if(roomPassableInteriorCount(lvl, r) < MIN_PASSABLE) return false;
    return true;
  });

  if(!candidates.length) {
    if(debugOn && depth === 1) console.warn('DEBUG AMBUSH: no valid rooms');
    return;
  }
  if(debugOn) console.log(`AMBUSH candidates depth ${depth}: ${candidates.length}`);

  // Deterministic in debug: pick the first candidate so it is reproducible.
  const room = (debugOn && depth === 1) ? candidates[0] : candidates[randInt(0, candidates.length-1)];
  lvl.ambushStage = {
    room: { x: room.x, y: room.y, w: room.w, h: room.h, cx: room.cx, cy: room.cy },
    triggered: false,
    resolved: false,
    loreFired: false
  };

  if(debugOn && depth === 1){
    logMsg(`DEBUG: Ambush armed (L1) @ (${room.cx},${room.cy}) size ${room.w}x${room.h}`);
    console.log(`DEBUG AMBUSH ARMED L1 @ (${room.cx},${room.cy}) size ${room.w}x${room.h}`);
  } else if(debugOn){
    logMsg('DEBUG: Ambush armed.');
  }
}

function ambushStageCheckOnPlayerStep(lvl, prevX, prevY, px, py){
  const st = lvl && lvl.ambushStage;
  if(!st || st.triggered || st.resolved) return;

  const r = st.room;
  if(!r) return;
  const inNow  = __ambush_inRoom(r, px, py);
  const inPrev = __ambush_inRoom(r, prevX, prevY);
  if(!inNow) return;

  // Optional: one-time entry beat
  if(inNow && !inPrev && !st.loreFired){
    st.loreFired = true;
    fireLoreOnce(`lore_ambush_${game.depth}`, "The room feels too empty.");
  }

  const cNow  = __ambush_inCenter3x3(r, px, py);
  const cPrev = __ambush_inCenter3x3(r, prevX, prevY);
   if(cNow && !cPrev){
        // Ambush declaration (fires exactly once because st.triggered prevents re-entry)
        logMsg("The room sits in judgment.");
        st.trigX = px;
        st.trigY = py;
        awakenAmbushStage(lvl);
   }

}

function __ambush_findOpenInRoom(lvl, r, x0, y0){
  for(let rad=0; rad<=7; rad++){
    for(let dy=-rad; dy<=rad; dy++){
      for(let dx=-rad; dx<=rad; dx++){
        const x = x0 + dx, y = y0 + dy;
        if(!__ambush_inRoomInner(r, x, y)) continue;
        if(!tilePassable(lvl, x, y)) continue;
        const k = keyXY(x,y);
        if(lvl.monsters && lvl.monsters.has(k)) continue;
        if(lvl.items && lvl.items.has(k)) continue;
        if(lvl.traps && lvl.traps.has(k)) continue;
        if(lvl.traders && lvl.traders.has(k)) continue;
        return {x,y};
      }
    }
  }
  return null;
}

function __ambush_guardTiles(lvl, r){
  const guards = [];
  if(!lvl || !lvl.doorCoords) return guards;

  for(const d of lvl.doorCoords){
    const dx = d.x, dy = d.y;
    if(!__ambush_inRoom(r, dx, dy)) continue;
    const sx = clamp(r.cx - dx, -1, 1);
    const sy = clamp(r.cy - dy, -1, 1);
    const gx = dx + sx, gy = dy + sy;
    if(!__ambush_inRoomInner(r, gx, gy)) continue;
    if(!tilePassable(lvl, gx, gy)) continue;
    guards.push({x:gx, y:gy});
  }
  return guards;
}

function awakenAmbushStage(lvl){
  const st = lvl && lvl.ambushStage;
  if(!st || st.triggered || st.resolved) return;
  st.triggered = true;

  const r = st.room;

  // Step 1: minimum spawn distance from player at trigger moment
  const TRIG_X = (typeof st.trigX === 'number') ? st.trigX : (lvl.player ? lvl.player.x : r.cx);
  const TRIG_Y = (typeof st.trigY === 'number') ? st.trigY : (lvl.player ? lvl.player.y : r.cy);
  const MIN_SPAWN_CHEB = 3; // distance < 3 is too close (Chebyshev)

    function tooCloseToTrigger(x, y){
        return Math.max(Math.abs(x - TRIG_X), Math.abs(y - TRIG_Y)) < MIN_SPAWN_CHEB;
    }

  if(!r) return;

  logMsg("The crowd seethes at your intrusion.");

  const depth = game.depth || 1;

  // Boss Œ¶: big HP, immobile
  const bossPos = __ambush_findOpenInRoom(lvl, r, r.cx, r.cy) || {x:r.cx, y:r.cy};
  const bk = keyXY(bossPos.x, bossPos.y);
  if(!lvl.monsters.has(bk)){
    lvl.monsters.set(bk, {
      glyph: '\u03A6',
      name: "The Arbiter",
      hp: randInt(34, 44) + Math.floor(depth*3),
      atk: randInt(2, 4) + Math.floor(depth/10),
      immobile: true,
      isAmbushBoss: true
    });
  }

  // Minions ‚äó: 5‚Äì7, mix of wardens + compressors
  const count = randInt(5, 7);
  const guards = __ambush_guardTiles(lvl, r);
  let gi = 0;

  const cornerSeeds = [
    {x:r.x+1,       y:r.y+1},
    {x:r.x+r.w-2,   y:r.y+1},
    {x:r.x+1,       y:r.y+r.h-2},
    {x:r.x+r.w-2,   y:r.y+r.h-2},
    {x:r.cx,        y:r.y+1},
    {x:r.cx,        y:r.y+r.h-2},
    {x:r.x+1,       y:r.cy},
    {x:r.x+r.w-2,   y:r.cy}
  ];

  let placed = 0;
  for(let i=0; i<cornerSeeds.length && placed<count; i++){
    const seed = cornerSeeds[i];
    const pos = __ambush_findOpenInRoom(lvl, r, seed.x, seed.y);
    if(!pos) continue;
    if(tooCloseToTrigger(pos.x, pos.y)) continue;
    const k = keyXY(pos.x, pos.y);
    if(lvl.monsters.has(k)) continue;

    const role = (placed < Math.ceil(count*0.6)) ? 'warden' : 'compressor';
    const g = (role === 'warden' && guards.length) ? guards[gi++ % guards.length] : null;

    lvl.monsters.set(k, {
      glyph: '\u2297',
      name: "Guardsman",
      hp: randInt(7, 12) + Math.floor(depth/4),
      atk: randInt(1, 3) + Math.floor(depth/12),
      isAmbushMinion: true,
      ambushRole: role,
      guardX: g ? g.x : undefined,
      guardY: g ? g.y : undefined,
      ambushRoom: r
    });
    placed++;
  }

  for(let tries=0; placed<count && tries<140; tries++){
    const x = randInt(r.x+1, r.x+r.w-2);
    const y = randInt(r.y+1, r.y+r.h-2);
    const pos = __ambush_findOpenInRoom(lvl, r, x, y);
    if(!pos) continue;
    if(tooCloseToTrigger(pos.x, pos.y)) continue;
    const k = keyXY(pos.x, pos.y);
    if(lvl.monsters.has(k)) continue;

    const role = (placed < Math.ceil(count*0.6)) ? 'warden' : 'compressor';
    const g = (role === 'warden' && guards.length) ? guards[gi++ % guards.length] : null;

    lvl.monsters.set(k, {
      glyph: '\u2297',
      name: "Bound Agent",
      hp: randInt(7, 12) + Math.floor(depth/4),
      atk: randInt(1, 3) + Math.floor(depth/12),
      isAmbushMinion: true,
      ambushRole: role,
      guardX: g ? g.x : undefined,
      guardY: g ? g.y : undefined,
      ambushRoom: r
    });
    placed++;
  }
}




  // ===== BAD FURNITURE STAMPS (Architectural remnants; blocking; lore-only) =====
  // Furniture lives in lvl.furnG (glyph) and lvl.furnT (type string).
  // It is placed in 1‚Äì2 rooms every 2‚Äì3 levels, and never in start/end rooms.
  const BAD_FURN = {
    throne: {
      type: 'throne',
      anchors: ['wall'],
      variants: [
        { w:2, h:3, rows: ["‚îå ", "‚ïë‚ñà", "‚îî "] },       // minimal workbench throne
        { w:3, h:3, rows: ["‚ïî‚ïê‚ï¶", "‚ïë‚ñà‚ï¨", "‚ïö‚ïê‚ï©"] }     // ceremonial throne
      ]
    },
    library: {
      type: 'library',
      anchors: ['wall'],
      // Modular shelving: 1‚Äì3 bays. We build the stamp on demand.
      build: function(bays){
        bays = Math.max(1, Math.min(3, bays|0));
        if(bays === 1){
          return { w:5, h:3, rows: ["‚ïî‚ïê‚ïê‚ïê‚ïó", "‚ïë‚ñà ‚ñà‚ïë", "‚ïö‚ïê‚ïê‚ïê‚ïù"] };
        }
        // Multi-bay: corners + junctions
        const top = "‚ïî" + ("‚ïê‚ïê‚ïê‚ï¶".repeat(bays-1)) + "‚ïê‚ïê‚ïê‚ïó";
        const mid = "‚ïë" + ("‚ñà ‚ñà ".repeat(bays)).slice(0, bays*4-1) + "‚ïë";
        const bot = "‚ïö" + ("‚ïê‚ïê‚ïê‚ï©".repeat(bays-1)) + "‚ïê‚ïê‚ïê‚ïù";
        // Ensure mid length matches top/bot inner span (bays*4-1), pad if needed
        let midFixed = mid;
        const need = top.length;
        if(midFixed.length < need) midFixed = midFixed.slice(0,1) + (midFixed.slice(1,-1)).padEnd(need-2, " ") + midFixed.slice(-1);
        if(midFixed.length > need) midFixed = midFixed.slice(0, need-1) + "‚ïë";
        return { w:top.length, h:3, rows: [top, midFixed, bot] };
      }
    },
    dais: {
      type: 'dais',
      anchors: ['center'],
      variants: [
        { w:5, h:3, rows: ["‚ï¶‚ñà‚ñà‚ï¶", "‚ïë‚ñà‚ñà‚ïë", "‚ï©‚ñà‚ñà‚ï©"] },
        { w:3, h:3, rows: ["‚ïî‚ï¶‚ïó", "‚ïë‚ï¨‚ïë", "‚ïö‚ï©‚ïù"] }
      ]
    },
    void: {
      type: 'void',
      anchors: ['center'],
      variants: [
        { w:2, h:2, rows: ["‚îå‚îê", "‚îî‚îò"] },
        { w:2, h:2, rows: ["‚ïî‚ïó", "‚ïö‚ïù"] }
      ]
    }
  };

  function _badFurnStampCells(stamp){
    // Returns list of [dx,dy,ch] for non-space chars
    const cells = [];
    for(let dy=0; dy<stamp.h; dy++){
      const row = stamp.rows[dy] || "";
      for(let dx=0; dx<stamp.w; dx++){
        const ch = row[dx] || " ";
        if(ch !== " "){
          cells.push([dx,dy,ch]);
        }
      }
    }
    return cells;
  }

  function _badRoomContainsPoint(r, p){
    return p && p.x >= r.x && p.x < r.x+r.w && p.y >= r.y && p.y < r.y+r.h;
  }

  function _badFindRoomContaining(rooms, pos){
    if(!rooms || !pos) return null;
    for(const r of rooms){
      if(!r) continue;
      if(_badRoomContainsPoint(r, pos)) return r;
    }
    return null;
  }

  function _badCanPlaceStamp(lvl, stamp, ox, oy){
    const tiles = lvl.tiles;
    const furnG = lvl.furnG;
    const cells = _badFurnStampCells(stamp);
    for(const [dx,dy,ch] of cells){
      const x = ox+dx, y = oy+dy;
      if(x<1||y<1||x>=MAP_W-1||y>=MAP_H-1) return false;
      // Only stamp on empty floor/corridor (never overwrite doors/rock/stairs)
      const t = tiles[x][y];
      if(!(t===TILE.FLOOR || t===TILE.CORR)) return false;
      if(furnG[x][y]) return false;
      // Never overwrite items/traps/traders/monsters
      const k = keyXY(x,y);
      if(lvl.items && lvl.items.has(k)) return false;
      if(lvl.traps && lvl.traps.has(k)) return false;
      if(lvl.traders && lvl.traders.has(k)) return false;
      if(lvl.monsters && lvl.monsters.has(k)) return false;
    }
    return true;
  }

  function _badStampFurniture(lvl, stamp, type, ox, oy){
    const furnG = lvl.furnG, furnT = lvl.furnT;
    const cells = _badFurnStampCells(stamp);
    for(const [dx,dy,ch] of cells){
      const x = ox+dx, y = oy+dy;
      furnG[x][y] = ch;
      furnT[x][y] = type;
    }
  }

  function _badPickWallAnchorRoomPos(r, stamp){
    // Place flush against a random wall inside room, with 1-tile interior buffer.
    // Returns {x,y} origin for stamp.
    const walls = ['N','S','W','E'];
    shuffleInPlace(walls);
    for(const w of walls){
      let ox, oy;
      if(w === 'N'){
        oy = r.y + 1;
        ox = randInt(r.x + 1, (r.x + r.w - 1) - stamp.w);
      } else if(w === 'S'){
        oy = (r.y + r.h - 1) - stamp.h;
        ox = randInt(r.x + 1, (r.x + r.w - 1) - stamp.w);
      } else if(w === 'W'){
        ox = r.x + 1;
        oy = randInt(r.y + 1, (r.y + r.h - 1) - stamp.h);
      } else { // E
        ox = (r.x + r.w - 1) - stamp.w;
        oy = randInt(r.y + 1, (r.y + r.h - 1) - stamp.h);
      }
      if(ox != null && oy != null) return {x:ox, y:oy};
    }
    return null;
  }

  function _badPickCenterRoomPos(r, stamp){
    // Centered or slight offset, always leaving a 1-tile ring when possible
    const minX = r.x + 2;
    const maxX = (r.x + r.w - 2) - stamp.w;
    const minY = r.y + 2;
    const maxY = (r.y + r.h - 2) - stamp.h;
    if(maxX < minX || maxY < minY) return null;
    const ox = randInt(minX, maxX);
    const oy = randInt(minY, maxY);
    return {x:ox, y:oy};
  }

  function placeBADFurniture(lvl, rooms, depth, startPos, downPos){
    if(!rooms || rooms.length === 0) return;
    // Frequency: 1‚Äì2 furniture rooms every 2‚Äì3 levels (low touch)
    if(depth < 1) return;
    const chance = (depth % 3 === 0) ? 0.85 : (depth % 3 === 2) ? 0.60 : 0.20;
    if(Math.random() > chance) return;

    const startRoom = _badFindRoomContaining(rooms, startPos);
    const endRoom   = _badFindRoomContaining(rooms, downPos);

    const eligible = rooms.filter(r => {
      if(!r) return false;
      if(startRoom && r === startRoom) return false;
      if(endRoom && r === endRoom) return false;
      // Avoid tiny rooms
      return (r.w >= 7 && r.h >= 7);
    });
    if(eligible.length === 0) return;

    shuffleInPlace(eligible);
    const maxFeatures = (depth % 3 === 0) ? 2 : 1;
    const featureCount = Math.min(maxFeatures, eligible.length);

    // Pick types (weighted toward throne+library; dais/void rarer)
    const types = ['throne','library','throne','library','dais','void'];

    let placed = 0;
    for(let i=0; i<eligible.length && placed<featureCount; i++){
      const r = eligible[i];

      const kind = choice(types);
      let stamp = null;
      let anchor = 'wall';

      if(kind === 'library'){
        stamp = BAD_FURN.library.build(randInt(1,3));
        anchor = 'wall';
      } else {
        const def = BAD_FURN[kind];
        stamp = choice(def.variants);
        anchor = def.anchors[0];
      }

// ===== BAD STATUES (Œ© Witness galleries; inert stone; lore-only) =====
function placeBADStatues(lvl, rooms, depth, startPos, downPos){
  if(!lvl || !rooms || rooms.length===0) return;

  // Forced placement on level 1 for testing
  const force = (depth === 1);

  // Sparse otherwise: roughly every 4‚Äì6 levels
  if(!force){
    if(depth < 2) return;
    if(rand() > 0.22) return; // low probability
  }

  const startRoom = _badFindRoomContaining(rooms, startPos);
  const endRoom   = _badFindRoomContaining(rooms, downPos);

  // Eligible rooms: not start/end, decent size
  const eligible = rooms.filter(r=>{
    if(!r) return false;
    if(startRoom && r === startRoom) return false;
    if(endRoom && r === endRoom) return false;
    return (r.w >= 9 && r.h >= 7);
  });
  if(eligible.length===0){
    if(!force) return;
    // For forced test (depth 1), allow start/end rooms as a fallback so you always see Œ©.
    eligible.push(...rooms.filter(r=>r));
    if(eligible.length===0) return;
  }

  const r = choice(eligible);

  // Choose pattern based on room size
  const big = (r.w >= 13 && r.h >= 9);
  const mode = big ? choice(['wall','pairs']) : 'wall';

  const placeOmega = (x,y)=>{
    if(x<1 || y<1 || x>=MAP_W-1 || y>=MAP_H-1) return false;
    // do not overwrite existing furniture/env/doors/stairs/shrines/trader/items
    if(lvl.furnG && lvl.furnG[x][y]) return false;
    if(lvl.env && lvl.env[x][y]) return false;
    if(lvl.items && lvl.items.has(keyXY(x,y))) return false;
    const tt = lvl.tiles[x][y];
    if(!(tt===TILE.FLOOR || tt===TILE.CORR)) return false;
    // avoid doors / stairs / special tiles by glyph check via tile type
    lvl.furnG[x][y] = 'Œ©';
    lvl.furnT[x][y] = 'statue';
    // Statues are true stone: mark base tile as ROCK so later item placement can't land here.
    lvl.tiles[x][y] = TILE.ROCK;
    return true;
  };

  let placedAny = false;

  if(mode === 'wall'){
    // Choose one wall and place every other tile along interior edge
    const wall = choice(['N','S','W','E']);
    if(wall === 'N'){
      const y = r.y+1;
      for(let x=r.x+2; x<=r.x+r.w-3; x+=2) placedAny = placeOmega(x,y) || placedAny;
    }else if(wall === 'S'){
      const y = r.y+r.h-2;
      for(let x=r.x+2; x<=r.x+r.w-3; x+=2) placedAny = placeOmega(x,y) || placedAny;
    }else if(wall === 'W'){
      const x = r.x+1;
      for(let y=r.y+2; y<=r.y+r.h-3; y+=2) placedAny = placeOmega(x,y) || placedAny;
    }else{
      const x = r.x+r.w-2;
      for(let y=r.y+2; y<=r.y+r.h-3; y+=2) placedAny = placeOmega(x,y) || placedAny;
    }
  }else{
    // Symmetrical pairs down center of room (leave a central aisle)
    const cx = Math.floor(r.x + r.w/2);
    const xL = cx-2, xR = cx+2;
    for(let y=r.y+2; y<=r.y+r.h-3; y+=2){
      const a = placeOmega(xL,y);
      const b = placeOmega(xR,y);
      placedAny = (a||b) || placedAny;
    }
  }

  // If forced and nothing placed, fall back to one statue near wall
  if(force && !placedAny){
    const x = r.x+2; const y = r.y+1;
    placeOmega(x,y);
  }
}
// ===== END BAD STATUES =====

      // Select origin based on anchor type
      let origin = null;
      if(anchor === 'wall') origin = _badPickWallAnchorRoomPos(r, stamp);
      else origin = _badPickCenterRoomPos(r, stamp);
      if(!origin) continue;

      // Try a few jitters in the same room
      let ok = false;
      for(let attempt=0; attempt<12 && !ok; attempt++){
        let ox = origin.x, oy = origin.y;
        if(anchor === 'wall'){
          // Slide along wall a bit
          ox = clamp(ox + randInt(-2,2), r.x+1, (r.x+r.w-1)-stamp.w);
          oy = clamp(oy + randInt(-2,2), r.y+1, (r.y+r.h-1)-stamp.h);
        } else {
          ox = clamp(ox + randInt(-2,2), r.x+2, (r.x+r.w-2)-stamp.w);
          oy = clamp(oy + randInt(-2,2), r.y+2, (r.y+r.h-2)-stamp.h);
        }
        if(_badCanPlaceStamp(lvl, stamp, ox, oy)){
          _badStampFurniture(lvl, stamp, kind, ox, oy);
          ok = true;
          placed++;
        }
      }
    }
  }
  // ===== END BAD FURNITURE STAMPS =====




  // ===== BRIDGES (BAD): ]:::::[ as anchors + span; combat isolation via bridge layer =====
  function placeBridges(lvl, rooms, depth, startPos, downPos){
    if(!lvl || !rooms || rooms.length < 2) return;

    // Phase 1 placement: rare in normal play; force 1 in DEBUG for testing.
    const want = (window.DEBUG ? 1 : (chance(0.15) ? 1 : 0));
    if(!want) return;

    function inRoom(r, p){
      return p && p.x >= r.x && p.x < r.x+r.w && p.y >= r.y && p.y < r.y+r.h;
    }

    // Prefer medium+ rooms, but don't be too strict (room sizes vary).
    const candidates = rooms.filter(r=>{
      if(r.w < 8 || r.h < 5) return false;
      if(inRoom(r, startPos) || inRoom(r, downPos)) return false;
      return true;
    });
    if(!candidates.length) return;

    // Try candidates for a clean horizontal span inside the room.
    for(let tries=0; tries<60; tries++){
      const r = candidates[randInt(0, candidates.length-1)];
      const len = randInt(3,6);
      const y = r.y + randInt(1, r.h-2);
      const x0min = r.x + 2;
      const x0max = r.x + r.w - (len + 3);
      if(x0max < x0min) continue;
      const x0 = randInt(x0min, x0max);
      const xl = x0-1;
      const xr = x0+len;
      if(xl <= r.x || xr >= r.x + r.w - 1) continue;

      let ok = true;
      for(let x=xl; x<=xr; x++){
        const t = lvl.tiles[x][y];
        if(t !== TILE.FLOOR) { ok = false; break; }
        if((x===startPos.x && y===startPos.y) || (x===downPos.x && y===downPos.y)) { ok = false; break; }
      }
      if(!ok) continue;

      lvl.tiles[xl][y] = TILE.BRIDGE_L;
      for(let x=x0; x<x0+len; x++) lvl.tiles[x][y] = TILE.BRIDGE_SPAN;
      lvl.tiles[xr][y] = TILE.BRIDGE_R;
      return;
    }
  }
  // ===== END BRIDGES =====
function generateLevel(depth){
    const tiles = makeGrid(MAP_W, MAP_H, TILE.ROCK);
    const seen = makeGrid(MAP_W, MAP_H, false);
    const visible = makeGrid(MAP_W, MAP_H, false);
    const env = makeGrid(MAP_W, MAP_H, 0);
    const furnG = makeGrid(MAP_W, MAP_H, null);
    const furnT = makeGrid(MAP_W, MAP_H, 0);
    const secret = makeGrid(MAP_W, MAP_H, false);
    const secretDoors = new Map();

    const rooms = [];
    const roomTarget = randInt(ROOMS_MIN, ROOMS_MAX);

    for(let i=0;i<ROOM_ATTEMPTS && rooms.length<roomTarget;i++){
      const w = randInt(ROOM_W[0], ROOM_W[1]);
      const h = randInt(ROOM_H[0], ROOM_H[1]);
      const x = randInt(2, MAP_W - w - 3);
      const y = randInt(2, DUNGEON_H - h - 3);
      const r = {x,y,w,h, cx: Math.floor(x+w/2), cy: Math.floor(y+h/2)};
      if(rooms.some(o => rectsOverlapInflated(r,o,2))) continue;
      carveRoom(tiles, r);
      rooms.push(r);
    }
    if(rooms.length < 5){
      const r = {x: 10, y: 6, w: 22, h: 10, cx: 21, cy: 11};
      carveRoom(tiles, r);
      rooms.push(r);
    }

    // ===== // ===== OPTION A EXPERIMENT: reverse the main spine direction (right-to-left) =====
    // Phase 1: keep caves unchanged; only flip the room-chain order.
    // Debug: every other level. Normal: 20% chance.
    const spineFlip = DEBUG ? (depth % 2 === 0) : chance(0.20);

    // Sort rooms by cx; flip order when spineFlip is on.
    rooms.sort((a,b)=> spineFlip ? (b.cx - a.cx) : (a.cx - b.cx));

    // Connect consecutive rooms in this sorted order (the "spine").
    for(let i=1;i<rooms.length;i++){
      const a=rooms[i-1], b=rooms[i];
      carveCorridor(tiles, a.cx,a.cy,b.cx,b.cy);
    }

    // Start is first room in the chain; DOWN is last room in the chain.
    const startPos = findOpenSpot(tiles, rooms[0]);
    const downPos  = findOpenSpot(tiles, rooms[rooms.length-1]);
    tiles[downPos.x][downPos.y] = TILE.DOWN;

    // DEBUG-only marker so you can validate quickly without spoiling normal play.
    if(DEBUG) logMsg(`DEBUG: SpineFlip=${spineFlip ? "ON" : "off"}`);

    const items = new Map();
    const traps = new Map();
    const monsters = new Map();
    const traders = new Map();
    const corpses = new Map(); // keyXY -> { v: 1..5, color: "#rrggbb" }
    // DEBUG: Spawn all 4 scrolls in the first room (auto-read on pickup).
    // Only for debug/testing so you can validate effects quickly.
    if(DEBUG){
      const debugScrolls = ["‚òº","‚ñ≤","Œ®","¬§"];
      const r0 = rooms[0];
      // Scan for open spots inside the first room (avoid startPos and stairs).
      let placed = 0;
      for(let y = r0.y + 1; y <= r0.y + r0.h - 2 && placed < debugScrolls.length; y++){
        for(let x = r0.x + 1; x <= r0.x + r0.w - 2 && placed < debugScrolls.length; x++){
          if(x===startPos.x && y===startPos.y) continue;
          const t = tiles[x][y];
          if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
          const k = keyXY(x,y);
          if(items.has(k)) continue;
          items.set(k, { type: debugScrolls[placed] });
          placed++;
        }
      }
      if(placed < debugScrolls.length){
        // Fallback: drop remaining scrolls anywhere normal on the map
        for(; placed < debugScrolls.length; placed++){
          const p = findOpenSpot(tiles, r0);
          items.set(keyXY(p.x,p.y), { type: debugScrolls[placed] });
        }
      }
    }

    const lvl = {
      tiles, seen, visible, env, items, traps, monsters, traders, corpses,
      furnG, furnT,
      startPos, downPos, player: {...startPos},
      secret, secretDoors,
      lockedDoors: [],
      doorCoords: [],
      openedDoorMsgShown: false,
      blackouts: []
    };

    addSecretRooms(lvl, depth);

    lvl.doorCoords = placeDoorsOnChokepoints(lvl);
    lvl.lockedDoors = lockDoorsNoAdjacency(tiles, lvl.doorCoords, startPos);

    // Embedded cave systems (0‚Äì2 per level) live below the dungeon in the extra map band.
    generateCaves(lvl, depth);

    // DEBUG: reveal cave entrances only (not opened)
    if(DEBUG && lvl.caveEntrances && lvl.caveEntrances.size){
      for(const [k, ce] of lvl.caveEntrances.entries()){
        if(ce.discovered) continue;
        const p = parseKey(k);
        ce.discovered = true;
        if(lvl.tiles[p.x][p.y] === TILE.ROCK) lvl.tiles[p.x][p.y] = TILE.CAVE_C;
      }
      logMsg("DEBUG: Cave entrances revealed.");
    }

    // Intercessor stage visual injection (Level 1 only for now; ENV overlays only)
    // Goal: ensure every run can see/test the stage without touching tiles/pathing yet.
    if(depth === 1){
      const stageRoom = (rooms && rooms.length) ? rooms[Math.max(0, rooms.length-1)] : null;
      placeIntercessorStageEnv(lvl, stageRoom);
    }

// Blackout room selection (visibility-only modifier)
// NOTE: does not affect map generation/pathing, only FOV + seen behavior.
chooseBlackoutRooms(lvl, rooms, depth, startPos, downPos);

    // Bridges (BAD): combat-isolating spans inside rooms (rare; DEBUG forces one)
    placeBridges(lvl, rooms, depth, startPos, downPos);

    // Ambush stage: choose 0‚Äì1 rooms per level (latent until triggered).
    placeAmbushStage(lvl, rooms, depth, startPos, downPos);




    // Trader spawn
    if(chance(TRADER_SPAWN_CHANCE)){
      for(let tries=0; tries<8000; tries++){
        const x = randInt(2, MAP_W-3);
        const y = randInt(2, MAP_H-3);
        if(lvl.secret[x][y]) continue;
        const t = tiles[x][y];
        if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
        if((x===startPos.x && y===startPos.y) || (x===downPos.x && y===downPos.y)) continue;
        traders.set(keyXY(x,y), { name: "Trader" });
        break;
      }
    }
    const forbidOnTrader = (x,y) => traders.has(keyXY(x,y));

    const isNormal = (x,y) => !lvl.secret[x][y];
    const isSecret = (x,y) => lvl.secret[x][y];

    // Altar (gold sacrifice for max HP boost)
    // NOTE: condition order matters; check hp cap first, then randomness.
    if (game.hpMax < MAX_HP_CAP && Math.random() < ALTAR_CHANCE) {
      const minDist = 6; // keep away from start for fairness
      scatter(
        items,
        tiles,
        1,
        () => ({ type: ENT.ALTAR }),
        (x, y) =>
          isNormal(x, y) &&
          (Math.max(Math.abs(x - startPos.x), Math.abs(y - startPos.y)) >= minDist),
        forbidOnTrader
      );
    }

    // Vitality Shrine (optional permanent HP growth)
    // DEBUG: force a shrine into the starting room for testing
    if(DEBUG && game.hpMax < MAX_HP_CAP){
      const startRoom = rooms.find(r =>
        startPos.x >= r.x && startPos.x < (r.x + r.w) &&
        startPos.y >= r.y && startPos.y < (r.y + r.h)
      );
      if(DEBUG && DEBUG_FORCE_VITALITY_SHRINE && startRoom){
        let placed = false;
        for(let tries=0; tries<8000 && !placed; tries++){
          const x = randInt(startRoom.x + 1, startRoom.x + startRoom.w - 2);
          const y = randInt(startRoom.y + 1, startRoom.y + startRoom.h - 2);
          if(!isNormal(x,y)) continue;
          if(forbidOnTrader(x,y)) continue;
          if(x===startPos.x && y===startPos.y) continue;
          const k = keyXY(x,y);
          if(items.has(k)) continue;
          const t = tiles[x][y];
          if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
          if(t===TILE.DOWN || t===TILE.SDOWN) continue;
          if(t===TILE.DOOR_C || t===TILE.DOOR_O || t===TILE.LDOOR_C) continue;
          items.set(k, { type: ENT.SHRINE });
          placed = true;
        }
      }
    } else if(Math.random() < VITALITY_SHRINE_CHANCE && game.hpMax < MAX_HP_CAP){
      // keep away from start for fairness
      const minDist = 6;
      scatter(items, tiles, 1, () => ({ type: ENT.SHRINE }),
        (x,y) => isNormal(x,y) && (Math.max(Math.abs(x-startPos.x), Math.abs(y-startPos.y)) >= minDist),
        forbidOnTrader
      );
    }

    // Torches
    const torchCount = TORCH_BASE_COUNT + Math.floor(depth / TORCH_BONUS_EVERY_LEVELS) * TORCH_PER_LEVEL_BONUS;
    scatter(items, tiles, torchCount, () => ({ type: ENT.TORCH }), isNormal, forbidOnTrader);

    // Base spawns (excluding most chests: key chests will add more)
    const potionCount = randInt(3,5) + Math.floor(depth/5);
    const chestCount  = randInt(1,2) + Math.floor(depth/9);
    const trapCount   = randInt(2,4) + Math.floor(depth/5);
    let monsterCount= randInt(3,6) + Math.floor(depth/3);

    const __skelSpawned = spawnSkeletonPacks(lvl, depth, monsters, tiles, isNormal, forbidOnTrader, startPos);
    // Keep total monster density roughly consistent
    monsterCount = Math.max(0, monsterCount - Math.ceil(__skelSpawned/2));

    // Higher-tier herd packs (depth 9+): Cyclops / Spiders / Wyrms (each with a leader)
    let __herdSpawned = 0;
    for(const spec of HERD_SPECS){
      __herdSpawned += spawnHerdPacks(lvl, depth, monsters, tiles, isNormal, forbidOnTrader, startPos, spec);
    }
    monsterCount = Math.max(0, monsterCount - Math.ceil(__herdSpawned/2));

    scatter(items, tiles, potionCount, () => ({ type: ENT.POTION, potion: rollPotionType(depth) }), isNormal, forbidOnTrader);

    
    // Scrolls (new): spawn as distinct glyph items; pickup only for now (effects later)
    const scrollCount = (depth >= 2 ? 1 : 0) + (chance(0.35) ? 1 : 0);
    scatter(items, tiles, scrollCount, () => ({ type: SCROLL_GLYPHS[randInt(0, SCROLL_GLYPHS.length-1)] }), isNormal, forbidOnTrader);

// Normal gold-only chests (key chests added later)
    scatter(items, tiles, chestCount,  () => {
      const total = randInt(6,16) + depth*2;
      const cgold = chance(0.28) ? randInt(1, Math.max(1, Math.floor(total*0.6))) : 0;
      return { type: ENT.CHEST, gold: total - cgold, cgold, keys: 0 };
    }, isNormal, forbidOnTrader);

    if(depth === 1){
      // Guaranteed starting weapon placed on level 1 (player begins unarmed)
      const r0 = rooms[0] || {x:2,y:2,w:10,h:6};
      let placed = false;
      for(let tries=0; tries<6000 && !placed; tries++){
        const x = randInt(r0.x+1, r0.x+r0.w-2);
        const y = randInt(r0.y+1, r0.y+r0.h-2);
        if(x===startPos.x && y===startPos.y) continue;
        if(lvl.secret[x][y]) continue;
        if(tiles[x][y] !== TILE.FLOOR) continue;
        const k = keyXY(x,y);
        if(items.has(k) || traps.has(k) || monsters.has(k) || traders.has(k)) continue;
        items.set(k, { type: ENT.WEAPON, atk: 3, name: "Dagger" });
        placed = true;
      }
      if(!placed){
        // Fallback: anywhere passable not on start
        for(let tries=0; tries<6000 && !placed; tries++){
          const x = randInt(2, MAP_W-3);
          const y = randInt(2, MAP_H-3);
          if(x===startPos.x && y===startPos.y) continue;
          if(lvl.secret[x][y]) continue;
          const t = tiles[x][y];
          if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
          const k = keyXY(x,y);
          if(items.has(k) || traps.has(k) || monsters.has(k) || traders.has(k)) continue;
          items.set(k, { type: ENT.WEAPON, atk: 3, name: "Dagger" });
          placed = true;
        }
      }
    } else if(Math.random() < 0.35){
      scatter(items, tiles, 1, () => ({ type: ENT.WEAPON, atk: weaponAtkForDepth(depth), name: weaponNameForDepth(depth) }), isNormal, forbidOnTrader);
    }

    scatter(traps, tiles, trapCount, () => ({ revealed:false, dmg: randInt(2,5)+Math.floor(depth/6) }), isNormal, forbidOnTrader);
    for(let i=0;i<monsterCount;i++){
      scatter(monsters, tiles, 1, () => makeMonsterForDepth(depth), isNormal, forbidOnTrader);
    }

    // Secret loot
    const secretPotions = Math.max(1, Math.floor(potionCount/2));
    const secretChests  = Math.max(1, Math.floor(chestCount/1.5));
    scatter(items, tiles, secretPotions, () => ({ type: ENT.POTION, potion: rollPotionType(depth) }), isSecret, forbidOnTrader);
    scatter(items, tiles, secretChests, () => {
      const total = (randInt(6,16) + depth*2) * SECRET_REWARD_MULT;
      const cgold = chance(0.32) ? randInt(1, Math.max(1, Math.floor(total*0.6))) : 0;
      return { type: ENT.CHEST, gold: total - cgold, cgold, keys: 0 };
    }, isSecret, forbidOnTrader);
    scatter(items, tiles, Math.max(1, Math.floor(torchCount/3)), () => ({ type: ENT.TORCH }), isSecret, forbidOnTrader);
    const secretTrapCount = Math.max(2, Math.floor(trapCount * SECRET_TRAP_MULT));
    scatter(traps, tiles, secretTrapCount, () => ({ revealed:false, dmg: randInt(2,5)+Math.floor(depth/6) + 1 }), isSecret, forbidOnTrader);

    // Place key chests AFTER doors exist (so it knows exact needed key count)
    placeKeyChests(lvl, depth);

    // Boss on 20
    if(depth === 20){
      for(let tries=0; tries<9000; tries++){
        const x = randInt(2, MAP_W-3);
        const y = randInt(2, MAP_H-3);
        if(!isNormal(x,y)) continue;
        const t = tiles[x][y];
        if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
        const k = keyXY(x,y);
        if(monsters.has(k) || traders.has(k)) continue;
        monsters.set(k, { glyph: ENT.HORROR, hp: 34, atk: 9, name: "Deep Horror" });
        break;
      }
    }

    
    // Step 3: populate room environments (render-only overlays)
    placeLevelEnvironments(lvl, rooms, depth, startPos);

    // Step 3b: place BAD furniture stamps (blocking architecture + lore only)
    placeBADFurniture(lvl, rooms, depth, startPos, downPos);

    // Step 3c: place BAD statues (Œ© witness formations; lore-only)
    if (typeof placeBADStatues === 'function') placeBADStatues(lvl, rooms, depth, startPos, downPos);

    // TEST HARNESS: ensure Œ© statues are visible early for validation (Lvls 1‚Äì3)
    /*
    if(depth <= 3){
      try{
        const sr = (typeof _badFindRoomContaining === 'function') ? _badFindRoomContaining(rooms, startPos) : null;
        const r0 = sr || (rooms && rooms.length ? rooms[0] : null);
        if(r0 && lvl.furnG && lvl.furnT){
          const x = Math.min(r0.x + 2, r0.x + r0.w - 3); // interior near left wall
          let placed = 0;
          for(let y = r0.y + 2; y <= r0.y + r0.h - 3; y += 2){
            if(placed >= 6) break;
            if(x === startPos.x && y === startPos.y) continue;
            const t = lvl.tiles[x][y];
            if(t === TILE.FLOOR || t === TILE.CORR){
              lvl.furnG[x][y] = 'Œ©';
              lvl.furnT[x][y] = 'statue';
              lvl.tiles[x][y] = TILE.ROCK;
              placed++;
            }
          }
        }
      }catch(_){}
    }
    */

    // Precompute cave mask used for fog-of-war + rendering behavior.
    lvl.caveMask = buildCaveMaskFromFloors(lvl);
    // Stationary light sources (e.g., cave illumination scroll). Cleared on level change.
    lvl.staticLights = [];
    // Cave-only ambient bats (visual-only). Trigger once per whole cave, on first illumination.
    lvl.caveBatsTriggered = false;
    lvl.caveBats = [];
    spawnCaveIlluminationScrolls(lvl, depth);
    spawnCaveChaosRelics(lvl, depth);

    // Chaos Relic state
    lvl.chaosRelicWarned = new Set();     // adjacency message, once per relic
    lvl.pendingChaosReward = null;        // tracks spawned monsters for reward drop

    return lvl;
  }

  // ---------- SECRET DOOR REVEAL ----------
  function tryRevealAdjacentSecretDoors(lvl){
    const px = lvl.player.x, py = lvl.player.y;
    for(let dx=-1; dx<=1; dx++){
      for(let dy=-1; dy<=1; dy++){
        if(dx===0 && dy===0) continue;
        const x = px + dx, y = py + dy;
        if(x<1||y<1||x>=MAP_W-1||y>=MAP_H-1) continue;

        const k = keyXY(x,y);
        if(!lvl.secretDoors.has(k)) continue;
        const sd = lvl.secretDoors.get(k);
        if(sd.discovered) continue;
        if(lvl.tiles[x][y] !== TILE.ROCK) continue;

        if(chance(SECRET_REVEAL_CHANCE)){
          sd.discovered = true;
          lvl.tiles[x][y] = TILE.SD_C;
          logMsg("A secret door reveals itself!");
        }
      }
    }
  }

  // ---------- CAVE ENTRANCES / CAVES ----------
  function tryRevealAdjacentCaveEntrances(lvl){
    if(!lvl.caveEntrances || lvl.caveEntrances.size === 0) return;
    const px = lvl.player.x, py = lvl.player.y;
    for(let dx=-1; dx<=1; dx++){
      for(let dy=-1; dy<=1; dy++){
        if(dx===0 && dy===0) continue;
        const x = px + dx, y = py + dy;
        if(x<1||y<1||x>=MAP_W-1||y>=MAP_H-1) continue;

        const k = keyXY(x,y);
        if(!lvl.caveEntrances.has(k)) continue;
        const ce = lvl.caveEntrances.get(k);
        if(ce.discovered) continue;
        if(lvl.tiles[x][y] !== TILE.ROCK) continue;

        // Slightly more generous than secret doors; still feels "hidden".
        if(chance(0.45)){
          ce.discovered = true;
          lvl.tiles[x][y] = TILE.CAVE_C;
          logMsg("Cracks in the stone reveal a cavernous entrance.");
           fireLoreOnce(`cave_entrance_${game.depth}`, "Stone gives way to an old throat and deeper breath.");
        }
      }
    }
  }

  function buildCaveMaskFromFloors(lvl){
    const mask = makeGrid(MAP_W, MAP_H, false);
    if(!lvl.cave) return mask;
    for(let x=0; x<MAP_W; x++){
      for(let y=0; y<MAP_H; y++){
        if(lvl.cave[x][y]) mask[x][y] = true;
      }
    }
    // Expand one tile into surrounding rock so cave walls can be treated as "cave space" for rendering/fog rules.
    for(let x=0; x<MAP_W; x++){
      for(let y=0; y<MAP_H; y++){
        if(!lvl.cave[x][y]) continue;
        for(let dx=-1; dx<=1; dx++){
          for(let dy=-1; dy<=1; dy++){
            const nx=x+dx, ny=y+dy;
            if(nx<0||ny<0||nx>=MAP_W||ny>=MAP_H) continue;
            mask[nx][ny] = true;
          }
        }
      }
    }
    return mask;
  }

// Spawn cave-only Scroll of Illumination (‚òº): auto-read on pickup.
// 50% chance per cave entrance. Effect: creates a stationary glow that persists until level change.
function spawnCaveIlluminationScrolls(lvl, depth){
  if(!lvl || !lvl.caveMask || !lvl.caveEntrances) return;
  const entranceCount = lvl.caveEntrances.size || 0;
  if(entranceCount <= 0) return;

  let count = 0;
  for(let i=0;i<entranceCount;i++){
    if(chance(0.50)) count++;
  }
  if(count <= 0) return;

  const tiles = lvl.tiles;
  function canPlaceCave(x,y){
    if(y < CAVE_Y0) return false;
    if(!lvl.caveMask[x][y]) return false;
    const t = tiles[x][y];
    return (t === TILE.FLOOR || t === TILE.CORR || t === TILE.CAVE_FLOOR);
  }
  // Place the illumination scrolls on cave floors only.
  scatter(lvl.items, tiles, count, () => ({ type: "‚òº", caveIllum: true }), canPlaceCave, null);
}

function spawnCaveChaosRelics(lvl, depth){
  if(!lvl || !lvl.caveMask || !lvl.items) return;

  // Somewhat common: ~35% of caves get a relic.
  // Cap: don't spam; at most 1 relic per level (safe + meaningful).
  const CHANCE = 0.35;

  if(!chance(CHANCE)) return;

  // Place it somewhere inside cave space, on floor, not right at entrance.
  for(let tries=0; tries<8000; tries++){
    const x = randInt(2, MAP_W-3);
    const y = randInt(2, MAP_H-3);

    if(!lvl.caveMask[x][y]) continue;
    if(lvl.tiles[x][y] !== TILE.FLOOR && lvl.tiles[x][y] !== TILE.CORR) continue;

    // Avoid placing on entrance tiles
    const t = lvl.tiles[x][y];
    if(t === TILE.CAVE_C || t === TILE.CAVE_O) continue;

    const k = keyXY(x,y);
    if(lvl.items.has(k)) continue;

    lvl.items.set(k, { type:'A' });
    return;
  }
}

  
// ------------------------------------------------------------
// CAVE BATS (ambient, harmless, cave-only)
// - Glyph: ^
// - Color: dull brown (COL.bat)
// - Trigger: once per whole cave, on first illumination of any cave tile
// ------------------------------------------------------------
function spawnCaveBats(lvl){
  if(!lvl || lvl.caveBatsTriggered) return;
  lvl.caveBatsTriggered = true;

  // Decide pair vs swarm based on available cave footprint
  let caveTiles = 0;
  if(lvl.caveMask){
    for(let x=0;x<MAP_W;x++){
      for(let y=CAVE_Y0; y<MAP_H; y++){
        if(lvl.caveMask[x][y]) caveTiles++;
      }
    }
  }
  const swarmOk = caveTiles >= 90;          // needs a decent chamber system
  const isSwarm = swarmOk && chance(0.18);  // rare
  const count = isSwarm ? randInt(3,6) : 2;

  // Spawn near the first visible cave tile if possible, else near player.
  let sx = lvl.player.x, sy = lvl.player.y;
  if(lvl.visible && lvl.caveMask){
    outer:
    for(let y=CAVE_Y0; y<MAP_H; y++){
      for(let x=0;x<MAP_W; x++){
        if(lvl.visible[x][y] && lvl.caveMask[x][y]){ sx=x; sy=y; break outer; }
      }
    }
  }

  // Create a small flock with random jitter, then scatter.
  lvl.caveBats = [];
  for(let i=0;i<count;i++){
    lvl.caveBats.push({
      x: sx + randInt(-1,1),
      y: sy + randInt(-1,1),
      life: randInt(6,10),  // short-lived (movement steps)
      dx: randInt(-1,1),
      dy: randInt(-1,1)
    });
  }

  if(isSwarm) logMsg("A swarm of bats erupts from the darkness!");
  else if(chance(0.30)) logMsg("Eyes watch in the dark.");
}

function stepCaveBats(lvl){
  if(!lvl || !lvl.caveBats || !lvl.caveBats.length) return;
  const alive = [];
  for(const b of lvl.caveBats){
    let nx = b.x, ny = b.y;

    // erratic motion with bias to keep moving
    if(chance(0.55)){ b.dx = randInt(-1,1); b.dy = randInt(-1,1); }
    nx += b.dx; ny += b.dy;

    // keep within bounds and inside cave
    if(nx<1||ny<1||nx>=MAP_W-1||ny>=MAP_H-1){ nx = b.x; ny = b.y; }
    if(lvl.caveMask && !lvl.caveMask[nx][ny]){ nx = b.x; ny = b.y; }

    b.x = nx; b.y = ny;
    b.life -= 1;

    if(b.life > 0) alive.push(b);
  }
  lvl.caveBats = alive;
}

function generateCaves(lvl, depth){
    // Carve 0‚Äì2 cave systems per level into the extra "band" below the dungeon.
    lvl.cave = makeGrid(MAP_W, MAP_H, false);
    lvl.caveEntrances = new Map();

    // Depth scaling: more caves deeper, but keep footprint modest.
    const maxCaves = 5;
    let caveCount = 0;

    // Tunings (DEBUG off): guaranteed 1 cave from depth 1; more as depth increases.
    if(depth >= 1 && chance(1.00)) caveCount++;
    if(depth >= 2 && chance(0.75)) caveCount++;
    if(depth >= 7 && chance(0.55)) caveCount++;

    caveCount = Math.min(maxCaves, caveCount);
    if(caveCount <= 0) return;

    const tiles = lvl.tiles;

    function isDungeonPassable(t){
      return (t === TILE.FLOOR || t === TILE.CORR || t === TILE.DOOR_O || t === TILE.LDOOR_O || t === TILE.SD_O || t === TILE.DOWN || t === TILE.SDOWN);
    }

// Reachability: ensure cave entrances only spawn where the player can actually stand adjacent
// on the main dungeon (not behind unopened secret doors / locked doors).
function isReachPassable(t){
  // Only tiles the player can currently walk on at level start.
  return (t === TILE.FLOOR || t === TILE.CORR || t === TILE.DOOR_O || t === TILE.LDOOR_O || t === TILE.SD_O || t === TILE.DOWN || t === TILE.SDOWN);
}
function buildReachableFromStart(){
  const reach = makeGrid(MAP_W, MAP_H, false);
  const q = [];
  const sx = lvl.startPos.x, sy = lvl.startPos.y;
  if(sx<0||sy<0||sx>=MAP_W||sy>=MAP_H) return reach;
  if(!isReachPassable(tiles[sx][sy])) return reach;
  reach[sx][sy] = true;
  q.push([sx,sy]);
  while(q.length){
    const [x,y] = q.pop();
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if(nx<0||ny<0||nx>=MAP_W||ny>=DUNGEON_H) continue; // stay in dungeon region
      if(reach[nx][ny]) continue;
      if(!isReachPassable(tiles[nx][ny])) continue;
      reach[nx][ny]=true;
      q.push([nx,ny]);
    }
  }
  return reach;
}
const reachable = buildReachableFromStart();

    function findEntranceCandidate(){
      const candidates = [];
      for(let x=2; x<MAP_W-2; x++){
        // Favor the lower third of the dungeon so the vertical "drop" feels natural.
        for(let y=Math.floor(DUNGEON_H*0.55); y<DUNGEON_H-2; y++){
          if(tiles[x][y] !== TILE.ROCK) continue;

          // Never place cave entrances on (or too near) secret doors or other cave entrances
          const k0 = keyXY(x,y);
          if(lvl.secretDoors && lvl.secretDoors.has(k0)) continue;
          if(lvl.caveEntrances && lvl.caveEntrances.size){
            let tooClose = false;
            for(let ddx=-2; ddx<=2 && !tooClose; ddx++){
              for(let ddy=-2; ddy<=2; ddy++){
                if(ddx===0 && ddy===0) continue;
                const nx = x + ddx, ny = y + ddy;
                if(nx<1||ny<1||nx>=MAP_W-1||ny>=MAP_H-1) continue;
                const kk = keyXY(nx,ny);
                if(lvl.caveEntrances.has(kk) || (lvl.secretDoors && lvl.secretDoors.has(kk))){
                  tooClose = true;
                  break;
                }
              }
            }
            if(tooClose) continue;
          }

const n = tiles[x][y-1], s = tiles[x][y+1], w = tiles[x-1][y], e = tiles[x+1][y];

// Must be adjacent to a *reachable* dungeon tile (not merely a floor behind a secret/locked barrier).
const adjReach =
  (reachable[x][y-1] && isReachPassable(n) && !lvl.secret[x][y-1]) ||
  (reachable[x][y+1] && isReachPassable(s) && !lvl.secret[x][y+1]) ||
  (reachable[x-1][y] && isReachPassable(w) && !lvl.secret[x-1][y]) ||
  (reachable[x+1][y] && isReachPassable(e) && !lvl.secret[x+1][y]);

if(!adjReach) continue;

          // Must have rock below to "descend" into the cave pad/band.
          if(y+1 >= MAP_H-1) continue;
          if(tiles[x][y+1] !== TILE.ROCK) continue;

          // Avoid placing directly beside existing special tiles.
          if(n === TILE.DOWN || s === TILE.DOWN || w === TILE.DOWN || e === TILE.DOWN) continue;

          candidates.push({x,y});
        }
      }
      if(!candidates.length) return null;
      return candidates[randInt(0, candidates.length-1)];
    }

    function carveCaveFloor(x,y){
      if(x<1||y<1||x>=MAP_W-1||y>=MAP_H-1) return;
      if(tiles[x][y] === TILE.ROCK) tiles[x][y] = TILE.FLOOR;
      lvl.cave[x][y] = true;
    }

    function carveBlob(cx, cy, r){
      // Non-rectangular "chamber" blob using noisy radius.
      const r2 = r*r;
      for(let dx=-r; dx<=r; dx++){
        for(let dy=-r; dy<=r; dy++){
          const x=cx+dx, y=cy+dy;
          if(x<1||y<CAVE_Y0||x>=MAP_W-1||y>=MAP_H-1) continue;
          const jitter = 0.55 + Math.random()*0.75; // controls blob irregularity
          if(dx*dx + dy*dy <= r2*jitter){
            carveCaveFloor(x,y);
          }
        }
      }
    }

    function randomWalk(startX, startY, steps){
      let x=startX, y=startY;
      carveCaveFloor(x,y);

      let chamberCooldown = 0;
      for(let i=0; i<steps; i++){
        // Direction bias: mostly downward/sideways, less upward.
        const r = Math.random();
        let dx=0, dy=0;
        if(r < 0.30){ dx = -1; dy = 0; }
        else if(r < 0.60){ dx = 1; dy = 0; }
        else if(r < 0.90){ dx = 0; dy = 1; }
        else { dx = 0; dy = -1; }

        // 1‚Äì2 tile passages
        x = clamp(x + dx, 2, MAP_W-3);
        y = clamp(y + dy, CAVE_Y0+1, MAP_H-3);

        carveCaveFloor(x,y);
        if(chance(0.35)) carveCaveFloor(x+dx, y+dy); // thicken occasionally

        if(chamberCooldown<=0 && chance(0.12)){
          const rr = randInt(3, 7);
          carveBlob(x, y, rr);
          chamberCooldown = randInt(8, 16);
        } else {
          chamberCooldown--;
        }
      }
      return {x,y};
    }

    const used = new Set();
    for(let i=0; i<caveCount; i++){
      const ent = findEntranceCandidate();
      if(!ent) break;
      const ek = keyXY(ent.x, ent.y);
      if(used.has(ek)) continue;
      used.add(ek);

      // Store entrance; remains ROCK until discovered.
      lvl.caveEntrances.set(ek, { discovered:false });

      // Vertical "drop" through the pad into the cave band.
      for(let y=ent.y+1; y<CAVE_Y0; y++){
        carveCaveFloor(ent.x, y);
      }
      carveCaveFloor(ent.x, CAVE_Y0);

      // Main walk
      const steps = randInt(70, 140);
      const end = randomWalk(ent.x, CAVE_Y0, steps);

      // 50% of caves have a dead-end branch you must backtrack.
      if(chance(0.5)){
        const bSteps = randInt(25, 55);
        randomWalk(end.x, end.y, bSteps);
      }
    }
  }


// ---------- BLACKOUT ROOMS ----------
// Blackout rooms:
// - No render-loop masking (player glyph remains visible normally)
// - While player is inside (INNER area): FOV radius forced to 1 (torches have no effect)
// - No map memory in blackout area (OUTER area incl. walls/corners): tiles never persist in lvl.seen,
//   so after leaving it appears as a void (no outline).
//
// Implementation detail:
//   Each blackout record stores both an INNER rect (walkable room footprint) and an OUTER rect
//   expanded by 1 tile to include surrounding walls/corners.
function __isInOuter(x,y,rc){ return x>=rc.x0 && x<=rc.x1 && y>=rc.y0 && y<=rc.y1; }
function __isInInner(x,y,rc){ return x>=rc.ix0 && x<=rc.ix1 && y>=rc.iy0 && y<=rc.iy1; }

function lvlBlackoutOuterRectAt(lvl, x, y){
  if(!lvl || !lvl.blackouts || !lvl.blackouts.length) return null;
  for(const rc of lvl.blackouts){ if(__isInOuter(x,y,rc)) return rc; }
  return null;
}
function lvlBlackoutInnerRectAt(lvl, x, y){
  if(!lvl || !lvl.blackouts || !lvl.blackouts.length) return null;
  for(const rc of lvl.blackouts){ if(__isInInner(x,y,rc)) return rc; }
  return null;
}

// Use OUTER for tile-level fog/memory suppression (includes walls/corners)
function lvlIsBlackoutAt(lvl, x, y){ return !!lvlBlackoutOuterRectAt(lvl, x, y); }
// Use OUTER for player-in-room effects (includes doorway tile; FOV clamp + enter message)
function lvlIsInBlackoutRoom(lvl, x, y){ return !!lvlBlackoutOuterRectAt(lvl, x, y); }

function clearSeenInRect(lvl, rc){
  if(!lvl || !lvl.seen || !rc) return;
  for(let x=rc.x0; x<=rc.x1; x++){
    for(let y=rc.y0; y<=rc.y1; y++){
      if(x<0||y<0||x>=MAP_W||y>=MAP_H) continue;
      lvl.seen[x][y] = false;
    }
  }
}

function chooseBlackoutRooms(lvl, rooms, depth, startPos, downPos){
  if(!lvl) return;
  lvl.blackouts = [];

  // --- Level schedule (banded + spike levels 13 and 19) ---
  // Two-stage: (1) chance the level has any blackout; (2) if yes, % of rooms converted.
  // Kept intentionally "unusual" with quiet stretches, and limited room counts for potency.
  let levelChance = 0.0;
  let roomPct = 0.0;

  if(depth <= 2){
    levelChance = 0.0; roomPct = 3.0;
  } else if(depth === 3){
    levelChance = 0.08; roomPct = 0.15;
  } else if(depth === 4){
    levelChance = 0.10; roomPct = 0.15;
  } else if(depth === 5){
    levelChance = 0.12; roomPct = 0.18;
  } else if(depth >= 6 && depth <= 8){
    levelChance = 0.0; roomPct = 0.0;
  } else if(depth === 9){
    levelChance = 0.50; roomPct = 0.18;
  } else if(depth === 10){
    levelChance = 0.18; roomPct = 0.20;
  } else if(depth === 11){
    levelChance = 0.20; roomPct = 0.20;
  } else if(depth === 12){
    levelChance = 0.25; roomPct = 0.22;
  } else if(depth === 13){
    levelChance = 1.0; roomPct = 0.25; // SPIKE
  } else if(depth === 14){
    levelChance = 0.20; roomPct = 0.20;
  } else if(depth === 15){
    levelChance = 0.18; roomPct = 0.20;
  } else if(depth >= 16 && depth <= 18){
    levelChance = 0.0; roomPct = 0.0;
  } else if(depth === 19){
    levelChance = 1.0; roomPct = 0.35; // SPIKE
  } else { // 20+
    levelChance = 0.25; roomPct = 0.20;
  }

  // Decide if blackout exists on this level at all.
  if(levelChance <= 0 || !chance(levelChance)) return;

  if(!rooms || !rooms.length || roomPct <= 0) return;

  // Helper: does a point sit within a room rect?
  function ptInRoom(pt, r){
    if(!pt) return false;
    return (pt.x >= r.x && pt.x < r.x + r.w && pt.y >= r.y && pt.y < r.y + r.h);
  }

  // Exclude start room and stairs/exit room for fairness
  const cands = [];
  for(const r of rooms){
    if(startPos && ptInRoom(startPos, r)) continue;
    if(downPos && ptInRoom(downPos, r)) continue;
    cands.push(r);
  }
  if(!cands.length) return;

  // Shuffle candidates (Fisher‚ÄìYates)
  for(let i=cands.length-1; i>0; i--){
    const j = randInt(0, i);
    const tmp = cands[i]; cands[i] = cands[j]; cands[j] = tmp;
  }

  // Potency caps
  const maxBlackouts = (depth <= 12) ? 2 : 3;

  // Determine how many rooms to convert this level
  let target = Math.round(cands.length * roomPct);
  target = Math.max(1, target);
  target = Math.min(maxBlackouts, target);

  // Room -> blackout record
  function mkRec(r){
    const ix0 = r.x, iy0 = r.y, ix1 = r.x + r.w - 1, iy1 = r.y + r.h - 1;
    const x0 = ix0 - 1, y0 = iy0 - 1, x1 = ix1 + 1, y1 = iy1 + 1;
    return { x0, y0, x1, y1, ix0, iy0, ix1, iy1 };
  }

  for(let i=0; i<target; i++){
    const r = cands[i];
    if(!r) continue;
    lvl.blackouts.push(mkRec(r));
  }
}



  // ---------- FOV / LOS ----------
  function isDoorClosed(t){ return (t === TILE.DOOR_C || t === TILE.SD_C || t === TILE.LDOOR_C || t === TILE.CAVE_C); }
  function isBlockingTile(lvl, x, y){
    const t = lvl.tiles[x][y];

    return (t === TILE.ROCK) || isDoorClosed(t);
  }
  function hasLos(lvl, x0,y0,x1,y1){
    let dx = Math.abs(x1-x0), sx = x0<x1 ? 1 : -1;
    let dy = -Math.abs(y1-y0), sy = y0<y1 ? 1 : -1;
    let err = dx + dy;
    let x=x0, y=y0;
    while(true){
      if(x===x1 && y===y1) return true;
      if(!(x===x0 && y===y0) && isBlockingTile(lvl, x, y)) return false;
      const e2 = 2*err;
      if(e2 >= dy){ err += dy; x += sx; }
      if(e2 <= dx){ err += dx; y += sy; }
      if(x<0||y<0||x>=MAP_W||y>=MAP_H) return false;
    }
  }
  function computeFov(lvl){
    const R = currentVisionRadius();
    for(let x=0;x<MAP_W;x++) for(let y=0;y<MAP_H;y++) lvl.visible[x][y]=false;
    const px = lvl.player.x, py = lvl.player.y;
    const __playerInBlackout = !!lvlBlackoutOuterRectAt(lvl, px, py);
    for(let dx=-R; dx<=R; dx++){
      for(let dy=-R; dy<=R; dy++){
        const x = px + dx, y = py + dy;
        if(x<0||y<0||x>=MAP_W||y>=MAP_H) continue;
        if(dx*dx + dy*dy > R*R) continue;
        if(!__playerInBlackout && lvlIsBlackoutAt(lvl, x, y) && !(x===px && y===py)) continue;
        if(hasLos(lvl, px, py, x, y)){
          lvl.visible[x][y] = true;
          // Cave fog-of-war: visibility does NOT persist behind you.
          if(!(lvl.caveMask && lvl.caveMask[x][y]) && !lvlIsBlackoutAt(lvl, x, y)){
            lvl.seen[x][y] = true;
          }
        }
      }
    }

// Apply stationary light sources (e.g., cave glow) as additional visibility.
if(lvl.staticLights && lvl.staticLights.length){
  for(const L of lvl.staticLights){
    const lx = L.x, ly = L.y;
    const LR = L.r;
    for(let dx=-LR; dx<=LR; dx++){
      for(let dy=-LR; dy<=LR; dy++){
        const x = lx + dx, y = ly + dy;
        if(x<0||y<0||x>=MAP_W||y>=MAP_H) continue;
        if(dx*dx + dy*dy > LR*LR) continue;
        if(!__playerInBlackout && lvlIsBlackoutAt(lvl, x, y) && !(x===px && y===py)) continue;
        if(hasLos(lvl, lx, ly, x, y)){
          lvl.visible[x][y] = true;
          if(!(lvl.caveMask && lvl.caveMask[x][y]) && !lvlIsBlackoutAt(lvl, x, y)){
            lvl.seen[x][y] = true;
          }
        }
      }
    }
  }
}

  // Blackout: tiles (including walls/corners) never persist in memory.
  if(lvl.blackouts && lvl.blackouts.length){
    for(const rc of lvl.blackouts){
      for(let x=Math.max(0,rc.x0); x<=Math.min(MAP_W-1,rc.x1); x++){
        for(let y=Math.max(0,rc.y0); y<=Math.min(MAP_H-1,rc.y1); y++){
          lvl.seen[x][y] = false;
        }
      }
    }
  }

  // Trigger cave bats once per whole cave: first time any cave tile becomes illuminated.
  if(!lvl.caveBatsTriggered && lvl.caveMask){
    let found = false;
    for(let x=0;x<MAP_W && !found;x++){
      for(let y=CAVE_Y0; y<MAP_H; y++){
        if(lvl.visible[x][y] && lvl.caveMask[x][y]){
          found = true;
          break;
        }
      }
    }
    if(found) spawnCaveBats(lvl);
  }

    for(const [k, tr] of lvl.traps.entries()){
      const {x,y} = parseKey(k);
      if(lvl.visible[x][y]){
        if(!tr.revealed){ /* trap reveal reserved for future abilities; visual proximity fade handles visibility */ }
else {
          tr.revealed = true;
        }
      }
    }
  
    // Safety: never hide the player's own tile.
    lvl.visible[px][py] = true;
}

  
  // Helper: determine if a tile is lit by any stationary light source (used to render cave glow robustly).
  function isLitByStaticLights(lvl, x, y){
    if(!lvl || !lvl.staticLights || !lvl.staticLights.length) return false;
    for(const L of lvl.staticLights){
      const dx = x - L.x, dy = y - L.y;
      if(dx*dx + dy*dy > L.r*L.r) continue;
      if(hasLos(lvl, L.x, L.y, x, y)) return true;
    }
    return false;
  }

// ---------- TRADER PROMPT DEFAULT N ----------
  // [removed handlePromptOnMoveStart]

  // [removed openTraderPromptIfStanding]

  function resolveTrade(accepted){
    const lvl = getLevel(game.depth);
    const p = game.prompt;
    if(!p || p.type !== 'trade') return;

    const onTile = (lvl.player.x === p.x && lvl.player.y === p.y);
    if(!onTile){ clearPrompt(); return; }

    if(!accepted){
      logMsg("Trade declined.");
      clearPrompt();
      return;
    }

    const sel = p.selection || 'A';
    if(sel === 'A'){
      if(game.gold < p.costPotion){
        logMsg(`Not enough gold. Potion costs ${p.costPotion}g.`);
        clearPrompt();
        return;
      }
      if(game.inv.potions.length >= POTION_CAP){
        logMsg(`Potion satchel is full (cap ${POTION_CAP}).`);
        clearPrompt();
        return;
      }
      game.gold -= p.costPotion;
      const potion = chance(0.60) ? POTION.HEAL : rollPotionType(game.depth);
      game.inv.potions.push(potion);
      logMsg(`Bought a ${POTION_NAME[potion]} potion for ${p.costPotion}g.`);
      clearPrompt();
      return;
    }

    if(sel === 'B'){
      if(game.gold < p.costWeapon){
        logMsg(`Not enough gold. Weapon upgrade costs ${p.costWeapon}g.`);
        clearPrompt();
        return;
      }
      game.gold -= p.costWeapon;
      game.atk += TRADER_WEAPON_ATK_BONUS;
      game.weaponName = `${game.weaponName}+`;
      logMsg(`Upgraded weapon! ATK +${TRADER_WEAPON_ATK_BONUS} for ${p.costWeapon}g.`);
      clearPrompt();
      return;
    }

    clearPrompt();
  }

  function resolveChaosRelic(accepted){
    if(!accepted) return;
    game.relicJustClaimed = true;
    const lvl = getLevel(game.depth);
    const p = lvl.player;
    resolveChaosRelicAt(p.x, p.y);
  }

  function resolveChaosRelicAt(x, y){
    const lvl = getLevel(game.depth);
    const k = keyXY(x, y);
    const it = lvl.items.get(k);
    if(!it || it.type !== 'A') return;

    lvl.items.delete(k);
    logMsg("The relic shatters ‚Äî something answers the call.");
    fireLoreOnce("cave_relic_shatter", "The old stone learns your name.");
    startTileAnim(x, y, "monster_death", 700, { glyph: '—ß', color: COL.chaosRelic });

    const spawnedKeys = [];
    const count = randInt(3,6);
    const px = lvl.player.x, py = lvl.player.y;

    for(let i=0; i<count; i++){
      let placed = false;
      for(let tries=0; tries<12000 && !placed; tries++){
        const sx = randInt(2, MAP_W-3);
        const sy = randInt(2, MAP_H-3);
        if(!lvl.caveMask || !lvl.caveMask[sx][sy]) continue;

        const t = lvl.tiles[sx][sy];
        if(!(t===TILE.FLOOR || t===TILE.CORR)) continue;
        if(Math.abs(sx-px)<=1 && Math.abs(sy-py)<=1) continue;

        const kk = keyXY(sx,sy);
        if(lvl.monsters.has(kk) || lvl.traders.has(kk)) continue;

        const m = makeMonsterForDepth(game.depth);
        m.chaos = true;
        m.chaosId = CHAOS_ID++;
        lvl.monsters.set(kk, m);
        spawnedKeys.push(m.chaosId);
        placed = true;
      }
    }

    lvl.pendingChaosReward = { x:x, y:y, monsters: new Set(spawnedKeys) };
  }

  function resolveShrine(accepted){
    if(!accepted) return;
    const lvl = getLevel(game.depth);
    const p = lvl.player;
    resolveShrineAt(p.x, p.y);
  }

  
function resolveAltarAt(x, y){
    const lvl = getLevel(game.depth);
    const k = keyXY(x, y);
    const it = lvl.items.get(k);
    if(!it || it.type !== ENT.ALTAR) return;

    // If already at max cap, altar refuses (prevents meaningless gold burn)
    if(game.hpMax >= MAX_HP_CAP){
      logMsg("The alter is silent. You can grow no stronger.");
      return;
    }

    if(game.gold < ALTAR_GOLD_COST){
      logMsg(`Not enough gold. Sacrifice costs ${ALTAR_GOLD_COST}GP.`);
      return;
    }

    // Pay and receive blessing
    game.gold -= ALTAR_GOLD_COST;
    const boost = randInt(ALTAR_HP_BOOST_MIN, ALTAR_HP_BOOST_MAX);
    const oldMax = game.hpMax;
    game.hpMax = Math.min(MAX_HP_CAP, game.hpMax + boost);
    game.hp = game.hpMax; // full refill

    

    fireLoreOnce('lore_altar', 'That cost is remembered.');
lvl.items.delete(k);

    const gained = game.hpMax - oldMax;
    logMsg(`You sacrifice ${ALTAR_GOLD_COST}GP. (+${gained} max HP) Fully healed.`);
}

function resolveShrineAt(x, y){
    const lvl = getLevel(game.depth);
    const k = keyXY(x, y);
    const it = lvl.items.get(k);
    if(!it || it.type !== ENT.SHRINE) return;

    lvl.items.delete(k);

    if(game.hpMax >= MAX_HP_CAP){
      logMsg("The shrine is dormant. You feel no further growth is possible.");
      logMsg("Shrine vanishes.");
      return;
    }

    let paidMsg = "";
    if(game.inv.potions.length > 0){
      const idx = randInt(0, game.inv.potions.length - 1);
      const lost = game.inv.potions.splice(idx, 1)[0];
      paidMsg = `(lost a ${POTION_NAME[lost]} potion)`;
    } else {
      const cost = SHRINE_BASE_GOLD_COST + game.depth * SHRINE_GOLD_PER_LEVEL;
      if(game.gold < cost){
        logMsg("You have nothing to offer the shrine.");
        logMsg("The shrine fades.");
        return;
      }
      game.gold -= cost;
      paidMsg = `(paid ${cost} gold)`;
    }

    game.hpMax += 1;
    game.hp = Math.min(game.hpMax, game.hp + 1);

    logMsg(`Vitality surges through you. +1 Max HP ${paidMsg}.`);
    logMsg("Shrine vanishes.");
  }

  // ---------- MOVEMENT / COMBAT ----------
  function tilePassable(lvl, x, y){
    // BAD furniture stamps are blocking stone
    if(lvl.furnG && lvl.furnG[x] && lvl.furnG[x][y]) return false;
    const t = lvl.tiles[x][y];
    // Bridges: span is walkable decking ':' but you may only enter/exit via endpoints '[' and ']'.
    // Passability here is simple; boundary rules are enforced in movement code (player + monsters).
    if(t === TILE.BRIDGE_L || t === TILE.BRIDGE_R || t === TILE.BRIDGE_SPAN) return true;
    if(t === TILE.ROCK) return false;
    if(t === TILE.DOOR_C || t === TILE.SD_C || t === TILE.CAVE_C) return false;
    if(t === TILE.LDOOR_C){
      if(hasTransmute()) return true;
      return false;
    }
    return true;
  }

  function isBridgeSpan(lvl, x, y){
  const t = (lvl && lvl.tiles && lvl.tiles[x]) ? lvl.tiles[x][y] : null;
  return (t === TILE.BRIDGE_SPAN);
}

function isBridgeEnd(lvl, x, y){
  const t = (lvl && lvl.tiles && lvl.tiles[x]) ? lvl.tiles[x][y] : null;
  return (t === TILE.BRIDGE_L || t === TILE.BRIDGE_R);
}

function isBridgeAny(lvl, x, y){
  const t = (lvl && lvl.tiles && lvl.tiles[x]) ? lvl.tiles[x][y] : null;
  return (t === TILE.BRIDGE_L || t === TILE.BRIDGE_R || t === TILE.BRIDGE_SPAN);
}

function roomHasFurniture(lvl, r){
  if(!lvl || !lvl.furnT || !lvl.furnG) return false;
  for(let y=r.y+1; y<=r.y+r.h-2; y++){
    for(let x=r.x+1; x<=r.x+r.w-2; x++){
      if((lvl.furnT[x] && lvl.furnT[x][y]) ||
         (lvl.furnG[x] && lvl.furnG[x][y])) return true;
    }
  }
  return false;
}

function roomPassableInteriorCount(lvl, r){
  let n = 0;
  for(let y=r.y+1; y<=r.y+r.h-2; y++){
    for(let x=r.x+1; x<=r.x+r.w-2; x++){
      if(tilePassable(lvl, x, y)) n++;
    }
  }
  return n;
}

  // ---------- CORPSES (persistent, non-blocking residue) ----------
  // We store corpse metadata separately from the base tile grid so the tile can remain '_' while
  // the renderer can pick a variant PNG + tint to the monster's color.
  const CORPSE_VARIANTS = 5;

  // Encounter-scoped corpse variant selection (Option B)
  // We avoid per-monster-type encoding; instead we let repetition communicate quantity.
  // Small skirmishes: mostly the same, sometimes mixed. Large fights: coherent pattern.
  const CORPSE_SMALL_MAX = 5; // <=5 feels like a skirmish
  const CORPSE_HORDE_MIN = 6; // >=6 feels like a horde
  const CORPSE_ENCOUNTER_GAP_MS = 2500; // combat separated by this time starts a new encounter
  let __corpseEncounter = { lastMs:0, variant:1, horde:false, estCount:0 };

  function __countNearbyMonsters(lvl, cx, cy, r=8){
    if(!lvl || !lvl.monsters) return 0;
    let n = 0;
    for(const mm of lvl.monsters.values()){
      if(!mm) continue;
      const dx = Math.abs((mm.x??0) - cx);
      const dy = Math.abs((mm.y??0) - cy);
      if(dx <= r && dy <= r) n++;
    }
    return n;
  }

  function touchCorpseEncounter(lvl){
    const now = performance.now();
    const p = lvl && lvl.player;
    const px = p ? p.x : 0, py = p ? p.y : 0;

    // Start a new encounter if enough time has passed since last combat touch
    if(!__corpseEncounter.lastMs || (now - __corpseEncounter.lastMs) > CORPSE_ENCOUNTER_GAP_MS){
      __corpseEncounter = { lastMs: now, variant: randInt(1, CORPSE_VARIANTS), horde:false, estCount:0 };
    } else {
      __corpseEncounter.lastMs = now;
    }

    // Estimate fight scale using nearby monster density at the time of contact.
    const near = __countNearbyMonsters(lvl, px, py, 8);
    __corpseEncounter.estCount = Math.max(__corpseEncounter.estCount||0, near);
    if(__corpseEncounter.estCount >= CORPSE_HORDE_MIN) __corpseEncounter.horde = true;

    return __corpseEncounter;
  }

  function pickCorpseVariantForThisDeath(lvl){
    const enc = touchCorpseEncounter(lvl);

    // Horde: coherent pattern for the whole fight.
    if(enc.horde) return enc.variant;

    // Skirmish: mostly coherent, sometimes mixed.
    // (This gives "some similarity" without looking tiled.)
    return (Math.random() < 0.65) ? enc.variant : randInt(1, CORPSE_VARIANTS);
  }


  // --- Encounter-structured corpse variants (Option B) ---
  // We want repetition to communicate quantity. For small fights, allow some variation.
  // For large/horde fights, unify the remains pattern across the whole encounter.
  let __encounterSeq = 1;
  function __countNearbyMonsters(lvl, cx, cy, r=8){
    if(!lvl || !lvl.monsters) return 0;
    let c = 0;
    for(const [kk, mm] of lvl.monsters.entries()){
      if(!mm) continue;
      const dx = Math.abs(mm.x - cx);
      const dy = Math.abs(mm.y - cy);
      if(dx <= r && dy <= r) c++;
    }
    return c;
  }
  function touchEncounter(lvl, cx, cy){
    const now = performance.now();
    if(!game.encounter || (now - (game.encounter.lastMs||0)) > 2500){
      game.encounter = { id: (__encounterSeq++), lastMs: now, baseVariant: randInt(1, CORPSE_VARIANTS), horde: false };
    }
    game.encounter.lastMs = now;
    // Decide horde-ness once it becomes true.
    if(!game.encounter.horde){
      const n = __countNearbyMonsters(lvl, cx, cy, 8);
      if(n >= 6) game.encounter.horde = true;
    }
    return game.encounter;
  }
  function pickCorpseVariantForEncounter(enc){
    if(!enc) return randInt(1, CORPSE_VARIANTS);
    if(enc.horde) return enc.baseVariant; // unified pattern
    // Small fights: biased random so you still get "counting" via similarity.
    return (Math.random() < 0.65) ? enc.baseVariant : randInt(1, CORPSE_VARIANTS);
  }


  function corpseFamilyGlyph(g){
    // Bosses can share the same remains pattern as their minions; color carries hierarchy.
    if(g === ENT.CYCLOPS_CHIEF) return ENT.CYCLOPS;
    return g;
  }
  function corpseVariantForFamily(fam){
    // Deterministic mapping: same family -> same corpse pattern (reinforces counting).
    const s = String(fam || "?");
    let h = 0;
    for(let i=0;i<s.length;i++) h = ((h<<5) - h + s.charCodeAt(i)) | 0;
    h = Math.abs(h);
    return (h % CORPSE_VARIANTS) + 1; // 1..5
  }
  function placeCorpse(lvl, x, y, variant, color){
    if(!lvl || !lvl.tiles || !lvl.tiles[x]) return;
    const t = lvl.tiles[x][y];
    // Only replace normal walkable ground (never overwrite stairs/doors/special tiles)
    if(!(t === TILE.FLOOR || t === TILE.CORR || t === TILE.CORPSE)) return;
    lvl.tiles[x][y] = TILE.CORPSE;
    if(!lvl.corpses) lvl.corpses = new Map();
    lvl.corpses.set(keyXY(x,y), { v: variant, color: color || COL.monster });
  }

  function playerAttack(lvl, mx, my){
    // Bridge combat isolation: block attacks across bridge boundary
    const _p = lvl.player;
    if(isBridgeAny(lvl, _p.x, _p.y) !== isBridgeAny(lvl, mx, my)){
      // Silent fail: the bridge separates you from what is below.
      return;
    }
    playSfx('attack');
    const __enc = touchCorpseEncounter(lvl);
    const k = keyXY(mx,my);
    const m = lvl.monsters.get(k);
    let dmg = randInt(1, game.atk);
    if(!game.weaponEquipped){
      dmg = Math.max(1, Math.floor(dmg/2));
    }
    m.hp -= dmg;
    logMsg(`Hit ${m.name} for ${dmg}.`);
    if(m.hp <= 0){
      // Visual-only death dissolve (one tile). We delete the monster immediately,
      // but the animation stores glyph+color so it can render independently.
      const __deathColor = (m && m.chaos) ? (COL.chaosRelic || "#c77dff") : ((m && m.color) ? m.color : ((typeof MONSTER_COLOR !== "undefined" && MONSTER_COLOR[m.glyph]) ? MONSTER_COLOR[m.glyph] : (COL?.monster || "#ff6b6b")));
      // Lock movement/combat inputs until the death dissolve completes (prevents render/cache races).
      try{ game.__lockInputUntil = (performance.now() + 705); }catch(_){ }
      startTileAnim(mx, my, "monster_death", 700, { glyph: m.glyph, color: __deathColor });

      // After the dissolve, leave behind persistent remains (non-blocking).
      // Step 1: prove variants work by simple per-kill randomization (no renderer changes).
      // (We can re-introduce Option B encounter coherence once this is stable.)
      const v = randInt(1, CORPSE_VARIANTS);

      setTimeout(() => {
  try{
    // Variant selection decided once per death.
    const v2 = randInt(1, 5);

    // Use the game's existing color logic for this monster (do not change palettes).
    // Prefer colorForEnt(m) if available; fall back to __deathColor.
    const corpseColor = (typeof colorForEnt === "function") ? (colorForEnt(m) || __deathColor) : __deathColor;

    placeCorpse(lvl, mx, my, v2, corpseColor);

    // Ensure corpse appears immediately after dissolve, without re-entrancy freezes.
    requestGlyphAnimFrame();
    setTimeout(() => { try{ renderScreen(); }catch(_e){} }, 0);
  }catch(_e){}
}, 700);

      lvl.monsters.delete(k);

      // Intercessor resolution: if the Intercessor falls, remaining faithful surrender.
      if(m && m.isIntercessor){
        const st = lvl && lvl.intercessorStage;
        if(st){ st.resolved = true; }
        // Pacify any remaining Supplicants from this rite.
        if(st && typeof st.packId !== 'undefined'){
          for(const [kk, mm] of lvl.monsters.entries()){
            if(mm && mm.packId === st.packId){
              mm.pacified = true;
              mm.guardIntercessor = false;
              mm.atk = 0;
            }
          }
        }
      }

      // Ambush resolution: if the Authority Node (Œ¶) falls, remaining bound agents (‚äó) dissolve.
      if(m && m.isAmbushBoss){
        const st = lvl && lvl.ambushStage;
        if(st){ st.resolved = true; }
        for(const [kk, mm] of lvl.monsters.entries()){
          if(mm && mm.isAmbushMinion) lvl.monsters.delete(kk);
        }
        logMsg("Your judgement has been served.");
      }

      // Chaos Relic reward check: drop only after all spawned monsters are dead
      if(lvl.pendingChaosReward && lvl.pendingChaosReward.monsters){
        // Track chaos kills by monster ID (monsters can move, so keys change)
        if(m && m.chaos && typeof m.chaosId !== "undefined") lvl.pendingChaosReward.monsters.delete(m.chaosId);
        if(lvl.pendingChaosReward.monsters.size === 0){
          logMsg("The cavern falls silent.");
          fireLoreOnce("cave_relic_silence", "Even echoes hold their breath.");

          // Guaranteed reward at relic location
          const rx = lvl.pendingChaosReward.x;
          const ry = lvl.pendingChaosReward.y;
          const rk = keyXY(rx, ry);

          const r = Math.random();
          if(r < 0.4) lvl.items.set(rk, { type: ENT.POTION });
          else if(r < 0.75) { game.gold += randInt(6,12) + Math.floor(game.depth/3); logMsg("You gather scattered coins."); }
          else lvl.items.set(rk, { type: ENT.WEAPON });

          lvl.pendingChaosReward = null;
        }
      }

      let bounty = randInt(1,4) + Math.floor(game.depth/4);
      if(m && m.isIntercessor) bounty = bounty * 3; // Intercessor pays out big (2‚Äì3x typical)
      game.gold += bounty;
      logMsg(`${m.name} falls. +${bounty} gold.`);
    }
  }

  function monstersAct(lvl){
  const p = lvl.player;
  const next = new Map(lvl.monsters);

  // Index packs (skeleton herds)
  const leaders = new Map();       // packId -> {k,m,x,y}
  const followers = [];            // {k,m,x,y}

  for(const [k, m] of lvl.monsters.entries()){
    if(m && m.packId){
      const pos = parseKey(k);
      if(m.packLeader && !leaders.has(m.packId)){
        leaders.set(m.packId, { k, m, x: pos.x, y: pos.y });
      } else {
        followers.push({ k, m, x: pos.x, y: pos.y });
        // If the pack has no explicit leader (older saves), first seen becomes leader
        if(!leaders.has(m.packId)){
          m.packLeader = true;
          leaders.set(m.packId, { k, m, x: pos.x, y: pos.y });
          followers.pop(); // reclassify this one as leader
        }
      }
    }
  }

  function packStretch(packId, lx, ly){
    let md = 0;
    for(const f of followers){
      if(f.m && f.m.packId === packId){
        const d = Math.max(Math.abs(f.x - lx), Math.abs(f.y - ly));
        if(d > md) md = d;
      }
    }
    return md;
  }

  // Helper: attempt to move monster from (x,y) by (dx,dy) respecting rules.
  function tryMove(k, m, x, y, dx, dy){
    const nx = x + dx, ny = y + dy;
    const nk = keyXY(nx,ny);
    if(nx<1||ny<1||nx>=MAP_W-1||ny>=MAP_H-1) return k;
    if(nx===p.x && ny===p.y) return k;
    if(next.has(nk)) return k;

    // Bridge boundary rule: you can only enter/exit bridge decking ':' via endpoints '[' and ']'.
    const t0 = lvl.tiles[x][y];
    const t1 = lvl.tiles[nx][ny];
    const a0 = (t0 === TILE.BRIDGE_L || t0 === TILE.BRIDGE_R || t0 === TILE.BRIDGE_SPAN);
    const a1 = (t1 === TILE.BRIDGE_L || t1 === TILE.BRIDGE_R || t1 === TILE.BRIDGE_SPAN);
    if(a0 !== a1){
      const e0 = (t0 === TILE.BRIDGE_L || t0 === TILE.BRIDGE_R);
      const e1 = (t1 === TILE.BRIDGE_L || t1 === TILE.BRIDGE_R);
      if(!(e0 || e1)) return k;
    }

    if(!tilePassable(lvl, nx, ny)) return k;

    // Slime slows monster movement (half speed)
    const curE = envAt(lvl, x, y);
    const nextE = envAt(lvl, nx, ny);
    const inSlime = (curE === 'slime' || nextE === 'slime');
    if(inSlime){
      if(!m._slimeWait){
        m._slimeWait = true;
        next.set(k, m); // stay put this turn
        return k;
      } else {
        m._slimeWait = false;
      }
    } else {
      m._slimeWait = false;
    }

    next.delete(k);
    next.set(nk, m);
    return nk;
  }

  function computeChaseOrWander(x,y, m){
    const dist = Math.max(Math.abs(p.x-x), Math.abs(p.y-y));
    const inSight = lvl.visible[x]?.[y] === true;
    const canChase = (!hasInvis());

    let dx=0, dy=0;

// Intercessor: stationary presence
if(m && m.immobile) return null;

  // Ambush minions (‚äó): wardens guard exits; compressors converge toward player.
  // They should NOT roam corridors; they stay inside their ambush room bounds.
  if(m && m.isAmbushMinion){
    const r = m.ambushRoom;
    const inRoom = (rr, X, Y) => !!(rr && X >= rr.x && X < rr.x+rr.w && Y >= rr.y && Y < rr.y+rr.h);

    // If we somehow got out of the room, drift back inward.
    if(r && !inRoom(r, x, y)){
      dx = clamp((r.cx||x) - x, -1, 1);
      dy = clamp((r.cy||y) - y, -1, 1);
      if(dx===0 && dy===0) return null;
      return {dx,dy, dist};
    }

    // Warden: go to assigned guard tile, then hold.
    if(m.ambushRole === 'warden' && typeof m.guardX === 'number' && typeof m.guardY === 'number'){
      const gx = m.guardX, gy = m.guardY;
      const dG = Math.max(Math.abs(gx-x), Math.abs(gy-y));
      if(dG > 0){
        dx = clamp(gx - x, -1, 1);
        dy = clamp(gy - y, -1, 1);
        // keep inside room bounds
        if(r && !inRoom(r, x+dx, y+dy)){
          dx = clamp((r.cx||x) - x, -1, 1);
          dy = clamp((r.cy||y) - y, -1, 1);
        }
        if(dx===0 && dy===0) return null;
        return {dx,dy, dist};
      }
      return null;
    }

    // Compressor: converge (simple chase) but stay in-room.
    if(inSight && canChase && dist <= 10){
      dx = clamp(p.x - x, -1, 1);
      dy = clamp(p.y - y, -1, 1);
      if(r && !inRoom(r, x+dx, y+dy)){
        // if step would leave room, bias inward
        dx = clamp((r.cx||x) - x, -1, 1);
        dy = clamp((r.cy||y) - y, -1, 1);
      }
      if(dx===0 && dy===0) return null;
      return {dx,dy, dist};
    }

    // Mild drift inward even when not chasing.
    if(r){
      dx = clamp((r.cx||x) - x, -1, 1);
      dy = clamp((r.cy||y) - y, -1, 1);
      if(dx===0 && dy===0) return null;
      return {dx,dy, dist};
    }
    return null;
  }

// Supplicants: defend the Intercessor. They become aggressive only near the anchor.
if(m && m.guardIntercessor){
  const ax = (typeof m.guardX === 'number') ? m.guardX : (lvl.intercessorStage ? lvl.intercessorStage.ix : x);
  const ay = (typeof m.guardY === 'number') ? m.guardY : (lvl.intercessorStage ? lvl.intercessorStage.iy : y);

  const distToAnchor = Math.max(Math.abs(ax - x), Math.abs(ay - y));
  const playerToAnchor = Math.max(Math.abs(ax - p.x), Math.abs(ay - p.y));

  // If player is threatening the anchor, move to intercept (pursue).
  if(inSight && canChase && playerToAnchor <= 6){
    dx = clamp(p.x - x, -1, 1);
    dy = clamp(p.y - y, -1, 1);
    if(dx===0 && dy===0) return null;
    return {dx,dy, dist};
  }

  // Otherwise, stay close to the anchor (tight ring) so the room feels guarded.
  if(distToAnchor > 2){
    dx = clamp(ax - x, -1, 1);
    dy = clamp(ay - y, -1, 1);
    if(dx===0 && dy===0) return null;
    return {dx,dy, dist};
  }

  // Close enough: small chance to reposition, otherwise hold.
  if(Math.random() < 0.55) return null;
  dx = randInt(-1,1);
  dy = randInt(-1,1);
  if(dx===0 && dy===0) return null;
  return {dx,dy, dist};
}


    // Skeleton packs: ambling herd AI (low aggression)
    if(m && m.packId){
      // Herd packs (Skeletons / Cyclops / Spiders / Wyrms): ambling herd AI with a touch of opportunistic pursuit.
      // Leaders act as "brains"; followers will be handled in phase 2 via pack cohesion.
      let pursueDist = 4, pursueChance = 0.18, pauseChance = 0.25, driftChance = 0.18, followChance = 0.60;

      // Slightly different "feel" per herd (still broadly skeleton-like)
      const g = m.glyph;
      if(g === ENT.CYCLOPS || g === ENT.CYCLOPS_CHIEF){
        pursueDist = 6; pursueChance = 0.26; pauseChance = 0.18; followChance = 0.62;
      } else if(g === ENT.SPIDER || g === ENT.SPIDER_QUEEN){
        pursueDist = 6; pursueChance = 0.24; pauseChance = 0.16; followChance = 0.64;
      } else if(g === ENT.WYRM || g === ENT.WYRM_ELDER){
        pursueDist = 7; pursueChance = 0.30; pauseChance = 0.12; followChance = 0.66;
      }

      const pursue = (inSight && canChase && dist <= pursueDist && Math.random() < pursueChance);

      if(pursue){
        dx = clamp(p.x - x, -1, 1);
        dy = clamp(p.y - y, -1, 1);
      } else {
        // Amble: keep a gentle "heading" that drifts over time.
        if(!m._herdDir || Math.random() < driftChance){
          m._herdDir = { dx: randInt(-1,1), dy: randInt(-1,1) };
          if(m._herdDir.dx===0 && m._herdDir.dy===0) m._herdDir.dx = 1;
        }

        // Pause chance (shamble feel)
        if(Math.random() < pauseChance) return null;

        // Follow heading, else random step
        if(Math.random() < followChance){
          dx = clamp(m._herdDir.dx, -1, 1);
          dy = clamp(m._herdDir.dy, -1, 1);
        } else {
          dx = randInt(-1,1);
          dy = randInt(-1,1);
        }
      }
    } else if(inSight && canChase && dist <= 8 && Math.random() < 0.65){
      dx = clamp(p.x - x, -1, 1);
      dy = clamp(p.y - y, -1, 1);
    } else if(Math.random() < 0.35){
      dx = randInt(-1,1);
      dy = randInt(-1,1);
    } else {
      return null;
    }
    if(dx===0 && dy===0) return null;
    return {dx,dy, dist};
  }

  // Phase 1: all non-skeletons + skeleton leaders move/attack (leaders act as brains)
  const leaderNewPos = new Map(); // packId -> {x,y,k}

  for(const [k, m] of lvl.monsters.entries()){
    const {x,y} = parseKey(k);
    if(m && m.pacified) continue;

    // Followers will be handled in phase 2
    if(m && m.packId && !m.packLeader) continue;

    // Skeleton pack cohesion: leader slows/waits if the herd is stretched
    if(m && m.packId && m.packLeader){
      const stretch = packStretch(m.packId, x, y);
      if(stretch >= 3) continue;
    }
    const dist = Math.max(Math.abs(p.x-x), Math.abs(p.y-y));
    if(dist === 1){
      // Bridge combat isolation: bridge separates combat layers (monsters)
      if(isBridgeAny(lvl, x, y) !== isBridgeAny(lvl, p.x, p.y)) continue;
      const dmg = randInt(1, m.atk);
      if(hasInvincible()){
        logMsg(`${m.name} strikes ‚Äî but it cannot harm you.`);
      } else {
        game.hp -= dmg;
        playSfx('damage');
        logMsg(`${m.name} hits for ${dmg}.`);
        if(game.hp <= 0){
          game.hp = 0;
          lvl.monsters = next;
          endGameLose();
          return;
        }
      }
      continue;
    }

    const step = computeChaseOrWander(x,y,m);
    if(!step) continue;

    const nk = tryMove(k, m, x, y, step.dx, step.dy);

    if(m && m.packId){
      const pos = parseKey(nk);
      leaderNewPos.set(m.packId, { x: pos.x, y: pos.y, k: nk });
    }
  }

  // Phase 2: skeleton followers move toward their leader, keeping a loose herd formation
  // Move farthest-first to reduce self-blocking
  followers.sort((a,b)=>{
    const la = leaderNewPos.get(a.m.packId) || leaders.get(a.m.packId);
    const lb = leaderNewPos.get(b.m.packId) || leaders.get(b.m.packId);
    const da = la ? Math.max(Math.abs(la.x-a.x), Math.abs(la.y-a.y)) : 0;
    const db = lb ? Math.max(Math.abs(lb.x-b.x), Math.abs(lb.y-b.y)) : 0;
    return db - da;
  });

  for(const f of followers){
    const m = f.m;
    const k = f.k;
    const x = f.x, y = f.y;

    // If follower is adjacent to player, it attacks as usual.
    const distP = Math.max(Math.abs(p.x-x), Math.abs(p.y-y));
    if(distP === 1){
      // Bridge combat isolation: bridge separates combat layers (followers)
      if(isBridgeAny(lvl, x, y) !== isBridgeAny(lvl, p.x, p.y)) continue;
      const dmg = randInt(1, m.atk);
      if(hasInvincible()){
        logMsg(`${m.name} strikes ‚Äî but it cannot harm you.`);
      } else {
        game.hp -= dmg;
        playSfx('damage');
        logMsg(`${m.name} hits for ${dmg}.`);
        if(game.hp <= 0){
          game.hp = 0;
          lvl.monsters = next;
          endGameLose();
          return;
        }
      }
      continue;
    }

    const lead = leaderNewPos.get(m.packId) || leaders.get(m.packId);
    if(!lead) continue;

    // Cohesion target: followers stay tight to the leader.
// If they drift too far, they *must* close distance (no jitter / no pausing).
const distL = Math.max(Math.abs(lead.x - x), Math.abs(lead.y - y));

let tx = lead.x, ty = lead.y;

if(distL <= 2){
  // close enough: occasional jitter & hesitation for a shambling herd feel
  if(Math.random() < 0.30) continue; // pause
  if(Math.random() < 0.35){
    tx += randInt(-1,1);
    ty += randInt(-1,1);
  }
}

const dx = clamp(tx - x, -1, 1);
const dy = clamp(ty - y, -1, 1);
if(dx===0 && dy===0) continue;

    // 15% chance to try a small flank step if direct step is blocked
    let moved = false;
    const attempted = [{dx,dy}];
    if(Math.random() < 0.15){
      attempted.push({dx,dy:0});
      attempted.push({dx:0,dy});
      attempted.push({dx:-dy,dy:dx});
      attempted.push({dx:dy,dy:-dx});
    }

    for(const a of attempted){
      const beforeSize = next.size;
      const nk = tryMove(k, m, x, y, a.dx, a.dy);
      if(nk !== k || next.size !== beforeSize){
        moved = (nk !== k);
        break;
      }
    }
    if(!moved){
      // stay put
    }
  }

  lvl.monsters = next;
}

  function openDoorIfPresent(lvl, x, y){
    const t = lvl.tiles[x][y];

    if(t === TILE.DOOR_C){
      setTileWithAnim(lvl, x, y, TILE.DOOR_O, "open");
      if(!lvl.openedDoorMsgShown){ logMsg("Opened a door."); lvl.openedDoorMsgShown = true; }
      return true;
    }

    if(t === TILE.LDOOR_C){
      if(hasTransmute()){
        logMsg("You phase through the locked door.");
        return false;
      }

      if(game.inv.keys <= 0){
        if(LOCKED_DOOR_BREAKS_WITHOUT_KEY){
          setTileWithAnim(lvl, x, y, TILE.LDOOR_O, "forced_open");
          if(hasInvincible()){
            logMsg("No key ‚Äî forced the lock. It shatters harmlessly.");
          } else if(LOCK_BREAK_DAMAGE > 0){
            game.hp -= LOCK_BREAK_DAMAGE;
            logMsg(`No key ‚Äî forced the lock. Door breaks open! (-${LOCK_BREAK_DAMAGE} HP)`);
            if(game.hp <= 0){
              game.hp = 0;
              endGameLose();
              return true;
            }
          } else {
            logMsg("No key ‚Äî forced the lock. Door breaks open!");
          }
        } else {
          logMsg("Locked. A key is needed.");
          try{ startTileAnim(x, y, "locked_bump", 1200); startTileAnim(x, y, "spark", 700); }catch(_){}
        }
        return true;
      }

      game.inv.keys--;
      setTileWithAnim(lvl, x, y, TILE.LDOOR_O, "forced_open");
      logMsg("Unlocked and opened the door.");
      return true;
    }

    if(t === TILE.SD_C){
      setTileWithAnim(lvl, x, y, TILE.SD_O, "secret_open");
      logMsg("Opened a secret door.");
      return true;
    }

    if(t === TILE.CAVE_C){
      setTileWithAnim(lvl, x, y, TILE.CAVE_O, "secret_open");
      logMsg("The damp darkness closes around you.");
      return true;
    }

    return false;
  }

  const DIRS = {
    'w':[0,-1], 'a':[-1,0], 's':[0,1], 'd':[1,0],
    'q':[-1,-1], 'e':[1,-1], 'z':[-1,1], 'c':[1,1],
    '.':[0,0]
  };

  function tryMove(dx, dy){
    if(game.ended) return;

    // Lore cooldown ticks once per player action (move or wait)
    tickLoreCooldown();

    const lvl = getLevel(game.depth);
    const p = lvl.player;
    const wasInCave = (p.y >= CAVE_Y0);
    const prev = {x:p.x, y:p.y};
    if(dx===0 && dy===0){
      playSfx('wait');
    monstersAct(lvl);

      // Rest heal: +0.25 HP per wait turn, capped at 3 HP healed per level
      const REST_CAP = 3;
      game.restHealedThisLevel = game.restHealedThisLevel || 0;

      if(game.hp < game.hpMax && game.restHealedThisLevel < REST_CAP){
        game.restFrac = (game.restFrac || 0) + 0.25;

        // Only allow healing up to remaining cap
        const remaining = REST_CAP - game.restHealedThisLevel;
        const gainRaw = Math.floor(game.restFrac);
        const gain = Math.min(remaining, gainRaw);

        if(gain > 0){
          game.hp = Math.min(game.hpMax, game.hp + gain);
          game.restHealedThisLevel += gain;
          game.restFrac = game.restFrac - gain;
          logMsg("Resting, you healed for 1HP");
        }

        if(game.restHealedThisLevel >= REST_CAP){
          game.restFrac = 0;
          if(!game.restCapMsgShown){
            logMsg("You feel no further benefit from resting here.");
            game.restCapMsgShown = true;
          }
        }
      } else {
        // No benefit (either full HP or cap reached)
        game.restFrac = 0;
        if(game.restHealedThisLevel >= REST_CAP && !game.restCapMsgShown){
          logMsg("You feel no further benefit from resting here.");
          game.restCapMsgShown = true;
        }
      }

      // Chaos Relic proximity warning (adjacent, once per relic)
      for(let dx2=-1; dx2<=1; dx2++){
        for(let dy2=-1; dy2<=1; dy2++){
          if(!dx2 && !dy2) continue;
          const ax = p.x + dx2;
          const ay = p.y + dy2;
          if(ax<0||ay<0||ax>=MAP_W||ay>=MAP_H) continue;

          const kk = keyXY(ax, ay);
          const it = lvl.items.get(kk);
          if(it && it.type === 'A'){
            const id = ax + "," + ay;
            if(!lvl.chaosRelicWarned.has(id)){
              logMsg("You feel you are being watched.");
              lvl.chaosRelicWarned.add(id);
            }
          }
        }
      }

      computeFov(lvl);
      dangerLoreTick(lvl);
      renderAll();
      return;
    }

    const nx = p.x + dx, ny = p.y + dy;
    if(nx<0||ny<0||nx>=MAP_W||ny>=MAP_H){ playSfx('bump'); return; }

    if(dx!==0 && dy!==0){
      const ok1 = tilePassable(lvl, p.x+dx, p.y);
      const ok2 = tilePassable(lvl, p.x, p.y+dy);
      if(!ok1 && !ok2){ playSfx('bump'); return; }
    }

    // Bridge boundary rule: you can only enter/exit bridge decking ':' via endpoints '[' and ']'.
    {
      const t0 = lvl.tiles[p.x][p.y];
      const t1 = lvl.tiles[nx][ny];
      const a0 = (t0 === TILE.BRIDGE_L || t0 === TILE.BRIDGE_R || t0 === TILE.BRIDGE_SPAN);
      const a1 = (t1 === TILE.BRIDGE_L || t1 === TILE.BRIDGE_R || t1 === TILE.BRIDGE_SPAN);
      if(a0 !== a1){
        const e0 = (t0 === TILE.BRIDGE_L || t0 === TILE.BRIDGE_R);
        const e1 = (t1 === TILE.BRIDGE_L || t1 === TILE.BRIDGE_R);
        if(!(e0 || e1)){ playSfx('bump'); return; }
      }
    }

    const mk = keyXY(nx,ny);

    if(lvl.monsters.has(mk)){
      // Bridge disadvantage: engaging on a bridge lets the defender act first.
      // (This prevents bridges from becoming player-favored hallway chokepoints.)
      if(isBridgeAny(lvl, p.x, p.y) && isBridgeAny(lvl, nx, ny)){
        const _m = lvl.monsters.get(mk);
        if(_m && !_m.pacified){
          const _dmg = randInt(1, _m.atk);
          if(hasInvincible()){
            logMsg(`${_m.name} strikes ‚Äî but it cannot harm you.`);
          } else {
            game.hp -= _dmg;
            playSfx('damage');
            logMsg(`${_m.name} hits for ${_dmg}.`);
            if(game.hp <= 0){
              game.hp = 0;
              endGameLose();
              return;
            }
          }
        }
      }

      musicMaybeTrigger('monsterEncounter');
      playerAttack(lvl, nx, ny);
      monstersAct(lvl);
      computeFov(lvl);
      dangerLoreTick(lvl);
      renderAll();
      return;
    }

    const doorT = lvl.tiles[nx][ny];

    // Cave entrance behaves like a door, but you step "into" it: discovered o -> opened O, then move onto it
    if(doorT === TILE.CAVE_C){
      setTileWithAnim(lvl, nx, ny, TILE.CAVE_O, "secret_open");
      logMsg("The damp darkness closes around you.");
      // Do not return; allow movement into the opened entrance this same turn.
    }

    const isDoorTile = (doorT === TILE.DOOR_C || doorT === TILE.SD_C || doorT === TILE.LDOOR_C);
    if(isDoorTile){
      const consumed = openDoorIfPresent(lvl, nx, ny);
      if(consumed){
        monstersAct(lvl);
        computeFov(lvl);
        renderAll();
        return;
      }
    }

    if(!tilePassable(lvl, nx, ny)){
      // BAD Furniture lore on contact (once per type per run)
      if(lvl.furnT && lvl.furnT[nx] && lvl.furnT[nx][ny]){
        const ft = lvl.furnT[nx][ny];
        if(ft === 'throne') fireLoreOnce('lore_furn_throne', 'The throne remains, but its burden does not.');
        else if(ft === 'library') fireLoreOnce('lore_furn_library', 'The pages crumble before their meaning can.');
        else if(ft === 'dais') fireLoreOnce('lore_furn_dais', 'The floor remembers a weight it no longer bears.');
        else if(ft === 'void') fireLoreOnce('lore_furn_void', 'Something once gathered here.');
        else if(ft === 'statue') fireLoreOnce('lore_furn_statue', 'Someone thought this needed witnesses.');
      }
      playSfx('bump');
      return;
    }

    // Slime slows movement: first keypress consumes a step without moving.
    const curEnv = envAt(lvl, p.x, p.y);
    const nextEnv = envAt(lvl, nx, ny);
    const inSlimeMove = (curEnv === 'slime' || nextEnv === 'slime');
    if(inSlimeMove){
      if(!game.slimeWait){
        game.slimeWait = true;
        logMsg("Slime slows your passage.");
        advanceTorchOnMove();
        tickEffectsOnStep();
        if(game.ended) { renderAll(true); return; }
        monstersAct(lvl);
        computeFov(lvl);
        renderAll();
        return;
      } else {
        game.slimeWait = false;
      }
    } else {
      game.slimeWait = false;
    }

    // Corpse Saturation (BAD): stepping onto a corpse slows movement like slime.
    // Derived at move-time only. No draw-time changes. Enemies are NOT slowed.
    const steppingOnCorpse = (lvl.tiles[nx][ny] === TILE.CORPSE);

    if(steppingOnCorpse){
      if(!game.corpseWait){
        game.corpseWait = true;

        // One lore message per tier per floor (no spam). Field can still appear later.
        // Less conservative: count corpses in a 5√ó5 area (radius 2) around the step target.
        let local = 0;
        for(let ox=-2; ox<=2; ox++){
        for(let oy=-2; oy<=2; oy++){
            if(ox===0 && oy===0) continue;
            const xx = nx + ox, yy = ny + oy;
            if(xx<0||yy<0||xx>=MAP_W||yy>=MAP_H) continue;
            if(lvl.tiles[xx][yy] === TILE.CORPSE) local++;
        }
        }

        // Tier B first (cluster)
        if(local >= 4){
        if(!game.corpseFieldLoreShown){
            logMsg("You slog slowly through the corpse field, surrounded by the stench ‚Äî and the satisfaction ‚Äî of what you left behind.");
            game.corpseFieldLoreShown = true;
        }
        } else {
        // Tier A (single/sparse)
        if(!game.corpseTripLoreShown){
            logMsg("You stammer for balance, nearly tripping over the fallen corpse.");
            game.corpseTripLoreShown = true;
        }
        }

        // Mirror slime's "first keypress consumes a step without moving"
        advanceTorchOnMove();
        tickEffectsOnStep();
        if(game.ended) { renderAll(true); return; }
        monstersAct(lvl);
        computeFov(lvl);
        //dangerLoreTick(lvl); REMOVED 
        renderAll();
        return;
      } else {
        game.corpseWait = false;
      }
    } else {
    game.corpseWait = false;
  }

p.x = nx; p.y = ny;

// Blackout room enter message + clear any remembered tiles in that room so it renders as void once you leave.
const __wasInBlackout = lvlIsInBlackoutRoom(lvl, prev.x, prev.y);
const __nowInBlackout = lvlIsInBlackoutRoom(lvl, p.x, p.y);
if(!__wasInBlackout && __nowInBlackout){
  const __rc = lvlBlackoutOuterRectAt(lvl, p.x, p.y);
  clearSeenInRect(lvl, __rc);
  logMsg("Not even your torch dispels the darkness lurking here.");
}
    // Contaminated Gold consequence: if a transaction spent any blood-gold at this trader,
    // the trader will scurry away once you step off their tile.
    const __prevTraderKey = keyXY(prev.x, prev.y);
    const __nowTraderKey = keyXY(p.x, p.y);
    const __prevOnTrader = (lvl.traders && lvl.traders.has(__prevTraderKey));
    const __nowOnTrader  = (lvl.traders && lvl.traders.has(__nowTraderKey));
    if(__prevOnTrader && !__nowOnTrader && lvl.traderScurry && lvl.traderScurry.has(__prevTraderKey)){
      lvl.traderScurry.delete(__prevTraderKey);
      lvl.traders.delete(__prevTraderKey);
      logMsg("The trader avoids your eyes and scurries away.");
    }

    // Intercessor Stage (v1): lore + optional awakening on deliberate engagement.
    intercessorStageCheckOnPlayerStep(lvl, prev.x, prev.y, p.x, p.y);
    // Ambush Stage (latent): empty-room eruption when player commits to center region.
    ambushStageCheckOnPlayerStep(lvl, prev.x, prev.y, p.x, p.y);
    const nowInCave = (p.y >= CAVE_Y0);
    if(!wasInCave && nowInCave){ onEnterCaves(); fireLoreOnce(`cave_enter_${game.depth}`, "The world narrows. Your torch becomes a small argument."); }
    if(wasInCave && !nowInCave) onExitCaves();
    playSfx('step');

    musicUserActivity();

    // Roaming ambience (situational, probabilistic)
    musicMaybeTrigger('roam');

    applyEnvironmentOnEnter(lvl, prev.x, prev.y, p.x, p.y);
    if(game.ended) { renderAll(true); return; }

    advanceTorchOnMove();
    tickEffectsOnStep();
    if(game.ended) { renderAll(true); return; }


    // ---------- CAVE LORE: paced beats on movement (stacked with normal messages) ----------
    if(isInCaves(p.y)){
      lvl.caveLoreState = lvl.caveLoreState || { steps:0, illumSteps:0 };
      lvl.caveLoreState.steps++;
      // After ~10 steps in caves on this level: a single authored beat.
      if(lvl.caveLoreState.steps === 10){
        fireLoreOnce(`cave_footsteps_${game.depth}`, 'Your footsteps find a rhythm the cave already knows.');
      }

      // If Illumination is active in caves (static light anchors), drip a rare pulse.
      const illumActive = !!(lvl.staticLights && lvl.staticLights.length);
      if(illumActive){
        lvl.caveLoreState.illumSteps++;
        if(lvl.caveLoreState.illumSteps % 10 === 0){
          fireLoreRepeat('The dark yields ground, but not allegiance.');
        }
      }
    }

    tryRevealAdjacentSecretDoors(lvl);
    tryRevealAdjacentCaveEntrances(lvl);

    // Traps
    if(lvl.traps.has(mk)){
      const tr = lvl.traps.get(mk);
      tr.revealed = true;

      if(hasInvincible()){
        logMsg("A trap triggers ‚Äî but you are invincible.");
      } else if(hasTransmute()){
        logMsg("You float over the trap unharmed.");
      } else {
        game.hp -= tr.dmg;
        playSfx('damage');
        logMsg(`A trap springs! Took ${tr.dmg} damage.`);
        if(game.hp <= 0){
          game.hp = 0;
          endGameLose();
          return;
        }
      }
    }

    // Items
    if(lvl.items.has(mk)){
      const it = lvl.items.get(mk);
      // Chaos Relic: standing on it shows an offer in the prompt strip; press Y to trigger.
      if(it.type === 'A'){
        // Do not auto-consume; no modal; monsters still get their turn.
        fireLoreOnce('lore_relic', 'Something ancient seeks an audience.');
      }

      if(it.type === ENT.POTION){
        if(game.inv.potions.length >= POTION_CAP){
          logMsg(`Potion satchel full (cap ${POTION_CAP}). Left potion behind.`);
        } else {
          game.inv.potions.push(it.potion || POTION.HEAL);
          playSfx('pickup');
          logMsg(`Picked up a ${POTION_NAME[it.potion || POTION.HEAL]} potion (!).`);
          lvl.items.delete(mk);
        }
      }
      else if(SCROLL_COLOR[it.type]){ // scroll glyph item (auto-read on pickup)
        playSfx('pickup');
        const nm = SCROLL_NAME[it.type] || 'Mystery';
        if(it.type === "‚òº"){ // Illumination
          // In caves, Illumination creates a stationary glow (anchor light) until level change.
          const px = lvl.player.x, py = lvl.player.y;
          const inCave = (it.caveIllum === true) || (lvl.cave && lvl.cave[px][py]);
          if(inCave){
            lvl.staticLights = lvl.staticLights || [];
            lvl.staticLights.push({ x: px, y: py, r: VISION_DEFAULT });
            logMsg("You unfurl the scroll of Illumination. A steady glow fills the cavern.");
            fireLoreOnce(`cave_illum_${game.depth}`, "Light persists where light should not.");
          } else {
            revealEntireLevel(lvl);
            logMsg("You unfurl the scroll of Illumination. The entire level is revealed!");
          }
        }
        else if(it.type === "¬§"){ // Diminution
          game.effects.invis = Infinity;
          logMsg("You unfurl the scroll of Diminution. Your form fades from sight.");
        }
        else if(it.type === "‚ñ≤"){ // Grounding (curse)
          game.effects.grounding = true;
          logMsg("You unfurl the scroll of Grounding. All monsters grow stronger!");
        }
        else if(it.type === "Œ®"){ // Attunement
          let found = false;
          for(const [k,v] of lvl.items){
            if(v.type === "¬•"){ // vitality shrine glyph
              game.seen.add(k);
              found = true;
            }
          }
          if(found){
            logMsg("You unfurl the scroll of Attunement. A distant shrine reveals itself.");
          } else {
            logMsg("You unfurl the scroll of Attunement. The dungeon remains silent.");
          }
        }
        else {
          logMsg(`You unfurl the scroll of ${nm}‚Ä¶ its magic is not yet bound.`);
        }
        lvl.items.delete(mk);
      }

else if(it.type === ENT.CHEST){
        const gold = it.gold || 0;
        const cgold = it.cgold || 0;
        game.gold += (gold + cgold);
        game.cgold += cgold;

        const foundKeys = it.keys || 0;
        if(foundKeys > 0){
          const space = KEY_CAP - game.inv.keys;
          const take = Math.max(0, Math.min(space, foundKeys));
          game.inv.keys += take;

          if(take === foundKeys){
            logMsg(`Opened a chest: +${gold + cgold} gold and +${take} keys.${cgold>0 ? ' Some of the coin is stained.' : ''}`);
          } else {
            const left = foundKeys - take;
            logMsg(`Opened a chest: +${gold + cgold} gold and +${take} keys (key ring full; ${left} left behind).${cgold>0 ? ' Some of the coin is stained.' : ''}`);
          }
        } else {
          logMsg(`Found treasure ($): +${gold + cgold} gold.${cgold>0 ? ' Some of the coin is stained.' : ''}`);
        }
        playSfx('pickup');
        lvl.items.delete(mk);
      } else if(it.type === ENT.WEAPON){
        game.atk = Math.max(game.atk, it.atk);
        game.weaponName = it.name;
        playSfx('pickup');
        const _hadWeapon = game.weaponEquipped;
        game.weaponEquipped = true;
// Lore: weapon acquisition / upgrades (run-persistent)
if(!_hadWeapon){
  fireLoreOnce('weapon_first', 'Cold steel settles into your warm hand.');
} else if(game.weaponUpgradeCount === 0){
  fireLoreOnce('weapon_up1', 'Metal, smoke, and iron shape its soul.');
} else {
  fireLoreRepeat('Anger and hunger ripple through steel.');
}
if(_hadWeapon) game.weaponUpgradeCount++;

        logMsg(`Weapon found (∆™): ${it.name} (ATK ${it.atk}).`);
        lvl.items.delete(mk);
      } else if(it.type === ENT.TORCH){
        const cnt = it.count || 1;
        const space = TORCH_CAP - game.inv.torches;
        const take = Math.max(0, Math.min(space, cnt));

        if(take <= 0){
          logMsg(`Torch pack full (cap ${TORCH_CAP}). Left torch behind.`);
        } else {
          game.inv.torches += take;
          logMsg(take === 1 ? "Picked up a torch (t)." : `Picked up ${take} torches (t).`);

          if(take >= cnt){
            lvl.items.delete(mk);
          } else {
            it.count = cnt - take;
            lvl.items.set(mk, it);
          }

          if(!game.torch.lit && game.torch.radius === VISION_DARK){
            maybeAutoLightTorch();
          }
        }
      } else if(it.type === ENT.SHRINE){
        // Shrine: standing on it shows an offer in the prompt strip; press Y to use.
      } else if(it.type === "__LOOSE_KEY__"){
        if(game.inv.keys >= KEY_CAP){
          logMsg(`Key ring full (cap ${KEY_CAP}). Left key behind.`);
        } else {
          game.inv.keys++;
          playSfx('pickup');
          logMsg("Picked up a key.");
          lvl.items.delete(mk);
        }
      }
    }
    monstersAct(lvl);
    computeFov(lvl);
    dangerLoreTick(lvl);
    renderAll();
  }
  // end function tryMove()

  function tryDescend(){
    if(game.ended) return;

    const lvl = getLevel(game.depth);
    const {x,y} = lvl.player;
    const t = lvl.tiles[x][y];

    if(!(t === TILE.DOWN || t === TILE.SDOWN)){
      logMsg("No stairs here.");
      renderAll();
      return;
    }

    if(game.depth === 20){
      endGameWin();
      return;
    }

    const nextDepth = game.depth + 1;
    loadLevel(nextDepth);
    playSfx('descend');
    playSfx('descend');

    // Music: descending interlude
    musicMaybeTrigger('descend', true);

    logMsg(t === TILE.SDOWN
      ? `Secret shortcut! Dropped to level ${String(nextDepth).padStart(2,'0')}.`
      : `Descended to level ${String(nextDepth).padStart(2,'0')}.`
    );
    // Lore (additive): secret shortcut descent should feel ominous, not lucky.
    if(t === TILE.SDOWN){
      fireLoreOnce('secret_shortcut_stair', "Dare you risk the crumbling stair?");
    }


    const heal = randInt(1,3);
    game.hp = Math.min(game.hpMax, game.hp + heal);
    renderAll();
  }

  function drinkHealingPotion(){
    if(game.ended) return;

    // Prevent wasting healing when already at full HP.
    if(game.hp >= game.hpMax){
      logMsg("HP is already full.");
      renderAll();
      return;
    }

    if(!consumePotionByType(POTION.HEAL)){
      logMsg("No healing potions.");
      renderAll();
      return;
    }

    playSfx('drink');

    const heal = randInt(POTION_HEAL_RANGE[0], POTION_HEAL_RANGE[1]);
    game.hp = Math.min(game.hpMax, game.hp + heal);
    logMsg(`Drank Healing (purple). +${heal} HP.`);
    renderAll();
  }

  function drinkPotionType(type){
    if(game.ended) return;

    if(!consumePotionByType(type)){
      logMsg(`No ${POTION_NAME[type]} potions.`);
      renderAll();
      return;
    }

    playSfx('drink');

    if(type === POTION.POISON){
      game.effects.poison = Math.max(game.effects.poison, POISON_STEPS);
      logMsg(`Drank Poison (green). ${POISON_STEPS} steps of sickness!`);
      renderAll();
      return;
    }

    if(type === POTION.INVIS){
      game.effects.invis = Math.max(game.effects.invis, INVIS_STEPS);
      logMsg(`Drank Invisibility (grey). Monsters lose your scent (${INVIS_STEPS}).`);
      renderAll();
      return;
    }

    if(type === POTION.TRANSMUTE){
      game.effects.transmute = Math.max(game.effects.transmute, TRANSMUTE_STEPS);
      logMsg(`Drank Transmutation (ochre). You float & phase (${TRANSMUTE_STEPS}).`);
      renderAll();
      return;
    }

    if(type === POTION.INVINC){
      game.effects.invincible = Math.max(game.effects.invincible, INVINCIBLE_STEPS);
      logMsg(`Drank Invincibility (red). Nothing can harm you (${INVINCIBLE_STEPS}).`);
      renderAll();
      return;
    }

    if (type === POTION.TELE) {
        const lvl = getLevel(game.depth);
        const pos = findRandomOpenTile(lvl);

        lvl.player.x = pos.x;
        lvl.player.y = pos.y;

        logMsg(`Your body tingles as you are transported to an unknown location.`);

        computeFov(lvl);
        renderAll();
        return;
    }

    logMsg("Drank a strange potion‚Ä¶ nothing happens.");
    renderAll();
  }

  
  // ---------- RENDERING ----------
  function spanChar(ch, color, dim=false, mx=null, my=null, meta=null){
    // Glyph-only override: show skull icon in canvas mode, ASCII-safe ¬ß in DOM mode
    if(!window.SAFE_MODE && ch === ENT.SKELETON) { ch = '‚ò†'; }
    // capture for canvas renderer
    if(window.__capCells){ window.__capCells.push(Object.assign({ch, color, dim: !!dim, x: mx, y: my}, meta||{})); }
const safe = ch === ' ' ? '&nbsp;' : escapeHtml(ch);
    const cls = dim ? ' class="dim"' : '';
    return `<span style="color:${color}"${cls}>${safe}</span>`;
  }

  function baseColorFor(lvl, x, y, glyph){
    if(glyph === '+' || glyph === '‚Äì' || glyph === '|') return COL.wall;
    const t = lvl.tiles[x][y];
    if(t === TILE.FLOOR) return COL.floor;
    if(t === TILE.CORR) return COL.corr;
    if(t === TILE.DOOR_C || t === TILE.DOOR_O) return COL.door;
    if(t === TILE.LDOOR_C) return COL.locked;
    if(t === TILE.SD_C || t === TILE.SD_O) return COL.sdoor;
    if(t === TILE.DOWN) return COL.stairs;
    if(t === TILE.SDOWN) return COL.shortcut;
    if(t === TILE.BRIDGE_SPAN) return COL.corr;
    if(t === TILE.BRIDGE_L || t === TILE.BRIDGE_R) return COL.wall;
    return COL.rock;
  }

  function colorForEntity(it){
    if(it.type === ENT.CHEST) return COL.chest;
    if(it.type === ENT.WEAPON) return COL.weapon;
    if(it.type === ENT.TORCH) return COL.torch;
    if(it.type === ENT.SHRINE) return COL.shrine;
    if(it.type === ENT.POTION) return POTION_COLOR[it.potion || POTION.HEAL] || COL.potion_purple;
    return COL.fg;
  }

  function isPassableTerrainForWalls(lvl, x, y){
    if(x<0||y<0||x>=MAP_W||y>=MAP_H) return false;
    const t = lvl.tiles[x][y];
    return (
      t === TILE.FLOOR || t === TILE.CORR ||
      t === TILE.DOOR_C || t === TILE.DOOR_O ||
      t === TILE.LDOOR_C || t === TILE.LDOOR_O ||
      t === TILE.SD_C || t === TILE.SD_O ||
          t === TILE.CAVE_C || t === TILE.CAVE_O ||
          t === TILE.DOWN || t === TILE.SDOWN
    );
  }

  function drawWallGlyph(lvl, x, y){
    const t = lvl.tiles[x][y];
    if(t !== TILE.ROCK) return null;

    const passN = isPassableTerrainForWalls(lvl, x, y-1);
    const passS = isPassableTerrainForWalls(lvl, x, y+1);
    const passW = isPassableTerrainForWalls(lvl, x-1, y);
    const passE = isPassableTerrainForWalls(lvl, x+1, y);

    const anyAdj = passN || passS || passW || passE;
    if(!anyAdj) return ' ';

    const vert = (passW || passE);
    const horiz = (passN || passS);

    if(vert && horiz) return '+';
    if(vert) return '|';
    if(horiz) return '‚Äì';
    return ' ';
  }

  // Cave rendering mask: cave floors are dots; walls remain invisible.
  // lvl.cave[x][y] marks carved cave floor tiles. We expand to adjacent rock so we can hide cave "walls" too.
  function isCaveMaskCell(lvl, x, y){
    if(!lvl || !lvl.cave) return false;
    if(x<0||y<0||x>=MAP_W||y>=MAP_H) return false;
    if(lvl.cave[x][y]) return true;
    if(lvl.tiles[x][y] !== TILE.ROCK) return false;
    for(let dx=-1; dx<=1; dx++){
      for(let dy=-1; dy<=1; dy++){
        const nx = x+dx, ny = y+dy;
        if(nx<0||ny<0||nx>=MAP_W||ny>=MAP_H) continue;
        if(lvl.cave[nx][ny]) return true;
      }
    }
    return false;
  }

  function torchHudText(){
    const r = currentVisionRadius();
    if(!game.torch.lit) return `Dark (${r})`;
    if(game.torch.burnLeft > 0) return `Burn ${r} ¬∑ ${game.torch.burnLeft}`;
    const stepsLeft = Math.max(0, (r - VISION_DARK));
    return `Dim ${r} ¬∑ ${stepsLeft}`;
  }

  function renderHud(freeze=false){
    const lvl = getLevel(game.depth);
    const depthStr = `${String(game.depth).padStart(2,'0')}/${String(game.maxDepth).padStart(2,'0')}`;
    const potionByType = countPotionsByType();
    const potionCount = game.inv.potions.length;

    const potBits = [];
    if(potionByType[POTION.HEAL] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.HEAL]};"><b>H</b>${potionByType[POTION.HEAL]}</span>`);
    if(potionByType[POTION.POISON] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.POISON]};"><b>P</b>${potionByType[POTION.POISON]}</span>`);
    if(potionByType[POTION.INVIS] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.INVIS]};"><b>I</b>${potionByType[POTION.INVIS]}</span>`);
    if(potionByType[POTION.TRANSMUTE] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.TRANSMUTE]};"><b>X</b>${potionByType[POTION.TRANSMUTE]}</span>`);
    if(potionByType[POTION.INVINC] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.INVINC]};"><b>V</b>${potionByType[POTION.INVINC]}</span>`);
    if(potionByType[POTION.TELE] > 0) potBits.push(`<span style="color:${POTION_COLOR[POTION.TELE]};"><b>E</b>${potionByType[POTION.TELE]}</span>`);

    // Drink mapping in this build:
    // P = Heal, 0=Poison, 1=Invis, 2=Trans, 3=Invinc, 4=Tele
    const potPills = [
      `<span class="pill" style="border-color:${POTION_COLOR[POTION.POISON]};color:${POTION_COLOR[POTION.POISON]};"><b>0</b> Poison</span>`,
      `<span class="pill" style="border-color:${POTION_COLOR[POTION.INVIS]};color:${POTION_COLOR[POTION.INVIS]};"><b>1</b> Invis</span>`,
      `<span class="pill" style="border-color:${POTION_COLOR[POTION.TRANSMUTE]};color:${POTION_COLOR[POTION.TRANSMUTE]};"><b>2</b> Trans</span>`,
      `<span class="pill" style="border-color:${POTION_COLOR[POTION.INVINC]};color:${POTION_COLOR[POTION.INVINC]};"><b>3</b> Invinc</span>`,
      `<span class="pill" style="border-color:${POTION_COLOR[POTION.TELE]};color:${POTION_COLOR[POTION.TELE]};"><b>4</b> Tele</span>`
    ];

    const effects = [];
    if(game.effects.poison > 0) effects.push(`<span class="tag" style="border-color:${POTION_COLOR[POTION.POISON]};color:${POTION_COLOR[POTION.POISON]};">POISON ${game.effects.poison}</span>`);
    if(game.effects.invis > 0) effects.push(`<span class="tag" style="border-color:${POTION_COLOR[POTION.INVIS]};color:${POTION_COLOR[POTION.INVIS]};">INVIS ${game.effects.invis}</span>`);
    if(game.effects.transmute > 0) effects.push(`<span class="tag" style="border-color:${POTION_COLOR[POTION.TRANSMUTE]};color:${POTION_COLOR[POTION.TRANSMUTE]};">TRANS ${game.effects.transmute}</span>`);
    if(game.effects.invincible > 0) effects.push(`<span class="tag" style="border-color:${POTION_COLOR[POTION.INVINC]};color:${POTION_COLOR[POTION.INVINC]};">INVINC ${game.effects.invincible}</span>`);

    $hud.innerHTML = `
      <span class="hud-item muted"><b>HP</b> ${game.hp}/${game.hpMax}</span>
      <span class="hud-item muted">[P] Heal</span>
      <span class="hud-item muted"><img class="hud-ico" src="/images/icons/potion_18.png" alt="Potions" title="Potion" /> <b>${potionCount}</b>/<b>${POTION_CAP}</b>${potBits.length ? ` ${potBits.join(' ')}` : ``}</span>
      <span class="hud-item muted"><img class="hud-ico" src="/images/icons/torch_18.png" alt="Torch" title="Torch" /> <b>${game.inv.torches}</b>/<b>${TORCH_CAP}</b></span>
      <span class="hud-item muted"><img class="hud-ico" src="/images/icons/${escapeHtml(game.weaponName)==='Bare Hands' ? 'fist_18.png' : 'sword_18.png'}" alt="Weapon" title="Weapon" /> <b>${game.atk}</b> (${escapeHtml(game.weaponName)})</span>
      <span class="hud-item muted"><img class="hud-ico" src="/images/icons/chest_18.png" alt="Gold" title="Chest" /> <b>${game.gold}</b></span>
      <span class="hud-item muted"><img class="hud-ico" src="/images/icons/key_18.png" alt="Keys" title="Key" /> <b>${game.inv.keys}</b></span>
      <span class="hud-item muted">Lvl <b>${depthStr}</b></span>

      ${DEBUG ? `
        <div class="hud-debug">
          <span><b>DEBUG</b></span>
          <span>Depth: ${game.depth}</span>
          <span>HP: ${game.hp}/${game.hpMax}</span>
          <span>Potions: ${game.inv.potions.length}/${POTION_CAP}</span>
          <span>Keys: ${game.inv.keys}/${KEY_CAP}</span>
          <span>Torches: ${game.inv.torches}/${TORCH_CAP}</span>
          <span>Fx: P${game.effects.poison} I${game.effects.invis} T${game.effects.transmute} V${game.effects.invincible}</span>
        </div>
      ` : ``}
    `;
  }

  function buildScreenFrame(){
    const capCells = [];
    window.__capCells = capCells;
    const lvl = getLevel(game.depth);
    computeFov(lvl);
    stepCaveBats(lvl);

    const px = lvl.player.x, py = lvl.player.y;
    const vx0 = clamp(px - Math.floor(VIEW_W/2), 0, MAP_W - VIEW_W);
    const vy0 = clamp(py - Math.floor(VIEW_H/2), 0, MAP_H - VIEW_H);

    let out = "";
    for(let y=vy0; y<vy0+VIEW_H; y++){
      for(let x=vx0; x<vx0+VIEW_W; x++){
        let __cellMeta = null;
        const caveMask = isCaveMaskCell(lvl, x, y);
        const glowVis = isLitByStaticLights(lvl, x, y);
        const vis = lvl.visible[x][y] || glowVis;
        // Treat currently-visible (or glow-lit) tiles as seen for rendering.
        let seen = vis ? true : lvl.seen[x][y];
        // Cave fog-of-war: never show remembered cave space (unless glow-lit).
        if(!vis && !glowVis && (lvl.caveMask && lvl.caveMask[x][y])) seen = false;

        if(!seen){
          out += spanChar(' ', COL.rock, false, x, y);
          continue;
        }

        let glyph = null;
        const t = lvl.tiles[x][y];

        if(
          t === TILE.DOOR_C || t === TILE.DOOR_O ||
          t === TILE.LDOOR_C || t === TILE.LDOOR_O ||
          t === TILE.SD_C || t === TILE.SD_O ||
          t === TILE.CAVE_C || t === TILE.CAVE_O ||
          t === TILE.DOWN || t === TILE.SDOWN ||
          t === TILE.BRIDGE_L || t === TILE.BRIDGE_R || t === TILE.BRIDGE_SPAN
        ){
          glyph = t;
        } else if(caveMask){
          // Caves: draw only illuminated floor (dots). Cave walls remain invisible.
          // Corpse tiles are passable and should remain visible once seen.
          if(t === TILE.FLOOR || t === TILE.CORR){
            glyph = TILE.FLOOR;
          } else if(t === TILE.CORPSE){
            glyph = TILE.CORPSE;
          } else {
            glyph = ' ';
          }
        } else if(t === TILE.FLOOR){
          glyph = TILE.FLOOR;
        } else if(t === TILE.CORR){
          glyph = TILE.CORR;
        } else if(t === TILE.CORPSE){
          // Corpse tiles are true map tiles (passable). Render '_' in the ASCII layer.
          // (Later: the glyph canvas may render a sprite overlay.)
          glyph = TILE.CORPSE;
        } else {
          glyph = drawWallGlyph(lvl, x, y);
        }

        let color = baseColorFor(lvl, x, y, glyph);
        const k = keyXY(x,y);

        // Corpse tint in DOM rendering.
        if(t === TILE.CORPSE && lvl.corpses && lvl.corpses.has(k)){
          const meta = lvl.corpses.get(k);
          if(meta && meta.color) color = meta.color;
        }

        // Environment overlay (render-only; passable). Applied only on visible floor/corridor.
        // NOTE: lvl.env stores an environment TYPE string ("water"/"slime"/"fire"/"mist"), not a glyph.
        if(vis && lvl.env){
          const et = lvl.env[x][y];
          if(et && (t === TILE.FLOOR || t === TILE.CORR)){
            glyph = ENV_GLYPH[et] || glyph;
            color = ENV_COLOR[et] || color;
          }
        }

        // BAD Furniture stamp overlay (blocking stone). Rendered on any seen tile.
        if(lvl.furnG && lvl.furnG[x][y]){
          glyph = lvl.furnG[x][y];
          color = COL.rock;
        }

        if(vis){
          if(lvl.items.has(k)){
            const it = lvl.items.get(k);

            // Chaos Relic: logic 'A', render glyph '—ß'
            if(it.type === 'A'){
              glyph = '—ß';
              color = COL.chaosRelic;
            } else {
              glyph = (it.type === ENT.POTION) ? ENT.POTION :
                      (it.type === "__LOOSE_KEY__") ? 'k' :
                      it.type;
              color = (it.type === "__LOOSE_KEY__") ? COL.door : colorForEntity(it);
              // Contaminated Gold: chests with any cgold render as blood-red gold
              if(it.type === ENT.CHEST && ((it.cgold||0) > 0)) color = COL.cgold;
            }
          }

          if(lvl.traps.has(k)){
            const tr = lvl.traps.get(k);
            if(tr.revealed){
              glyph = ENT.TRAP;
              color = COL.trap;
            }else{
              __cellMeta = Object.assign(__cellMeta||{}, {trapHidden:true});
            }
          }
          if(lvl.monsters.has(k)){
            const m = lvl.monsters.get(k);
            glyph = m.glyph;
            if(m && m.chaos){
              color = COL.chaosRelic;
            }else if(m && m.glyph === ENT.SKELETON && m.packLeader){
              color = '#e8e2a0'; // skeleton leader highlight
            }else{
              color = (MONSTER_COLOR[m.glyph] || COL.monster);
            }
          }
          if(lvl.traders.has(k)){
            glyph = ENT.TRADER;
            color = COL.trader;
          }

          // Cave bats (visual-only overlay): show only on empty walkable cave tiles.
          if(lvl.caveBats && lvl.caveBats.length){
            for(const b of lvl.caveBats){
              if(b.x===x && b.y===y){
                if(lvl.caveMask && lvl.caveMask[x][y] && (glyph===TILE.FLOOR || glyph===TILE.CORR || glyph==null)){
                  glyph = '^'
                  color = COL.bat;
                }
                break;
              }
            }
          }

          if(x===lvl.player.x && y===lvl.player.y){
            glyph = ENT.PLAYER;
            color = COL.player;
          }

        } else {
          color = COL.dim;
          if(lvl.traps.has(k) && lvl.traps.get(k).revealed){
            glyph = ENT.TRAP;
          }
        }

        out += spanChar(glyph, color, (!vis && seen), x, y, __cellMeta);
      }
      out += "\n";
    }
    window.__capCells = null;
    return { html: out, frame: { cells: capCells, cols: VIEW_W, rows: VIEW_H } };
  }

  function renderDomScreen(html){
    $screen.innerHTML = html;
  }

  function renderCanvasFrame(frame){
    window.__lastFrame = frame;
    renderGlyphCanvas();
  }

  function renderScreen(){
    const built = buildScreenFrame();
    renderDomScreen(built.html);
    if(!window.SAFE_MODE){
      renderCanvasFrame(built.frame);
    } else {
      // In SAFE_MODE, DOM is visible and canvas is disabled.
      window.__lastFrame = null;
    }
  }

  function renderAll(freeze=false){
    renderHud(freeze);
    renderScreen();
    updateContextPrompt();

    // HUD end-state indicator via Reset button (no extra HUD clutter)
    if(game.ended){
      if(game.victory){
        $restartBtn.classList.add('btn-win');
        $restartBtn.classList.remove('btn-lose');
        $restartBtn.textContent = 'Reset (Victory)';
      }else{
        $restartBtn.classList.add('btn-lose');
        $restartBtn.classList.remove('btn-win');
        $restartBtn.textContent = 'Reset (Defeat)';
      }
    }else{
      $restartBtn.classList.remove('btn-win','btn-lose');
      $restartBtn.textContent = 'Reset';
    }
  }

  // ---------- INPUT ----------
  function handleKey(e){
    let k = e.key.toLowerCase();
    // Arrow keys support
    if(k === 'arrowup') k = 'w';
    else if(k === 'arrowdown') k = 's';
    else if(k === 'arrowleft') k = 'a';
    else if(k === 'arrowright') k = 'd';

    // Input lock: prevents movement/combat during short tile-only animations (e.g., monster death dissolve)
    try{
      if(game && game.__lockInputUntil && performance.now() < game.__lockInputUntil){
        e.preventDefault();
        return;
      }
    }catch(_){}

    


    // Context prompts: Y interacts, movement declines by moving away.
    const lvl = getLevel(game.depth);
    const ctx = getContextPrompt(lvl);

    if(ctx){
      if(ctx.type === 'trade'){
        if(k === 'a' || k === 'b'){
          TRADE_SELECTION = (k === 'a') ? 'A' : 'B';
          renderAll();
          return;
        }
        if(k === 'y'){
          e.preventDefault();
          if(TRADE_SELECTION === 'A') buyTraderPotion();
          else buyTraderUpgrade();
          renderAll();
          return;
        }
      }

      if(ctx.type === 'altar' && k === 'y'){
        e.preventDefault();
        resolveAltarAt(lvl.player.x, lvl.player.y);
        renderAll();
        return;
      }

      if(ctx.type === 'shrine' && k === 'y'){
        e.preventDefault();
        resolveShrineAt(lvl.player.x, lvl.player.y);
        renderAll();
        return;
      }

      if(ctx.type === 'relic' && k === 'y'){
        e.preventDefault();
        resolveChaosRelicAt(lvl.player.x, lvl.player.y);
        renderAll();
        return;
      }
    }
if(game.ended) return;

    if(k === '>'){ e.preventDefault(); tryDescend(); return; }
    if(k === 'p'){ e.preventDefault(); drinkHealingPotion(); return; }
    if(k === '0'){ e.preventDefault(); drinkPotionType(POTION.POISON); return; }
    if(k === '1'){ e.preventDefault(); drinkPotionType(POTION.INVIS); return; }
    if(k === '2'){ e.preventDefault(); drinkPotionType(POTION.TRANSMUTE); return; }
    if(k === '3'){ e.preventDefault(); drinkPotionType(POTION.INVINC); return; }
    if(k === '4'){ e.preventDefault(); drinkPotionType(POTION.TELE); return; }
    // Wait / Rest (turn passes without movement)
    if(k === ' '){
      e.preventDefault();
      tryMove(0,0);
      return;
    }

    if(!(k in DIRS)) return;

    e.preventDefault();
    const [dx,dy] = DIRS[k];
    tryMove(dx,dy);
  }

  document.addEventListener('keydown', handleKey);
  $restartBtn.addEventListener('click', newGame);

  // ---------- START ----------
  renderLegend();
  initGlyphCanvas();

  // ============================
  // Splash intro controller
  // - Max ~5s
  // - Any key/mouse/touch skips instantly
  // ============================
  let __splashDone = false;
  let __splashTimer = 0;

  function endSplashNow(){
    if(__splashDone) return;
    __splashDone = true;

    const el = document.getElementById("splash");
    if(el){
      el.classList.add("hidden");
      // remove from layout for performance
      setTimeout(()=>{ try{ el.remove(); }catch(_){ } }, 0);
    }

    try{ removeSplashSkipListeners(); }catch(_){}
    try{ if(__splashTimer) clearTimeout(__splashTimer); }catch(_){}

    // Start game
    try{ newGame(); }catch(e){ console.error("Failed to start game after splash:", e); }
  }

  function addSplashSkipListeners(){
    const handler = (e) => {
      // prevent "click" from e.g. pressing button twice
      try{ e.preventDefault(); }catch(_){}
      endSplashNow();
    };
    window.__ddSplashSkipHandler = handler;
    window.addEventListener("keydown", handler, { capture:true, passive:false, once:true });
    window.addEventListener("mousedown", handler, { capture:true, passive:false, once:true });
    window.addEventListener("touchstart", handler, { capture:true, passive:false, once:true });
  }

  function removeSplashSkipListeners(){
    const handler = window.__ddSplashSkipHandler;
    if(!handler) return;
    window.removeEventListener("keydown", handler, { capture:true });
    window.removeEventListener("mousedown", handler, { capture:true });
    window.removeEventListener("touchstart", handler, { capture:true });
    window.__ddSplashSkipHandler = null;
  }

  function startAfterSplash(){
    const splash = document.getElementById("splash");
    const reveal = document.getElementById("splashReveal");

    // If splash is missing, just start immediately.
    if(!splash || !reveal){
      endSplashNow();
      return;
    }

    addSplashSkipListeners();

    // Robustness: end after 5s even if animationend doesn't fire
    __splashTimer = setTimeout(endSplashNow, 5000);

    // Prefer animationend for exact timing
    reveal.addEventListener("animationend", () => endSplashNow(), { once:true });
  }

  // Splash will call newGame() when finished
  startAfterSplash();
})();

// ===== CGOLD HELPERS (Burdened Agency) =====
function hasCGold(){
  return (typeof game !== 'undefined' && game.cgold && game.cgold > 0);
}

function purgeAllCGold(message){
  if(typeof game === 'undefined') return;
  if(game.cgold && game.cgold > 0){
    game.cgold = 0;
    if(message){
      addMsg(message);
    }
  }
}

function spendGoldWithCGoldFirst(cost){
  let spentCGold = 0, spentGold = 0;
  if(game.cgold && game.cgold > 0){
    spentCGold = Math.min(game.cgold, cost);
    game.cgold -= spentCGold;
    cost -= spentCGold;
  }
  if(cost > 0){
    spentGold = Math.min(game.gold || 0, cost);
    game.gold = (game.gold || 0) - spentGold;
    cost -= spentGold;
  }
  return { spentCGold, spentGold };
}
// ===== END CGOLD HELPERS =====



</script>
</body>
</html>